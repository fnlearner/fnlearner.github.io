<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="new运算符的实现定义一个函数，以及原型链的方法12345678910111213141516function Testfoo(name) &amp;#123;    console.log(this[name]) &amp;#125;;Testfoo.prototype.sayHello= function()&amp;#123;    console.log(&apos;hello&apos;);    return 1;&amp;#125;/">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript读书笔记">
<meta property="og:url" content="https://github.com/fnlearner/2019/08/05/readingNote-JS/index.html">
<meta property="og:site_name" content="Personal Blog">
<meta property="og:description" content="new运算符的实现定义一个函数，以及原型链的方法12345678910111213141516function Testfoo(name) &amp;#123;    console.log(this[name]) &amp;#125;;Testfoo.prototype.sayHello= function()&amp;#123;    console.log(&apos;hello&apos;);    return 1;&amp;#125;/">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/6/27/16b998bea55f3d96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/6/27/16b99940ab1c985c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://github.com/images/readingNote/set_example.png">
<meta property="og:updated_time" content="2020-10-07T09:41:15.635Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript读书笔记">
<meta name="twitter:description" content="new运算符的实现定义一个函数，以及原型链的方法12345678910111213141516function Testfoo(name) &amp;#123;    console.log(this[name]) &amp;#125;;Testfoo.prototype.sayHello= function()&amp;#123;    console.log(&apos;hello&apos;);    return 1;&amp;#125;/">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/6/27/16b998bea55f3d96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

<link rel="canonical" href="https://github.com/fnlearner/2019/08/05/readingNote-JS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript读书笔记 | Personal Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Personal Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/fnlearner/2019/08/05/readingNote-JS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="ZJS">
      <meta itemprop="description" content="你找到我了呀！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Personal Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-05 10:36:13" itemprop="dateCreated datePublished" datetime="2019-08-05T10:36:13+08:00">2019-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-07 17:41:15" itemprop="dateModified" datetime="2020-10-07T17:41:15+08:00">2020-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="new运算符的实现"><a href="#new运算符的实现" class="headerlink" title="new运算符的实现"></a>new运算符的实现</h2><h3 id="定义一个函数，以及原型链的方法"><a href="#定义一个函数，以及原型链的方法" class="headerlink" title="定义一个函数，以及原型链的方法"></a>定义一个函数，以及原型链的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Testfoo(name) &#123;</span><br><span class="line">    console.log(this[name]) </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Testfoo.prototype.sayHello= <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'hello'</span>);</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">//使用new运算符</span><br><span class="line"><span class="built_in">let</span> aaa = new Testfoo();</span><br><span class="line">aaa.sayHello();//输出hello</span><br><span class="line">//不使用new运算符</span><br><span class="line"><span class="built_in">let</span> testObj  = &#123;&#125;;//创建空对象</span><br><span class="line">testObj=Object.create(Testfoo.prototype);//创建一个具有Testfoo的原型链的空方法</span><br><span class="line">Testfoo.call(testObj);//指定this</span><br><span class="line">console.log(<span class="string">'testObj'</span>,testObj.sayHello());//输出hello</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="call和bind实现"><a href="#call和bind实现" class="headerlink" title="call和bind实现"></a>call和bind实现</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = <span class="keyword">function</span>(ctx, ...argv) &#123;</span><br><span class="line">	ctx = typeof ctx === <span class="string">'object'</span> ? ctx || global : &#123;&#125; // 当 ctx 是对象的时候默认设置为 ctx；如果为 null 则设置为 window 否则为空对象</span><br><span class="line">	const fn = Symbol(<span class="string">'fn'</span>)</span><br><span class="line">	ctx[fn] = this</span><br><span class="line">	ctx[fn](...argv)</span><br><span class="line">        delete ctx[fn]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> objCall = &#123; fn: <span class="string">'functionName'</span>, a: 10 &#125;;</span><br><span class="line">Testfoo.myCall(objCall, <span class="string">'a'</span>);//输出10</span><br></pre></td></tr></table></figure>

<p>ctx代表当前对象，this指针指向的是调用该方法的函数，将this指针指向的方法的引用地址赋值给当前对象内的fn字段。然后调用方法，这样this指针指向的方法的内部this指针的指向就是当前对象，这样就可以实现了this指针的绑定，</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind=<span class="keyword">function</span>(ctx,...arg1)&#123;</span><br><span class="line">    <span class="built_in">return</span> (...arg2)=&gt;&#123;</span><br><span class="line">        <span class="built_in">return</span> this.call(ctx,...arg2,...arg1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> obj2=&#123;a:1&#125;;</span><br><span class="line"><span class="keyword">function</span> addTwoNum(x,y)&#123;</span><br><span class="line">    console.log(x+y,this.a);</span><br><span class="line">&#125;</span><br><span class="line">addTwoNum.myBind(obj2,2)(2);//4 1;</span><br><span class="line">addTwoNum.myBind(obj2,2,2)();//4 1</span><br><span class="line">addTwoNum.myBind(obj2)(2,2);//4 1</span><br></pre></td></tr></table></figure>

<h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><p>iteraotr接口部署在Symbol.iterator上，一些内置类型拥有默认的迭代器行为，其他类型（如 Object）则没有。下表中的内置类型拥有默认的@@iterator方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype[@@iterator]</span><br><span class="line">TypedArray.prototype[@@iterator](</span><br><span class="line">String.prototype[@@iterator]</span><br><span class="line">Map.prototype[@@iterator]</span><br><span class="line">Set.prototype[@@iterator]</span><br></pre></td></tr></table></figure>

<p>遍历接口可以是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function DiyIterator()&#123;</span><br><span class="line">    var arr=[1,2,3];</span><br><span class="line">    var it=arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">    for(var v,res;(res=it.next())&amp;&amp;!res.done;)&#123;</span><br><span class="line">        v=res.value;</span><br><span class="line">        console.log(v);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function DiyIterator()&#123;</span><br><span class="line">    var arr=[1,2,3];</span><br><span class="line">   for(let item of arr)&#123;</span><br><span class="line">       console.log(item);//1,2,3</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String, Array, TypedArray, Map and Set 是所有内置可迭代对象， 因为它们的原型对象都有一个 @@iterator 方法.Object没有部署iterator接口，所以当执行这样的语句时，就会报错<br><img src="https://user-gold-cdn.xitu.io/2019/6/27/16b998bea55f3d96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片"></p>
<p>遍历对象可以用for..in..(for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。),或者用Object.entries(),Object.keys(),Object.values(),或者可以自己实现一个iterator接口，然后就成了这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function seriesIterator()&#123;</span><br><span class="line">    let task=&#123;</span><br><span class="line">        [Symbol.iterator]()&#123;</span><br><span class="line">            var steps=this.action.slice();</span><br><span class="line">            return &#123;</span><br><span class="line">                [Symbol.iterator]()&#123;return this&#125;,</span><br><span class="line">                next(...args)&#123;</span><br><span class="line">                    if(steps.length&gt;0)&#123;</span><br><span class="line">                        //为存放function的数组部署iterator接口</span><br><span class="line">                        let res=steps.shift()(...args);</span><br><span class="line">                        console.log(res);</span><br><span class="line">                        return &#123;</span><br><span class="line">                            value:res,done:false</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        return &#123;done:true&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                return(v)&#123;</span><br><span class="line">                    steps.length=0;</span><br><span class="line">                    return &#123;value:v,done:true&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        action:[]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.action.push(</span><br><span class="line">        function step1(x)&#123;</span><br><span class="line">            console.log(&apos;step 1:&apos;,x);</span><br><span class="line">            return x*2;</span><br><span class="line">        &#125;,</span><br><span class="line">        function step2(x,y)&#123;</span><br><span class="line">            console.log(`step 2 $&#123;x&#125; $&#123;y&#125;`);</span><br><span class="line">            return x+(y*2);</span><br><span class="line">        &#125;,</span><br><span class="line">        function step3(x,y,z)&#123;</span><br><span class="line">            console.log(`step 3 $&#123;x&#125; $&#123;y&#125; $&#123;z&#125;`);</span><br><span class="line">            return (x*y)+z;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    let it=task[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">    it.next(10);</span><br><span class="line">    it.next(10,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/6/27/16b99940ab1c985c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片"></p>
<p>根据MDN文档，如果一个迭代器 @@iterator 没有返回一个迭代器对象，那么它就是一个不符合标准的迭代器，这样的迭代器将会在运行期抛出异常，甚至非常诡异的 Bug。所以 需要返回this，next就是具体的逻辑，科科~</p>
<h2 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h2><h3 id="第一种就是常见的递归"><a href="#第一种就是常见的递归" class="headerlink" title="第一种就是常见的递归"></a>第一种就是常见的递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,[3,2,1,[1,2,3]]];</span><br><span class="line">const bianpinghua1= arr =&gt;&#123;</span><br><span class="line">    return arr.reduce((sum,cur)=&gt;&#123;</span><br><span class="line">        return sum.concat(Array.isArray(cur)?bianpinghua1(cur):cur);</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line">const testArr = bianpinghua1(arr)//[ 1, 2, 3, 3, 2, 1, 1, 2, 3 ]</span><br></pre></td></tr></table></figure>

<h3 id="第二种用es6的generator"><a href="#第二种用es6的generator" class="headerlink" title="第二种用es6的generator"></a>第二种用es6的generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function*  bianpinghua(arr)&#123; </span><br><span class="line">    if(Array.isArray(arr))&#123;</span><br><span class="line">        for(let i of arr)&#123;</span><br><span class="line">            yield* bianpinghua(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else</span><br><span class="line">        yield arr;</span><br><span class="line">&#125;</span><br><span class="line">for(let i of bianpinghua(arr))&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种用es6-我也不知道具体哪个时候出的api-的flat"><a href="#第三种用es6-我也不知道具体哪个时候出的api-的flat" class="headerlink" title="第三种用es6+(我也不知道具体哪个时候出的api)的flat"></a>第三种用es6+(我也不知道具体哪个时候出的api)的flat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr =[1,2,[3,4]];</span><br><span class="line">let temp =arr.flat(Infinity);</span><br><span class="line">console.lg(temp);//[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var  let const"></a>var  let const</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var声明的变量支持变量提升，提升到当前作用域的顶层，level低于函数声明式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">    var name =&apos;Jack&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样输出的name是undefined，var name = ‘Jack’ 在解析器中分为var name ; name = ‘Jack’ 两步，而var的变量提升了var name;所以上述代码在解析器中的眼里是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var name;</span><br><span class="line">    console.log(name);</span><br><span class="line">    name=&apos;Jack&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h3><p>let 和 const 声明的变量不会像var一样造成变量提升,let 和const 声明的变量只有在声明之后才能使用, let声明的变量会造成TDZ(暂时性死区)，在声明变量之前调用会抛出错误 ReferenceError<br>const 声明的变量不允许重新赋值，但是允许修改引用地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const tempObj =&#123;</span><br><span class="line">    a :1</span><br><span class="line">&#125;</span><br><span class="line">console.log(tempObj);//&#123;a:1&#125;</span><br><span class="line">tempObj.a=2;</span><br><span class="line">console.log(tempObj)//&#123;a:2&#125;</span><br></pre></td></tr></table></figure>

<p>可以选择使用Object.freeze()来冻结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const tempObj =&#123;</span><br><span class="line">    a :1</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(tempObj)</span><br><span class="line">console.log(tempObj);//&#123;a:1&#125;</span><br><span class="line">tempObj.a=2;</span><br><span class="line">console.log(tempObj)//&#123;a:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>   在JS里有两类任务，一种是同步任务，一种是异步任务，其中异步任务又含有宏任务(Macrotasks)和微任务(Microtasks )，setTimeout setInterval setImmediate<br>I/O UI渲染 就是异步任务中宏任务的典型代表,而微任务中的代表是Pormise,在JS执行顺序中，最先执行的是同步任务，接着是异步任务中的微任务，再接着是宏任务，微任务和宏任务的是放在不同的执行队列中，只有微任务执行完了才会执行开始调用宏任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  function test()&#123;</span><br><span class="line">      console.log(2);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(1);</span><br><span class="line">  test();</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">      console.log(3);</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise((resolve,rejected)=&gt;&#123;</span><br><span class="line">      resolve(4);</span><br><span class="line">      console.log(6);</span><br><span class="line">  &#125;).then(res=&gt;&#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">// 1 2 6 4 3</span><br></pre></td></tr></table></figure>

<p>console.log(1)和test 均属于同步任务，所以他们两个最先执行，输出1，2 ，setTimeou和promise均属于异步任务，因此它们都被推到全局API中的任务队列中等待执行栈中的任务执行完毕，等执行栈中的任务执行完毕时，就执行microTask queue中的微任务，等微任务执行完成时，再去寻找macroTask queue中是否还有寻找执行的宏任务；对promise来说 new Promise()里面的程序是属于同步任务的,而pormise的then方法才是属于异步任务中的微任务。</p>
<h2 id="数组常见方法的使用"><a href="#数组常见方法的使用" class="headerlink" title="数组常见方法的使用"></a>数组常见方法的使用</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function extractId(data)&#123;</span><br><span class="line">    return data.map(item=&gt;item.id);</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    &#123;</span><br><span class="line">        id:1,</span><br><span class="line">        name:&apos;Tom&apos;,</span><br><span class="line">        age:1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:2,</span><br><span class="line">        name:&apos;Jack&apos;,</span><br><span class="line">        age:2</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">console.log(extractId(arr));//[1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function extractIdAndAge(data)&#123;</span><br><span class="line">    return data.map(item=&gt;[item.id,item.age]);</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    &#123;</span><br><span class="line">        id:1,</span><br><span class="line">        name:&apos;Tom&apos;,</span><br><span class="line">        age:2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:2,</span><br><span class="line">        name:&apos;Jack&apos;,</span><br><span class="line">        age:1</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">console.log(extractId(arr));//[ [ 1, 2 ], [ 2, 1 ] ]</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。filter方法返回的元素的boolean值为真</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(data)&#123;</span><br><span class="line">    return data.filter(item=&gt;item)</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    undefined,null,NaN,0,false,&apos;&apos;,1</span><br><span class="line">]</span><br><span class="line">console.log(arr)//1</span><br><span class="line">因为undefined,null, NaN , 0 ,false ，&apos;&apos;转为boolean值后均为false</span><br></pre></td></tr></table></figure>

<h3 id="every-some"><a href="#every-some" class="headerlink" title="every,some"></a>every,some</h3><p>every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。若收到一个空数组，此方法在一切情况下都会返回 true。every遍历的数组的每个元素都需要满足判断条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test(data)&#123;</span><br><span class="line">    return data.every(item=&gt;item&gt;1)</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    2,3,4,0,0,1,1,null,undefined</span><br><span class="line">]</span><br><span class="line">console.log(test(arr))//false，因为0&lt;1,null 和undefined与数字比较时会转成数字0</span><br><span class="line">let arr1= [</span><br><span class="line">    2,3,4,5,6,7,8</span><br><span class="line">]</span><br><span class="line">console.log(test(arr1));//true</span><br></pre></td></tr></table></figure>

<p>some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。只要一个符合条件，就返回true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(data)&#123;</span><br><span class="line">    return data.some(item=&gt;item&gt;1)</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    2,3,4,0,0,1,1,null,undefined</span><br><span class="line">]</span><br><span class="line">console.log(test(arr))//true</span><br></pre></td></tr></table></figure>

<h3 id="splice、slice"><a href="#splice、slice" class="headerlink" title="splice、slice"></a>splice、slice</h3><p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。<br>splice(startNumber,deleteCount,…item)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3];</span><br><span class="line">arr.splice(0,1);//arr-&gt;[2,3]</span><br><span class="line"></span><br><span class="line">arr.splice(0,0,1);//arr-&gt;[ 1, 2, 3, 4, 5, 6, 7, 8 ]</span><br></pre></td></tr></table></figure>

<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。不给slice添加参数时默认返回所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1= [</span><br><span class="line">    2,3,4,5,6,7,8</span><br><span class="line">]</span><br><span class="line">let temp =arr1.slice(0,2)</span><br><span class="line">console.log(temp,arr1);//[ 2, 3 ] [ 2, 3, 4, 5, 6, 7, 8 ]</span><br></pre></td></tr></table></figure>

<h3 id="push-pop-shift-unshift"><a href="#push-pop-shift-unshift" class="headerlink" title="push pop shift unshift"></a>push pop shift unshift</h3><p>pop 返回数组最后一个元素，改变原数组<br>shift 返回数组第一个元素，改变原数组<br>push  向数组的末尾添加元素<br>unshift 向数组的头部添加元素</p>
<h3 id="includes-indexof-lastIndexOf"><a href="#includes-indexof-lastIndexOf" class="headerlink" title="includes indexof lastIndexOf"></a>includes indexof lastIndexOf</h3><p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">console.log(arr.includes(1))//true</span><br></pre></td></tr></table></figure>

<p>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>lastIndexOf与此类似，返回给定元素的最后一个索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr =[1,2,3,1];</span><br><span class="line">console.log(arr.indexOf(1))//0</span><br><span class="line">console.log(arr.lastIndexOf(2))//3</span><br><span class="line">console.log(arr.indexOf(4))//-1</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换有两种，要么是显示类型转换，要么是隐式类型转换</p>
<h3 id="显示类型转换见W3C"><a href="#显示类型转换见W3C" class="headerlink" title="显示类型转换见W3C"></a>显示类型转换见<a href="https://www.w3school.com.cn/js/js_type_conversion.asp" target="_blank" rel="noopener">W3C</a></h3><hr>
<h3 id="隐式类型转换常见于运算符比较隐式转换，参考ES规范11-9-3"><a href="#隐式类型转换常见于运算符比较隐式转换，参考ES规范11-9-3" class="headerlink" title="隐式类型转换常见于运算符比较隐式转换，参考ES规范11.9.3"></a>隐式类型转换常见于运算符比较隐式转换，参考<a href="http://yanhaijing.com/es5/#199" target="_blank" rel="noopener">ES规范</a>11.9.3</h3><hr>
<pre><code>若Type(x)与Type(y)相同， 则
若Type(x)为Undefined， 返回true。
若Type(x)为Null， 返回true。
若Type(x)为Number， 则
若x为NaN， 返回false。
若y为NaN， 返回false。
若x与y为相等数值， 返回true。
若x 为 +0 且 y为−0， 返回true。
若x 为 −0 且 y为+0， 返回true。
返回false。
若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false。
若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false。
当x和y为引用同一对象时返回true。否则，返回false。
若x为null且y为undefined， 返回true。
若x为undefined且y为null， 返回true。
若Type(x) 为 Number 且 Type(y)为String， 返回comparison x == ToNumber(y)的结果。
若Type(x) 为 String 且 Type(y)为Number，
返回比较ToNumber(x) == y的结果。
若Type(x)为Boolean， 返回比较ToNumber(x) == y的结果。
若Type(y)为Boolean， 返回比较x == ToNumber(y)的结果。
若Type(x)为String或Number，且Type(y)为Object，返回比较x == ToPrimitive(y)的结果。
若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) == y的结果。
返回false。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[]==![]</span><br><span class="line">//等式右边的显然是显示转换，根据规则，所有对象或数组的boolean总是为true,那么取反也就是false,那么等式就变成[]==false,接下来是等式的隐式类型转换，明显等式左边的是一个数组，那么就调用它的ToPrimitive方法，返回&apos;&apos;，因此等式变成&apos;&apos;==false，</span><br><span class="line">//接着进行基本类型转换,&apos;&apos;-&gt;0,false-&gt;0，最后等式变成0==0，所以结果是true</span><br><span class="line">1==&apos;1&apos;//true</span><br><span class="line">1==null//fasle</span><br><span class="line">1==undefined//false</span><br><span class="line">1==true//true</span><br><span class="line">1==[]//false</span><br><span class="line">&#123;&#125;==0//Unexpected token ==,这是因为AST把第一个&#123;&#125;不是解析成对象，而是解析成一个block(代码块),因此其实等式左边是没有值的，因此抛出一个异常,有疑问自行google AST explorer</span><br><span class="line">0==&#123;&#125;//true</span><br><span class="line">&#123;&#125;+1==1//true ,对于加法运算，JS会把运算符两侧的对象调用toPrimitive方法，因此等式变成&apos;&apos;+1==1-&gt;&apos;1&apos;==1-&gt;1==1</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JS中对闭包的解释是在函数中调用另一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;</span><br><span class="line">    return function inner()&#123;</span><br><span class="line">        return ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = 2;</span><br><span class="line">const testVim = test(a);//testVim 在没有销毁时始终占有function inner的内存地址</span><br><span class="line"></span><br><span class="line">console.log(&quot;testVim:&quot;, testVim());//3</span><br><span class="line">console.log(&quot;testVim:&quot;, testVim());//4</span><br><span class="line">console.log(&quot;testVim:&quot;, testVim());//5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    document.body.style.fontSize = size + &apos;px&apos;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var size12 = makeSizer(12);</span><br><span class="line">var size14 = makeSizer(14);</span><br><span class="line">var size16 = makeSizer(16);</span><br></pre></td></tr></table></figure>

<p>size12，size14 和 size16 三个函数将分别把 body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;size-12&apos;).onclick = size12;</span><br><span class="line">document.getElementById(&apos;size-14&apos;).onclick = size14;</span><br><span class="line">document.getElementById(&apos;size-16&apos;).onclick = size16;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot; id=&quot;size-12&quot;&gt;12&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; id=&quot;size-14&quot;&gt;14&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; id=&quot;size-16&quot;&gt;16&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="统计同一个字符串中出现次数最多的字符"><a href="#统计同一个字符串中出现次数最多的字符" class="headerlink" title="统计同一个字符串中出现次数最多的字符"></a>统计同一个字符串中出现次数最多的字符</h2><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>用正则匹配，\w可以用.代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let str =&apos;aaaaaaaabbbbbccccccccccccc&apos;;</span><br><span class="line">let getMaxCount = (str)=&gt;&#123;</span><br><span class="line">    const reg = /(\w)\1+/g;</span><br><span class="line">    const result = str.match(reg);</span><br><span class="line">    let finalResult = result.map(item=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            length:item.length,</span><br><span class="line">            item:item[0]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).sort((a,b)=&gt;&#123;</span><br><span class="line">        return a.length-b.length&lt;0</span><br><span class="line">    &#125;);</span><br><span class="line">    // console.log(finalResult)</span><br><span class="line">    return finalResult[0];</span><br><span class="line">&#125;</span><br><span class="line">getMaxCount(str);</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let getMaxCount_2 = (str)=&gt;&#123;</span><br><span class="line">    let temp = str.split(&quot;&quot;);</span><br><span class="line">    let result  = temp.reduce((obj,cur)=&gt;&#123;</span><br><span class="line">        obj[cur] = ++obj[cur]||1;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">    let max = &#123;</span><br><span class="line">        len:0,</span><br><span class="line">        item:&apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    for(let index in result)&#123;</span><br><span class="line">        if(result[index]&gt;max.len)&#123;</span><br><span class="line">            max.len = result[index];</span><br><span class="line">            max.item = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">getMaxCount_2(str);</span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const isUnique = (arr)=&gt;&#123;</span><br><span class="line">    const equals = (a, b) =&gt; &#123;</span><br><span class="line">        if (a === b) return true;</span><br><span class="line">        if (a instanceof Date &amp;&amp; b instanceof Date) return a.getTime() === b.getTime();</span><br><span class="line">        if (!a || !b || (typeof a !== &apos;object&apos; &amp;&amp; typeof b !== &apos;object&apos;)) return a === b;</span><br><span class="line">        if (a === null || a === undefined || b === null || b === undefined) return false;</span><br><span class="line">        if (a.prototype !== b.prototype) return false;</span><br><span class="line">        let keys = Object.keys(a);</span><br><span class="line">        if (keys.length !== Object.keys(b).length) return false;</span><br><span class="line">        return keys.every(k =&gt; equals(a[k], b[k]));</span><br><span class="line">      &#125;;</span><br><span class="line">    </span><br><span class="line">    for(let i =0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        for(let j =i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">            if(!!equals(arr[i],arr[j]))&#123;</span><br><span class="line">                arr.splice(j,1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">isUnique([123, [1, 2, 3], [1, &quot;2&quot;, 3], [1, 2, 3], &quot;meili&quot;,&#123;a:1,b:1&#125;,&#123;b:1,a:1&#125;]);</span><br></pre></td></tr></table></figure>

<h2 id="数组转链表"><a href="#数组转链表" class="headerlink" title="数组转链表"></a>数组转链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*链表节点</span><br><span class="line">*param &#123;*&#125; val</span><br><span class="line">*param &#123;ListNode&#125; next</span><br><span class="line">**/</span><br><span class="line">function ListNode(val,next=null)&#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*将数组转为链表</span><br><span class="line">*param &#123;array&#125; a</span><br><span class="line">*param &#123;ListNode&#125; </span><br><span class="line">**/</span><br><span class="line">const getListFromArray=a=&gt;&#123;</span><br><span class="line">    let dummy = new ListNode()</span><br><span class="line">    let pre =dummy;</span><br><span class="line">    a.forEach(x =&gt; &#123;</span><br><span class="line">        return pre=pre.next=new ListNode(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*将链表转为数组</span><br><span class="line">*param &#123;array&#125; </span><br><span class="line">*param &#123;ListNode&#125; node </span><br><span class="line">**/</span><br><span class="line">const getArrayFromList = index=&gt;&#123;</span><br><span class="line">    let a=[];</span><br><span class="line">    while(node)&#123;</span><br><span class="line">        a.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map,Set,WeakMap,WeakSet"></a>Map,Set,WeakMap,WeakSet</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值<br>new Map([iterable])<br>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined</p>
<p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>
<ul>
<li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li>
<li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li>
<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>
<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。<br>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>
<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">[0,0];</span><br><span class="line">]);</span><br><span class="line">map.size;//1</span><br><span class="line">for(let key of map.keys())&#123;</span><br><span class="line">    console.log(key)//0</span><br><span class="line">&#125;</span><br><span class="line">for(let [key,value] of map.keys())&#123;</span><br><span class="line">    console.log(key,value)//0 0</span><br><span class="line">&#125;</span><br><span class="line">for(let value of map.keys())&#123;</span><br><span class="line">    console.log(value)//0 0</span><br><span class="line">&#125;</span><br><span class="line">map.clear()//清楚map对象所有键值对</span><br><span class="line">map.delete(key)/*如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false */</span><br><span class="line">map.get(key)/*返回键对应的值，如果不存在，则返回undefined。*/</span><br><span class="line">map.set(key,value);/*设置Map对象中键的值。返回该Map对象。*/</span><br><span class="line">map.has(key)/*返回一个布尔值，表示Map实例是否包含键对应的值。*/</span><br></pre></td></tr></table></figure>

<ul>
<li>NaN 也可以作为Map对象的键。虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，但下面的例子表明，NaN作为Map的键来说是没有区别的:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, &quot;not a number&quot;);</span><br><span class="line"></span><br><span class="line">myMap.get(NaN); // &quot;not a number&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span><br><span class="line">var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];</span><br><span class="line">var myMap = new Map(kvArray);</span><br><span class="line"></span><br><span class="line">console.log(Array.from(myMap)); // 输出和kvArray相同的数组</span><br></pre></td></tr></table></figure>

<p>Map对象间可以进行合并，但是会保持键的唯一性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var first = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">var second = new Map([</span><br><span class="line">  [1, &apos;uno&apos;],</span><br><span class="line">  [2, &apos;dos&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span><br><span class="line">// 展开运算符本质上是将Map对象转换成数组。</span><br><span class="line">var merged = new Map([...first, ...second]);</span><br><span class="line"></span><br><span class="line">console.log(merged.get(1)); // uno</span><br><span class="line">console.log(merged.get(2)); // dos</span><br><span class="line">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>

<p>Map对象也能与数组合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var merged = new Map([...first, ...second, [1, &apos;eins&apos;]]);</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>new Set([iterable]);</p>
<ul>
<li>如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。</li>
<li>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6的这个Set结构出来以后一直被当作一个去重的的一个省时省力的结构，前提是去重的元素不是引用类型的。<br><img src="/images/readingNote/set_example.png" alt="图片"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr =[1,2,4,5,6,1,2];</span><br><span class="line">let set2= new Set(arr);//1,2,3,4,5,6  生成的是Set结构，不是Array结构</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(value) </span><br><span class="line">//在Set对象尾部添加一个元素。返回该Set对象。</span><br><span class="line">clear()</span><br><span class="line">//移除Set对象内的所有元素。</span><br><span class="line">delete(value)</span><br><span class="line">//移除Set的中与这个值相等的元素</span><br><span class="line">entries()</span><br><span class="line">//返回一个新的迭代器对象,[value,value]数组，为了使这个方法和Map对象保持相似， 每个值的键和值相等。</span><br><span class="line">has()</span><br><span class="line">//返回一个布尔值，表示该值在Set中存在与否。</span><br><span class="line">values()</span><br><span class="line">//返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</span><br></pre></td></tr></table></figure>

<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。<br>new WeakMap([iterable])<br>Iterable 是一个数组（二元数组）或者其他可迭代的且其元素是键值对的对象。每个键值对会被加到新的 WeakMap 里。null 会被当做 undefined</p>
<p>WeakMap 的 key 只能是 Object 类型。 原始数据类型 是不能作为 key 的（比如 Symbol）。<br>WeakMap 的 key是不可枚举的，因为它的弱引用机制，不确保key是否会被GC;没有部署迭代器，不能用for循环遍及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(key)</span><br><span class="line">get(key)</span><br><span class="line">has(key)</span><br><span class="line">set(key,value)</span><br></pre></td></tr></table></figure>

<p>当WeakMap里面的key设置为null时，WeakMap里面将不再存储key=null的映射，取消内存引用避免造成内存泄漏，从而使得不再被使用的key能被正确GC.</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 对象允许你将弱保持对象存储在一个集合中。<br>new WeakSet([iterable]);<br>如果传入一个可迭代对象作为参数, 则该对象的所有迭代值都会被自动添加进生成的 WeakSet 对象中.<br>WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次.</p>
<p>它和 Set 对象的区别有两点:</p>
<ul>
<li>WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以.</li>
<li>WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素.</li>
</ul>
<p>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear()</span><br><span class="line">delete(value)</span><br><span class="line">get(value)</span><br><span class="line">has(value)</span><br><span class="line">add(value)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet();</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(window);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(window); // true</span><br><span class="line">ws.has(foo);    // false, 对象 foo 并没有被添加进 ws 中 </span><br><span class="line"></span><br><span class="line">ws.delete(window); // 从集合中删除 window 对象</span><br><span class="line">ws.has(window);    // false, window 对象已经被删除了</span><br><span class="line"></span><br><span class="line">ws.clear(); // 清空整个 WeakSet 对象</span><br></pre></td></tr></table></figure>

<h2 id="小数和整数的那些事"><a href="#小数和整数的那些事" class="headerlink" title="小数和整数的那些事"></a>小数和整数的那些事</h2><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const num = 2147483648.88;</span><br><span class="line">console.log(num&gt;&gt;&gt;0);// 2147483648 </span><br><span class="line">console.log(Math.trunc(num))//2147483648</span><br><span class="line">//Math.ceil,Math.round,Math.floor均可以取整，从左到右依次是向上取整，四舍五入取整，向下取整</span><br></pre></td></tr></table></figure>

<h3 id="取小数"><a href="#取小数" class="headerlink" title="取小数"></a>取小数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const num = 2147483648.88;</span><br><span class="line">console.log(num%1)//0.880000114440918</span><br><span class="line">console.log(3.1|0)//3;</span><br><span class="line">console.log(num|0)//-2147483648，&apos;|&apos;由于仅能处理32位整数，所以一旦数字超过这个范围，&apos;|&apos;就不能正确处理</span><br><span class="line">// 由于涉及到浮点数计算，无论加减乘除都会出现精度缺失问题</span><br></pre></td></tr></table></figure>

<h3 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//由于精度的问题，浮点数不能用&apos;===&apos;和&apos;!==&apos;来进行比较</span><br><span class="line">let a =0.1,b=0.2,c=0.3;</span><br><span class="line">let sum =a+b;</span><br><span class="line">console.log(sum==c);//false,由于精度问题，所以0.1+0.2是不等于0.3的，应该等于0.30000000000000004</span><br><span class="line">function fract(a,b)&#123;</span><br><span class="line">  return Math.abs(a-b)&lt;Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">console.log(fract(sum,c));//true,Number.EPSILON 属性表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。</span><br></pre></td></tr></table></figure>

<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><h3 id="lt-lt-左移"><a href="#lt-lt-左移" class="headerlink" title="&lt;&lt; 左移"></a>&lt;&lt; 左移</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。</span><br><span class="line">9&lt;&lt;2 =36;</span><br><span class="line">9(base 10) =00000000000000000000000000001001 (base 2)</span><br><span class="line">9&lt;&lt;2(base 10) =00000000000000000000000000100100 (base 2)</span><br><span class="line">//在数字 x 上左移 y 比特得到 x * 2y.因此9&lt;&lt;2 = 9*Math.pow(2,2)</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt-右移-有符号"><a href="#gt-gt-右移-有符号" class="headerlink" title="&gt;&gt; 右移(有符号)"></a>&gt;&gt; 右移(有符号)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。</span><br><span class="line">9 (base 10): 00000000000000000000000000001001 (base 2)            </span><br><span class="line">9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</span><br><span class="line">------</span><br><span class="line">-9 (base 10): 11111111111111111111111111110111 (base 2)</span><br><span class="line">-9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt-gt-右移-无符号"><a href="#gt-gt-gt-右移-无符号" class="headerlink" title="&gt;&gt;&gt;右移(无符号)"></a>&gt;&gt;&gt;右移(无符号)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</span><br><span class="line">*/</span><br><span class="line">9 (base 10): 00000000000000000000000000001001 (base 2)</span><br><span class="line">9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</span><br><span class="line">-------</span><br><span class="line">-9 (base 10): 11111111111111111111111111110111 (base 2)</span><br><span class="line">-9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)</span><br></pre></td></tr></table></figure>

<h3 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h3><ul>
<li>Number<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;1&apos;;</span><br><span class="line">Number(str)//1</span><br><span class="line">Numebr(&apos;&apos;)//0</span><br><span class="line">Number(&apos;123n&apos;)//NaN</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Number 从字符串第一位开始判断，只要有一个不是数字，返回NaN，如果是空串，返回0；</p>
<ul>
<li>parseInt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;&apos;)//NaN</span><br><span class="line">parseInt(&apos;123&apos;)//123</span><br><span class="line">parseInt(&apos;123n&apos;)//123</span><br><span class="line">parseInt(&apos;n123n&apos;)//NaN</span><br></pre></td></tr></table></figure>

<p>parseInt 解析 过程中，当非数字字符排在数字后面时，返回解析到的数字，当非数字字符排在数字前面时，返回NaN</p>
<ul>
<li>‘&gt;&gt;底层二进制符’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;123&apos; &gt;&gt; 0 //123</span><br><span class="line">&apos;123n&apos; &gt;&gt; 0 //0</span><br><span class="line">&apos;n123&apos; &gt;&gt;0 //0 </span><br><span class="line">&apos;&apos; &gt;&gt; 0 //0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>无效数字返回0，有效数字返回数字</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="blockquote-center">我会努力更新的</blockquote>
    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="ZJS 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tagstags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2019/08/05/git-command/" rel="next" title="git常用命令集合">
      git常用命令集合 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#new运算符的实现"><span class="nav-number">1.</span> <span class="nav-text">new运算符的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义一个函数，以及原型链的方法"><span class="nav-number">1.1.</span> <span class="nav-text">定义一个函数，以及原型链的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call和bind实现"><span class="nav-number">2.</span> <span class="nav-text">call和bind实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#call"><span class="nav-number">2.1.</span> <span class="nav-text">call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-number">2.2.</span> <span class="nav-text">bind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器iterator"><span class="nav-number">3.</span> <span class="nav-text">迭代器iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扁平化"><span class="nav-number">4.</span> <span class="nav-text">扁平化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种就是常见的递归"><span class="nav-number">4.1.</span> <span class="nav-text">第一种就是常见的递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种用es6的generator"><span class="nav-number">4.2.</span> <span class="nav-text">第二种用es6的generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三种用es6-我也不知道具体哪个时候出的api-的flat"><span class="nav-number">4.3.</span> <span class="nav-text">第三种用es6+(我也不知道具体哪个时候出的api)的flat</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#var-let-const"><span class="nav-number">5.</span> <span class="nav-text">var  let const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#var"><span class="nav-number">5.1.</span> <span class="nav-text">var</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let-const"><span class="nav-number">5.2.</span> <span class="nav-text">let const</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件循环"><span class="nav-number">6.</span> <span class="nav-text">事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#event-loop"><span class="nav-number">6.1.</span> <span class="nav-text">event loop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组常见方法的使用"><span class="nav-number">7.</span> <span class="nav-text">数组常见方法的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">7.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">7.2.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#every-some"><span class="nav-number">7.3.</span> <span class="nav-text">every,some</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#splice、slice"><span class="nav-number">7.4.</span> <span class="nav-text">splice、slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push-pop-shift-unshift"><span class="nav-number">7.5.</span> <span class="nav-text">push pop shift unshift</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#includes-indexof-lastIndexOf"><span class="nav-number">7.6.</span> <span class="nav-text">includes indexof lastIndexOf</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">8.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#显示类型转换见W3C"><span class="nav-number">8.1.</span> <span class="nav-text">显示类型转换见W3C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式类型转换常见于运算符比较隐式转换，参考ES规范11-9-3"><span class="nav-number">8.2.</span> <span class="nav-text">隐式类型转换常见于运算符比较隐式转换，参考ES规范11.9.3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">9.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计同一个字符串中出现次数最多的字符"><span class="nav-number">10.</span> <span class="nav-text">统计同一个字符串中出现次数最多的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正则"><span class="nav-number">10.1.</span> <span class="nav-text">正则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduce"><span class="nav-number">10.2.</span> <span class="nav-text">reduce</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组去重"><span class="nav-number">11.</span> <span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组转链表"><span class="nav-number">12.</span> <span class="nav-text">数组转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-Set-WeakMap-WeakSet"><span class="nav-number">13.</span> <span class="nav-text">Map,Set,WeakMap,WeakSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">13.1.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">13.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakMap"><span class="nav-number">13.3.</span> <span class="nav-text">WeakMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakSet"><span class="nav-number">13.4.</span> <span class="nav-text">WeakSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小数和整数的那些事"><span class="nav-number">14.</span> <span class="nav-text">小数和整数的那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#取整"><span class="nav-number">14.1.</span> <span class="nav-text">取整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取小数"><span class="nav-number">14.2.</span> <span class="nav-text">取小数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点数比较"><span class="nav-number">14.3.</span> <span class="nav-text">浮点数比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位操作符"><span class="nav-number">15.</span> <span class="nav-text">位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-lt-左移"><span class="nav-number">15.1.</span> <span class="nav-text">&lt;&lt; 左移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gt-gt-右移-有符号"><span class="nav-number">15.2.</span> <span class="nav-text">&gt;&gt; 右移(有符号)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gt-gt-gt-右移-无符号"><span class="nav-number">15.3.</span> <span class="nav-text">&gt;&gt;&gt;右移(无符号)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串转整数"><span class="nav-number">15.4.</span> <span class="nav-text">字符串转整数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">16.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZJS"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">ZJS</p>
  <div class="site-description" itemprop="description">你找到我了呀！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/1525039433@qq.com" title="E-Mail → 1525039433@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZJS</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
