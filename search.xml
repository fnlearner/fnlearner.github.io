<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自适应布局</title>
    <url>/2019/08/07/Adaptive/</url>
    <content><![CDATA[<h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p>css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">        display: grid;</span><br><span class="line">        grid-template-columns:repeat(auto-fill,27rem);</span><br><span class="line">        grid-gap:3rem 1.5rem;</span><br><span class="line">&#125;       </span><br><span class="line">.main &gt; .item&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        width:100%;</span><br><span class="line">        height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码效果能让每一行都尽量铺满</p>
<html>
    <head><meta name="generator" content="Hexo 3.9.0">
        <style>
            .main{
                display: grid;
                grid-template-columns:repeat(auto-fill,27rem);
                grid-gap:3rem 1.5rem;
            }
            .main > .item{
                  background:linear-gradient(45deg,black,transparent);
                width:100%;
                height: 100px;
            }
        </style>
    </head>
    <body>
            <div class="main">
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
                <div class="item"></div>
            </div>
    </body>
</html>

<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">    border-spacing: 30px 0;</span><br><span class="line">&#125;</span><br><span class="line">.container &gt;div&#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    background-color: #00ffff;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 25vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;item&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;item&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;item&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;item&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<html>
    <head><meta name="generator" content="Hexo 3.9.0">
        <style>
            .container{
                display: table;
                width: 100%;
                border-spacing: 30px 0;
            }
            .container >.item{
                display: table-cell;
                background-color: #00ffff;
                border: 1px solid black;
                height: 200px;
                width: 25vw;
            }
        </style>
    </head>
    <body>
     <div class="container">
        <div class="item">item</div>
        <div class="item">item</div>
        <div class="item">item</div>
        <div class="item">item</div>
    </div>
    </body>
</html>

<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    justify-content: flex-start;             </span><br><span class="line">&#125;</span><br><span class="line">.main &gt; .item&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    background:linear-gradient(45deg,black,transparent);</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<html>
    <head><meta name="generator" content="Hexo 3.9.0">
        <style>
            .main{
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-start;
            }
            .main > .item{
                width: 300px;
                background:linear-gradient(45deg,black,transparent);
                height: 100px;
            }
        </style>
    </head>
    <body>
        <div class="main">
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
        </div>
    </body>
</html>

<p>以下<a href="https://juejin.im/post/5b90e07ce51d450e6a2dd140" target="_blank" rel="noopener">原文</a></p>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (min-width:240px) &#123;</span><br><span class="line">    html, body, button, input, select, textarea &#123;</span><br><span class="line">        font-size:9px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width:320px) &#123;</span><br><span class="line">	html, body, button, input, select, textarea &#123;</span><br><span class="line">		font-size:12px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 红米Note2</span><br><span class="line">@media screen and (min-width:360px) &#123;</span><br><span class="line">	html, body, button, input, select, textarea &#123;</span><br><span class="line">		font-size:13.5px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width:375px) &#123;</span><br><span class="line">	html, body, button, input, select, textarea &#123;</span><br><span class="line">		font-size:14.0625px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JS设置html的font-size大小"><a href="#JS设置html的font-size大小" class="headerlink" title="JS设置html的font-size大小"></a>JS设置html的font-size大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.documentElement.style.fontSize = document.documentElement.clientWidth / 750 + &apos;px&apos;;</span><br></pre></td></tr></table></figure>

<h2 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度</span><br><span class="line">html&#123;</span><br><span class="line">    font-size: 10vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javscript复杂判断</title>
    <url>/2019/08/07/Javscript_complex_judge/</url>
    <content><![CDATA[<p>在公司维护前人代码的时候，经常会遇见一堆的if-else语句</p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag = (status)=&gt;&#123;</span><br><span class="line">    if(status ==0)&#123;</span><br><span class="line">        //do somethind</span><br><span class="line">    &#125;else if(status==1)&#123;</span><br><span class="line">        //do somethind</span><br><span class="line">    &#125;else if(status ==2)&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;else if(status ==3)&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>或许还可以用switch-case的写法</p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag = (status)=&gt;&#123;</span><br><span class="line">    swtich(status)&#123;</span><br><span class="line">        case 0:</span><br><span class="line">            //do something</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">        case 2:</span><br><span class="line">            //do something</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            //do something</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如case 1和 case 2的处理情况都一样，可以像上面的写法.</p>
<p>然鹅如果需要判断的条件多的时候，如果继续用if-else的写法，那么工作量会翻倍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag = (status,type)=&gt;&#123;</span><br><span class="line">    if(type==0)&#123;</span><br><span class="line">        if(status ==0)&#123;</span><br><span class="line">            //do somethind</span><br><span class="line">        &#125;else if(status==1)&#123;</span><br><span class="line">            //do somethind</span><br><span class="line">        &#125;else if(status ==2)&#123;</span><br><span class="line">            //do something</span><br><span class="line">        &#125;else if(status ==3)&#123;</span><br><span class="line">            //do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(type==1)&#123;</span><br><span class="line">         if(status ==0)&#123;</span><br><span class="line">            //do somethind</span><br><span class="line">        &#125;else if(status==1)&#123;</span><br><span class="line">            //do somethind</span><br><span class="line">        &#125;else if(status ==2)&#123;</span><br><span class="line">            //do something</span><br><span class="line">        &#125;else if(status ==3)&#123;</span><br><span class="line">            //do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法太麻瓜了吧，简直反人类</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const actions = ()=&gt;&#123;</span><br><span class="line">    function A()&#123;</span><br><span class="line">        return &apos;A&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    function B()&#123;</span><br><span class="line">        return &apos;B&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Map([</span><br><span class="line">        [&apos;0_0&apos;,A],</span><br><span class="line">        [&apos;0_1&apos;,A],</span><br><span class="line">        [&apos;0_2&apos;,B]</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line">const flag =(status ,type)=&gt;&#123;</span><br><span class="line">    const action = actions().get(`$&#123;type&#125;_$&#123;status&#125;`);</span><br><span class="line">    console.log(action());</span><br><span class="line">&#125;</span><br><span class="line">flag(0,0);//A</span><br></pre></td></tr></table></figure>

<p>直接将逻辑封装起来，然后在另一个函数调用，看起来就干净很多！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const actions = ()=&gt;&#123;</span><br><span class="line">    function A()&#123;</span><br><span class="line">        return &apos;A&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    function B()&#123;</span><br><span class="line">        return &apos;B&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Map([</span><br><span class="line">        [/^0_[0-3]/,A],</span><br><span class="line">        [/1_[0-2]/,A],</span><br><span class="line">        [/1_1/,B]</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line">const flag =(status ,type)=&gt;&#123;</span><br><span class="line">     const action = [...actions()].filter(([key,value])=&gt;&#123;</span><br><span class="line">        return key.test(`$&#123;type&#125;_$&#123;status&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    action.forEach(([_,value])=&gt;&#123;</span><br><span class="line">        console.log(&quot;value.apply(this):&quot;, value.apply(this));//A</span><br><span class="line">        value.call(this);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">flag(1,1);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectKeys</title>
    <url>/2020/07/07/ObjectKeys/</url>
    <content><![CDATA[<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h3><p>上一个Object.keys()在js中的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    name:<span class="string">'John'</span>,</span><br><span class="line">    age:12,</span><br><span class="line">    id:1</span><br><span class="line">&#125;</span><br><span class="line">Object.keys(obj).forEach(key=&gt;&#123;</span><br><span class="line">    //output   <span class="string">'John'</span>,12,1</span><br><span class="line">    console.log(obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>试试ts版的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person =&#123;</span><br><span class="line">    name:string,</span><br><span class="line">    id:number,</span><br><span class="line">    age:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">declare</span> const me:Person;</span><br><span class="line"></span><br><span class="line">Object.keys(me).forEach(key=&gt;&#123;</span><br><span class="line">    // 在ts里面这个时候编辑器会提示我们错误</span><br><span class="line">    console.log(me[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type ‘Person’. No index signature with a parameter of type ‘string’ was found on type ‘Person’</code></p>
<p>来看一下Object.keys的类型声明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface ObjectConstructor &#123;</span><br><span class="line">    keys(o: object): string[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法接收任意类型的object作为输入并且返回string类型的数组作为输出。</p>
<p>来回到之前的问题，为什么会报错？</p>
<p>在Person中，具体的key值分别是name|age|id，但是它们的索引签名并不是string类型，所以当在keys方法中返回的string数组的每一个key都是string类型时，跟Person中的每个key的索引签名并不匹配，所以是不能通过string类型的key访问到me中的数据，<br>如果Person这样定义:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    [key:string]:string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样写，那么之前的forEach语句就可以正常执行不报错，而且循环中的每个item的类型推导是string类型<br><img src="/images/ObjectKeys/code2.png" alt="code"><br><br><br><strong>注意</strong>：那么这个就很有可能是报错的原因。更具体的类型在已经建立索引的库中引发的问题，或者是因为类型过于复杂导致类型不能正确推导</p>
<p>那么遇到这个问题该怎么解决？</p>
<p>最菜的方法就是把tsconfig.json里面的noImplicitAny选项给关了，那回家用JS吧</p>
<h3 id="Type-casting-类型转换"><a href="#Type-casting-类型转换" class="headerlink" title="Type-casting(类型转换)"></a>Type-casting(类型转换)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Object.keys(me).forEach(key=&gt;&#123;</span><br><span class="line">    (me as any)[key]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样写法虽然可以，但是不推荐</p>
<p>第二种可以把loop里面的key的类型设置为Person的key，这样就能让ts理解我们在做什么</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Object.keys(me).forEach(key=&gt;&#123;</span><br><span class="line">    me[key as keyof Person]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种比之前的要好点，还可以试试其他的，比如让ts自己能够完成这项工作</p>
<h3 id="Extending-Object-Constructor-继承接口ObjectConstructor"><a href="#Extending-Object-Constructor-继承接口ObjectConstructor" class="headerlink" title="Extending Object Constructor(继承接口ObjectConstructor)"></a>Extending Object Constructor(继承接口ObjectConstructor)</h3><p>在ts里面有一个声明合并的特性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">  height: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的code对Person接口进行了三次的声明，等同于下面这个code</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    height: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以同理我们可以写ObjectConstructor的接口，写key方法的重载，这次我们需要对object的value值进行细分，并且决定应该返回什么类型</p>
<p>三种行为</p>
<ol>
<li>如果我们传递进来一个number类型，那么应该返回空数组</li>
<li>如果我们传递进来一个字符串或者一个数组，那么应该返回string[]，也就是字符串数组</li>
<li>如果我们传递进来一个any类型，那么直接返回它的key</li>
</ol>
<p>看一下怎么构造这个类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> ObjectKeys&lt;T&gt; = T extends object?(keyof T)[]:</span><br><span class="line">T extends number?[]:</span><br><span class="line">T extends string|Array&lt;any&gt; ?string[]:</span><br><span class="line">never</span><br></pre></td></tr></table></figure>

<p>以never结尾来捕捉异常错误</p>
<p>然后写ObjectConstructor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface ObjectConstructor&#123;</span><br><span class="line">    keys(o:T):ObjectKeys&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这两段代码放在声明文件中，比如lib.d.ts</p>
<p>然后这个时候执行文章开头的那个loop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Object.keys(me).forEach((key) =&gt; &#123;</span><br><span class="line">  //这个时候就可以正常输出了</span><br><span class="line">  console.log(me[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>
<div style="overflow:hidden">
    <img src="/images/ObjectKeys/code.png" style="float:left;" title="Codes" alt="picture">
</div>





]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Traversing</title>
    <url>/2019/09/06/Traversing/</url>
    <content><![CDATA[<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="built_in">let</span> deepTraversal1 = (node, nodeList = []) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (node !== null) &#123;</span><br><span class="line">    nodeList.push(node)</span><br><span class="line">    <span class="built_in">let</span> children = node.children</span><br><span class="line">    <span class="keyword">if</span>(children!==null||children.length!==0)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">        deepTraversal1(children[i], nodeList)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> nodeList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="built_in">let</span> deepTraversal2= (node)=&gt;&#123;</span><br><span class="line">  <span class="built_in">let</span> nodes=[];</span><br><span class="line">  <span class="keyword">if</span>(node!== null)&#123;</span><br><span class="line">    nodes.push(node);</span><br><span class="line">    <span class="built_in">let</span> children = node.children;</span><br><span class="line">    <span class="keyword">if</span>(children!==null||children.length!==0)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="built_in">let</span> i=0;i&lt;children.length;i++)&#123;</span><br><span class="line">        nodes= nodes.concat(deepTraversal2(children[i]));</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="built_in">let</span> deepTraversal2=(node)=&gt;&#123;</span><br><span class="line">  <span class="built_in">let</span> stack =[];</span><br><span class="line">  <span class="built_in">let</span> nodes=[];</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    /*如果node节点存在*/</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">      <span class="built_in">let</span> item= stack.pop();//取出队尾元素</span><br><span class="line">      <span class="built_in">let</span> children = item.children;//获取元素子节点</span><br><span class="line">      nodes.push(children);//推进子节点，结构与父节点一样</span><br><span class="line">      <span class="keyword">if</span>(children!==null||children.length!==0)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> i =0;i&lt;children.length;i++)&#123;</span><br><span class="line">          stack.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>从某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> widthTraversal2=(node)=&gt;&#123;</span><br><span class="line">  <span class="built_in">let</span> nodes=[];</span><br><span class="line">  <span class="built_in">let</span> stack=[];</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">      <span class="built_in">let</span> item = stack.shift();</span><br><span class="line">      <span class="built_in">let</span> children = item.children;</span><br><span class="line">      nodes.push(node);</span><br><span class="line">      <span class="keyword">if</span>(children!==null||children.length!==0)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> i =0;i&lt;children.length;i++)&#123;</span><br><span class="line">          stack.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2020/09/25/axios/</url>
    <content><![CDATA[<h3 id="为什么-axios-既可以用-axios-这样请求-，也可以-axios-get-这样请求？"><a href="#为什么-axios-既可以用-axios-这样请求-，也可以-axios-get-这样请求？" class="headerlink" title="为什么 axios 既可以用 axios({})这样请求 ，也可以 axios.get()这样请求？"></a>为什么 axios 既可以用 axios({})这样请求 ，也可以 axios.get()这样请求？</h3><p>在使<code>axios.create</code>的时候,调用了这个方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create an instance of Axios</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Object&#125; defaultConfig The default config <span class="keyword">for</span> the instance</span><br><span class="line"> * @<span class="built_in">return</span> &#123;Axios&#125; A new instance of Axios</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> createInstance(defaultConfig) &#123;</span><br><span class="line">  var context = new Axios(defaultConfig);//生成配置 和拦截器</span><br><span class="line">  <span class="comment"># 在这里，instance 是一个 wrapped 函数，将context作为参数传递给request，所以调用axios(&#123;&#125;)就是在调用request(&#123;&#125;)</span></span><br><span class="line">  var instance = <span class="built_in">bind</span>(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">#Copy axios.prototype to instance</span></span><br><span class="line">  <span class="comment"># 这个是把Axios原型链的东西挂载到instance上去</span></span><br><span class="line">  <span class="comment"># 因为instance 是个一个functoin，所以在直接赋值的时候不能直接看到</span></span><br><span class="line">  <span class="comment"># 能在instance 的prototype上可以看到</span></span><br><span class="line">  <span class="comment"># 所以在调用类似axios.get(）这类的方法是能正常运行</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Copy context to instance</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line">  <span class="comment"># console.log(instance)</span></span><br><span class="line">  <span class="built_in">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从图中可以看到,方法之类的确实挂载到了原型链上<br><img src="/images/axios/prototype.png" alt="prototype"></p>
<h3 id="cancalToken-怎么取消请求的"><a href="#cancalToken-怎么取消请求的" class="headerlink" title="cancalToken 怎么取消请求的"></a>cancalToken 怎么取消请求的</h3><p>那么其实什么时候需要取消请求，举一个很常见的例子，取消重复请求，就是当前已经发出请求的情况下，后续同样的请求如果发送就会被取消（如果是表单的提交也可以使用 dom 的 disabld 禁止点击 2333）<br>举个栗子：<br>在 axios 上是挂载了 Cancel 相应的东西</p>
<ul>
<li>axios.Cancel = require(‘./cancel/Cancel’);</li>
<li>axios.CancelToken = require(‘./cancel/CancelToken’);</li>
<li>axios.isCancel = require(‘./cancel/isCancel’);</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var data = document.getElementById(<span class="string">"data"</span>).value;</span><br><span class="line">         const CancelToken = axios.CancelToken;</span><br><span class="line">         axios</span><br><span class="line">           .post(</span><br><span class="line">             <span class="string">"/post/server"</span>,</span><br><span class="line">             &#123;</span><br><span class="line">               data,</span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">               cancelToken: new CancelToken((c) =&gt; &#123;</span><br><span class="line">                 cancel = c;</span><br><span class="line">                 console.log(c)</span><br><span class="line">               &#125;),</span><br><span class="line">             &#125;</span><br><span class="line">           )</span><br><span class="line">           .<span class="keyword">then</span>(<span class="keyword">function</span> (res) &#123;</span><br><span class="line">             output.className = <span class="string">"container"</span>;</span><br><span class="line">             output.innerHTML = res.data;</span><br><span class="line">           &#125;)</span><br><span class="line">           .catch(<span class="keyword">function</span> (err) &#123;</span><br><span class="line">             output.className = <span class="string">"container text-danger"</span>;</span><br><span class="line">             output.innerHTML = err.message;</span><br><span class="line">           &#125;);</span><br><span class="line">         cancel(<span class="string">'sdfsd'</span>);</span><br></pre></td></tr></table></figure>

<p>然后这里 axios.post 实际上就是调用了<code>request</code>方法，方法的返回值是一个 promise，最后一个执行的 promise 是一个叫<code>dispatchRequest</code>的函数，函数位置在 core/dispatchRequest.js 文件下，因为返回的是一个 promise ，状态是 pendding，加入到微任务队列，然后执行主线程的<code>cancel</code>方法。cancel 方法是在初始化 cancelToken 的时候给 cancel 赋值了。</p>
<p><code>cancelToken：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> CancelToken(executor) &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof executor !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    throw new TypeError(<span class="string">'executor must be a function.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var resolvePromise;</span><br><span class="line">  <span class="comment"># 这里把resolve钩子赋值给resolvePromise 为了让cancel函数能够改变promise的状态</span></span><br><span class="line">  this.promise = new Promise(<span class="keyword">function</span> promiseExecutor(resolve) &#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  var token = this;</span><br><span class="line">  executor(<span class="keyword">function</span> cancel(message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (token.reason) &#123;</span><br><span class="line">      <span class="comment"># Cancellation has already been requested</span></span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token.reason = new Cancel(message);</span><br><span class="line">    <span class="comment"># 这里改变promise状态位fulfilled</span></span><br><span class="line">    resolvePromise(token.reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程任务执行完成的时候开始进入下一轮任务执行，没有宏任务需要执行，直接执行微任务，先执行刚刚 request 返回的 promise，其实是开始执行了<code>dispatchRequest</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = <span class="keyword">function</span> dispatchRequest(config) &#123;</span><br><span class="line">  throwIfCancellationRequested(config);</span><br><span class="line">  <span class="comment"># 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Throws a `Cancel` <span class="keyword">if</span> cancellation has been requested.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> throwIfCancellationRequested(config) &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">      <span class="comment"># 这个方法挂载在canceltoken原型链傻姑娘</span></span><br><span class="line">    config.cancelToken.throwIfRequested();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">CancelToken.prototype.throwIfRequested = <span class="keyword">function</span> <span class="function"><span class="title">throwIfRequested</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (this.reason) &#123;</span><br><span class="line">      <span class="comment"># 这里抛出错误，然后在主程序代码中的catch捕获，然后程序返回，不进行后续创建xhr对象的过程</span></span><br><span class="line">    throw this.reason;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在xhr文件中看到有一段代码，长这样:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">      // Handle cancellation</span><br><span class="line">      config.cancelToken.promise.then(<span class="keyword">function</span> onCanceled(cancel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">          <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.abort();</span><br><span class="line">        reject(cancel);</span><br><span class="line">        // Clean up request</span><br><span class="line">        request = null;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么上文中的resolvePromise改变后的promise就是在这里调用，那什么情况会到这里来执行请求，假如有A，B两个请求，A请求响应时间过长，然后等到B执行回调都回来的时候，直接把A请求给取（gan）消(diao)了</p>
]]></content>
  </entry>
  <entry>
    <title>部署hexo踩坑记录</title>
    <url>/2020/11/14/bugsForNode/</url>
    <content><![CDATA[<p>在执行下面这句代码的时候</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>

<p>报错信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Something<span class="string">'s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">TypeError [ERR_INVALID_ARG_TYPE]: The "mode" argument must be integer. Received an instance of Object</span></span><br><span class="line"><span class="string">    at copyFile (fs.js:1924:10)</span></span><br><span class="line"><span class="string">    at tryCatcher (/Users/zjs/Desktop/blog/node_modules/bluebird/js/release/util.js:16:23)</span></span><br><span class="line"><span class="string">    at ret (eval at makeNodePromisifiedEval (/Users/zjs/.nvm/versions/node/v14.10.0/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promisify.js:184:12), &lt;anonymous&gt;:13:39)</span></span><br></pre></td></tr></table></figure>

<p>解决方案<br> NodeJs 版本从 14 回到 12 就🉑️！</p>
]]></content>
  </entry>
  <entry>
    <title>Chrome调试工具的那点事</title>
    <url>/2019/09/27/chorme-panel/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title="$_"></a>$_</h3><p>调试的过程中，你经常会通过打印查看一些变量的值，但如果你想看一下上次执行的结果呢？再输一遍表达式吗</p>
<a id="more"></a>
<p>这时候 $_ 就派上了用场，$_ 是对上次执行的结果的 引用 ：<br><img src="/images/chrome_panel/demo1.png" alt="demo"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title="$$"></a>$$</h3><p>用Jquery库的同学都知道$是Jquery的缩写，在Chrome的调试面板中，如果你没有定义$这个变量，它在 console 中就是对这一大串函数 document.querySelector 的别名。$$则是==Array.from(document.querySelector),返回的是一个数组，而不是一个nodeList，可以帮我们省却很多时间</p>
<h3 id="0"><a href="#0" class="headerlink" title="$0"></a>$0</h3><p>$0保存的是当前选中节点的引用,$1是上个节点，$2是上上个,到4截止。</p>
<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>截屏的时候你们肯定用的是qq或者tim的ctrl+alt+a或者微信的alt+a，其实浏览器本身也支持截屏<br><img src="/images/chrome_panel/demo2.gif" alt="图片"></p>
<h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p><img src="/images/chrome_panel/demo3.gif" alt="图片"></p>
<p>PS:Ummm,还有其他命令我就不玩啦。忘了说，ctrl+shift+p打开那个command面板</p>
<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p>大部分人打断点都是这样打滴<br><img src="/images/chrome_panel/demo4.png" alt="图片"><br>然鹅如果你只想看第50次循环中的数据是什么样的，难道需要前面的49次都断电吗？烦不烦？所以你可以酱紫：<br><img src="/images/chrome_panel/demo5.gif" alt="图片"></p>
<p>设置条件断点后，可以指定在某个条件的时候断点，并且在右侧可以移除所有断点而不用手动一个个点取消。</p>
]]></content>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>思考如何使a==1&amp;&amp;a==2&amp;&amp;a==3为true</title>
    <url>/2019/11/01/closure/</url>
    <content><![CDATA[<p>涉及运算符比较过程，运算符在比较两个值是否相等的时候做了什么,第二个涉及闭包JS比较两个数值是否相等可以用== 和=== ，<a id="more"></a>其中 == 会有隐式类型转换的操作，===则不会,在两个数比较时，先调用valueOf,如果返回的不是原始类型，继续调用toString,如果不是原始类型，抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const b = &#123;</span><br><span class="line">  value :1,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(`toString : $&#123;b==3&#125;`)</span><br><span class="line">console.log(`valueOf : $&#123;b==4&#125;`)</span><br><span class="line">//抛出异常TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const b = &#123;</span><br><span class="line">  value :1,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    return 3</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(`toString : $&#123;b==3&#125;`)</span><br><span class="line">console.log(`valueOf : $&#123;b==4&#125;`)</span><br><span class="line">//toString:true,valueOf:false</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const b = &#123;</span><br><span class="line">  value :1,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    return 3</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf()&#123;</span><br><span class="line">    return 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(`toString : $&#123;b==3&#125;`)//false</span><br><span class="line">console.log(`valueOf : $&#123;b==4&#125;`)//true</span><br></pre></td></tr></table></figure>

<p>OK,接下来说正题， a==1的时候先调用了a.valueOf(),然后根据valueOf的返回值与1进行比较,但是在a==1为真的情况下如何确保a==2以及a==3也同时成立呢？还记得里两个数比较时做的操作吗？先调用valueOf,然后是toString,所以只要覆写其中一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a =&#123;</span><br><span class="line">  value:1,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    return this.value++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//由于这时的a是一个Object,所以调用valueOf的时候返回的并不是原始类型，因此我们覆写toString方法即可</span><br><span class="line">console.log(a==1&amp;&amp;a==2&amp;&amp;a==3)//true</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2020/10/21/conclusion/</url>
    <content><![CDATA[<h3 id="笔记一"><a href="#笔记一" class="headerlink" title="笔记一"></a>笔记一</h3><p>在vue项目中使用ts-class的形式来编写组件的时候，要记得在export上面➕<code>@Component</code>装饰器，不然组件不能正常注册</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Component,</span><br><span class="line">    Vue,</span><br><span class="line">    InjectReactive</span><br><span class="line">&#125; from <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">class Child extends Vue &#123;</span><br><span class="line">    @InjectReactive() node: number;</span><br><span class="line">    <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">        console.log(this.node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在页面中需要用到子组件的情况，需要像这样注册,并且<code>@Component</code>装饰器只需要写一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Vue,</span><br><span class="line">    Component,</span><br><span class="line">    ProvideReactive</span><br><span class="line">&#125; from <span class="string">'vue-property-decorator'</span>;</span><br><span class="line">import Child from <span class="string">'./child.vue'</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">class Parent extends Vue &#123;</span><br><span class="line">    @ProvideReactive() node = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">        this.node = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="笔记二-—-ProvideReactive来做数据透传的注意点"><a href="#笔记二-—-ProvideReactive来做数据透传的注意点" class="headerlink" title="笔记二 — ProvideReactive来做数据透传的注意点"></a>笔记二 — ProvideReactive来做数据透传的注意点</h3><p>如果在组件中使用Provide来进行数据透传的话，数据是不带响应式的。如果需要数据具有响应式，那么需要用ProvideReactive来做属性的透传，代码例子可以看上一个代码，另外由于在路由跳转的时候，有时候会有Provide的值重新定义的问题，这时候控制台会抛出异常，具体可以看这个<br><a href="https://github.com/kaorun343/vue-property-decorator/issues/277">issue</a>,有临时的解决方案</p>
<h3 id="笔记三-—-在弹窗中保证数据的实时性"><a href="#笔记三-—-在弹窗中保证数据的实时性" class="headerlink" title="笔记三 — 在弹窗中保证数据的实时性"></a>笔记三 — 在弹窗中保证数据的实时性</h3><p>需要把数据以Provide的形式传递给弹窗，但是数据仅仅只在第一次显示的时候是正常的数据，在关闭弹窗后再一次开启弹窗，显示的数据是上一次的数据。原因暂时不知道。所以我在关闭弹窗的时候同时用v-if来销毁元素，这样每次打开的元素都是一个最新的元素，同时这个时候获取到的数据也是最新的数据。</p>
<h3 id="笔记四-—-数据获取完后保证子组件获取最新的数据"><a href="#笔记四-—-数据获取完后保证子组件获取最新的数据" class="headerlink" title="笔记四 — 数据获取完后保证子组件获取最新的数据"></a>笔记四 — 数据获取完后保证子组件获取最新的数据</h3><p>在父组件用axios获取数据的时候，然后传递给子组件，但是子组件渲染的时候是定义时就给的默认值。<br>原因：父组件在请求数据的时候，子组件的生命周期已经走完并且已经渲染完成，所以这时候是拿不到请求后返回的真实数据<br>方案：我这里用v-if来判断获取的数据的长度是否为空来判断是否要渲染子组件，缺点：数据量很大的时候会有很长时间的空白。</p>
<h3 id="笔记五-—-自定义组件绑定v-models"><a href="#笔记五-—-自定义组件绑定v-models" class="headerlink" title="笔记五 — 自定义组件绑定v-models"></a>笔记五 — 自定义组件绑定v-models</h3><p>想让自定义组件能够使用v-model语法糖，这样子组件的数据就可以实时的反馈到父组件中去</p>
<p>在vue中，对input来说，v-model是value和input事件的语法糖，对于checkbox来说，监听的事件是change，给对应的元素添加对应的事件，然后在自组件emit出去，把相应的value值绑定到对应的dom元素中去。</p>
]]></content>
  </entry>
  <entry>
    <title>GET 和 POST 的区别</title>
    <url>/2020/09/12/diff-between-get-post/</url>
    <content><![CDATA[<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><ol>
<li>GET请求返回的资源会被浏览器缓存</li>
<li>GET请求会保存在浏览器的历史记录中</li>
<li>GET请求能当书签</li>
<li>GET不能用来处理敏感数据</li>
<li>有长度限制（具体长度参见各个浏览器规范）</li>
<li>仅仅用来获取数据，不能修改</li>
<li>参数的数据类型，只接收ascll编码</li>
<li>仅支持url编码</li>
<li>产生一个数据包</li>
<li>页面重载或者回退没有影响</li>
</ol>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><ol>
<li>请求不会被缓存</li>
<li>不会保存在历史记录中</li>
<li>不能作为书签</li>
<li>数据长度没有限制</li>
<li>参数的数据类型没有限制</li>
<li>支持多种编码</li>
<li>两个数据包，需要服务器响应100后继续发出请求之后服务器（可能）响应200</li>
<li>刷新或者回退 数据会重新提交</li>
</ol>
<h2 id="其他http方法"><a href="#其他http方法" class="headerlink" title="其他http方法"></a>其他http方法</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put方法跟post一样，也是用来创建或者更新资源的，但是跟post不一样的地方在于put请求是幂等的，也就是说put请求发起多次所产生的结果是跟第一个一样的；那么对于post请求，重复请求就会产生多次创建相同资源的副作用</p>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>head请求跟get请求是差不多相同的，不同的地方在于head请求没有返回体<br>那么head 请求通常是在发起get请求之前检查get请求返回的是什么，比如在下载文件的时候或者下载请求体的时候</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除方法用来删除资源</p>
<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>是复杂请求的预检请求</p>
]]></content>
  </entry>
  <entry>
    <title>今日随笔(7-29)</title>
    <url>/2020/07/29/essay-1/</url>
    <content><![CDATA[<h2 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h2><p>使用 web worker 在一个单独的线程中执行函数，能够允许执行不阻塞 UI 渲染的耗时函数</p>
<ol>
<li><p>使用 blob 形式的 url 来创建<code>worker</code>,<code>worker</code>的内容应该是函数的系列化版本，然后立即返回函数的返回值</p>
</li>
<li><p>返回值是一个<code>promise</code>，它监听了<code>worker</code>的<code>onmessage</code> and <code>onerror</code>两个事件，返回从主线程发送过来的数据或者是抛出一个错误</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const runAsync = fn =&gt; &#123;</span><br><span class="line">  const worker = new Worker(</span><br><span class="line">    URL.createObjectURL(new Blob([`postMessage((<span class="variable">$&#123;fn&#125;</span>)());`]), &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">'application/javascript; charset=utf-8'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">return</span> new Promise((res, rej) =&gt; &#123;</span><br><span class="line">    worker.onmessage = (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">      res(data), worker.terminate();</span><br><span class="line">    &#125;;</span><br><span class="line">    worker.onerror = err =&gt; &#123;</span><br><span class="line">      rej(err), worker.terminate();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>example</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> const longRunningFunction = () =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> result = 0;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 1000; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> j = 0; j &lt; 700; j++)</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">let</span> k = 0; k &lt; 300; k++) result = result + i + j + k;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">runAsync(longRunningFunction).<span class="keyword">then</span>(console.log); // 209685000000</span><br></pre></td></tr></table></figure>

<p>然后由于代码是在不同的上下文执行的，因此所有的变量以及函数声明都要在内部定义,<br>比如下面这个是不行滴。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> outsideVariable = 50;</span><br><span class="line">runAsync(() =&gt; typeof outsideVariable).<span class="keyword">then</span>(console.log); // <span class="string">'undefined'</span></span><br></pre></td></tr></table></figure>

<h2 id="Copy-to-Clipboard"><a href="#Copy-to-Clipboard" class="headerlink" title="Copy to Clipboard"></a>Copy to Clipboard</h2><ol>
<li>创建一个<code>textarea</code>或者<code>input</code>元素添加到<code>document</code>中，让它的值等于要我们想要复制到粘贴板上的值</li>
<li>使用<code>HTMLInputElement.select()</code> 选择 刚刚创建的元素的内容</li>
<li>调用<code>Document.execCommand(&#39;copy&#39;)</code>复制刚刚选中的内容</li>
<li>将刚刚创建的元素移除</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const copy = val=&gt;&#123;</span><br><span class="line">    const el = document.createElement(<span class="string">'input'</span>)</span><br><span class="line">    input.value = val</span><br><span class="line">    document.body.appendChild(el)</span><br><span class="line">    el.select()</span><br><span class="line">    document.execCommand(<span class="string">'copy'</span>)</span><br><span class="line">    documnet.body.removeChild(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在执行这个方法的时候，在插入以及移除元素的时候可能会发生闪烁，一个常见的解决方案就是把创建的这个元素放置在不可见区域，看一下改造后的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const copyToClipboard = str =&gt; &#123;</span><br><span class="line">  const el = document.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">  el.value = str;</span><br><span class="line">  el.setAttribute(<span class="string">'readonly'</span>, <span class="string">''</span>);</span><br><span class="line">  el.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">  el.style.left = <span class="string">'-9999px'</span>;</span><br><span class="line">  document.body.appendChild(el);</span><br><span class="line">  el.select();</span><br><span class="line">  document.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">  document.body.removeChild(el);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="修改-url-来重载页面"><a href="#修改-url-来重载页面" class="headerlink" title="修改 url 来重载页面"></a>修改 url 来重载页面</h2><br>

<p><strong>使用 h5 的 history</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const nextURL = <span class="string">'https://my-website.com/page_b'</span>;</span><br><span class="line">const nextTitle = <span class="string">'My new page title'</span>;</span><br><span class="line">const nextState = &#123; additionalInformation: <span class="string">'Updated the URL with JS'</span> &#125;;</span><br><span class="line"><span class="comment"># 在浏览器历史新建一个入口并且无需重新加载</span></span><br><span class="line">window.history.pushState(nextState, nextTitle, nextURL);</span><br><span class="line"><span class="comment"># 取代当前入口</span></span><br><span class="line">window.history.replaceState(nextState, nextTitle, nextURL);</span><br></pre></td></tr></table></figure>

<p>history api 只允许访问同源网站，所以你不能导航到域名完全不一样的网站</p>
<p><strong>location</strong></p>
<p>location api 是比较旧的东西了，它需要重载页面才可以改变浏览器记录</p>
<h2 id="获取当前-url"><a href="#获取当前-url" class="headerlink" title="获取当前 url"></a>获取当前 url</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const getBaseUrl = url =&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> url.indexOf(<span class="string">'?'</span>) &gt;0 ?url.slice(0,url.indexOf(<span class="string">'?'</span>)):url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EXAMPLES</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getBaseURL(<span class="string">'http://url.com/page?name=Adam&amp;surname=Smith'</span>);</span><br><span class="line"><span class="comment"># 'http://url.com/page'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>今日随笔(7-30)</title>
    <url>/2020/07/30/essay-2/</url>
    <content><![CDATA[<h2 id="用-ts-开发-react-组件"><a href="#用-ts-开发-react-组件" class="headerlink" title="用 ts 开发 react 组件"></a>用 ts 开发 react 组件</h2><br>

<p><strong>基础函数式组件</strong></p>
<p>不用传递任何的 prop，直接返回一个 jsx 作为 react 组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Title</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;h1&gt;Welcome to this application&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p><strong>带有 prop 的函数式组件</strong></p>
<p>声明 props 类型并将 prop 传递给 jsx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> GreetingProps = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Greeting(props: GreetingProps) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;p&gt;Hi &#123;props.name&#125; 👋&lt;/p&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 prop 进行解构或许可读性更好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Greeting(&#123; name &#125;: GreetingProps) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;p&gt;Hi &#123;name&#125; 👋&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如 GreetingProps 中的 name 可选，那么就要给 name 一个默认值，以防 name 会变成 undefined</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> LoginMsgProps = &#123;</span><br><span class="line">  name?: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> LoginMsg(&#123; name = <span class="string">"Guest"</span> &#125;: LoginMsgProps) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;p&gt;Logged <span class="keyword">in</span> as &#123;name&#125;&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Children</strong></p>
<p>对于 children，更倾向于显示定义，而对于 ReactNode 类型来说，已经能够接受大多数的东西，比如 jsx，string 字符串等等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> CardProps = &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> Card(&#123; title, children &#125;: CardProps) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;section className=<span class="string">"cards"</span>&gt;</span><br><span class="line">      &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不需要 children 元素时，可以显示定义 children 的类型为 never</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> SaveButtonProps = &#123;</span><br><span class="line"></span><br><span class="line">  children: never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当传递了 children 时就会抛出错误</p>
<p><strong>对 html 元素使用拓展符</strong></p>
<p>拓展符对于 html 元素来说是个很好的特性，因为它能帮助你确保你把所有的 html 属性都给挪到你需要的元素上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> ButtonProps = JSX.IntrinsicElements[<span class="string">"button"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Button(&#123; ...allProps &#125;: ButtonProps) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;button &#123;...allProps&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>属性可以自定义设计</strong></p>
<p>当需要对 html 某些属性进行约束时，可以对它们进行自定义设定</p>
<p>如下这个例子，对 type 进行类型约束，这样仅能被赋予<code>&quot;primary&quot; | &quot;secondary&quot;</code>这两个值了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> StyledButton = Omit&lt;</span><br><span class="line">  JSX.IntrinsicElements[<span class="string">"button"</span>],</span><br><span class="line">  <span class="string">"type"</span> | <span class="string">"className"</span></span><br><span class="line">&gt; &amp; &#123;</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">"primary"</span> | <span class="string">"secondary"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> StyledButton(&#123; <span class="built_in">type</span>, ...allProps &#125;: StyledButton) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;Button className=&#123;`btn-<span class="variable">$&#123;type&#125;</span>`&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Required</strong></p>
<p>为了防止被 omit 出来的属性会忘记进行添加，封装一个 helper 来进行约束,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> MakeRequired&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp;</span><br><span class="line">  Required&lt;&#123; [P <span class="keyword">in</span> K]: T[P] &#125;&gt;;</span><br></pre></td></tr></table></figure>

<p>这样既可以将需要约束的属性omit出来，同时还能够防止忘记添加被omit出来的属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> ImgProps</span><br><span class="line">  = MakeRequired&lt;</span><br><span class="line">    JSX.IntrinsicElements[<span class="string">"img"</span>],</span><br><span class="line">    <span class="string">"alt"</span> | <span class="string">"src"</span></span><br><span class="line">  &gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> Img(&#123; alt, ...allProps &#125;: ImgProps) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;img alt=&#123;alt&#125; &#123;...allProps&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const zz = &lt;Img alt=<span class="string">"..."</span> src=<span class="string">"..."</span> /&gt;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2020/07/31/essay-3/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Docker 是由开发人员和系统管理员 构建 、运行和容器共享的应用程序的一个平台。使用容器部署应用程序称之为集装箱化。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>docker 为什么能够越来越受欢迎，那是因为:</p>
<ol>
<li><p>灵活性：即使再复杂的应用也能够被容器化。</p>
</li>
<li><p>轻量性：容器共享主机内核，并且在系统资源利用方面比虚拟机更加的高效</p>
</li>
<li><p>便携性：你可以在本地将应用打包成镜像，然后上传到云端，然后就可以在任何地方运行这个镜像</p>
</li>
<li><p>解耦：容器拥有高度自治权以及封闭性，你可以在不干扰其他应用程序的情况下对其中一个进行升级或者替换</p>
</li>
<li><p>拓展性：可以在数据中心自动分发容器副本</p>
</li>
<li><p>容器对应用隔离，对用户来说完全是黑盒，不用关心容器内发配置</p>
<a id="more"></a>
<h2 id="解决了哪些问题"><a href="#解决了哪些问题" class="headerlink" title="解决了哪些问题"></a>解决了哪些问题</h2></li>
<li><p>有时候在测试环境程序运行正常，但是在生产环境却出现了问题。<code>docker</code>的出现让测试环境和生产环境保持了一致性。</p>
</li>
<li><p>对于每个新用户来说，在执行程序之前必须在本机环境安装对应的环境。<code>docker</code>保证了一次配置，一键部署</p>
</li>
<li><p>由于版本问题导致程序不能正常启动.<code>docker</code>保证在部署的时候安装的版本跟开发时候的版本是完全一致的，重新定义了交付环境,比如对于<code>node-sass</code>的安装，不同版本的<code>node-sass</code>要对应不同版本的<code>node</code>，否则在安装的时候就会出现错误，需要重新 rebuild</p>
</li>
</ol>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>docker 常常与 微服务架构 一起使用<br>这是一个简单的单机架构，当需求简单时，可以采用单机架构进行开发<br><img src="/images/essay-3/esay.jpg" alt="简单需求"></p>
<p>但是当需求开始复杂时，如果还用单机架构进行开发</p>
<p><img src="/images/essay-3/complex.jpg" alt="复杂需求"></p>
<p>这样的设计是不太合理的</p>
<ol>
<li>对于网站和移动端来说，有很多相同逻辑的业务代码</li>
<li>数据有时候通过数据库共享，有时候通过调用接口传输。接口调用关系混乱。</li>
<li>单个应用为了给其他应用提供不同的结构，逐渐越改越大，越来越多的 ifelse，功能归属混乱</li>
<li>数据库为多个应用提供数据支持，难以重构和优化</li>
<li>所有应用都在同一个数据库进行操作，当数据量庞大时，容易出现性能瓶颈，需要分库分表</li>
<li>部署、维护、开发困难，即使只改动一个功能，也需要整体应用一起发布。如果不小心带上未经测试的代码，也有可能出现意料之外的错误</li>
</ol>
<p>将服务进行拆分，让每个容器能够各司其职，只负责一小部分模块，然后将各个服务进行拼接起来就组成一个完整的服务，并且在更新代码时也只需要更新其中一个容器而不用对整个应用进行更新<br><img src="/images/essay-3/micro_service.jpg" alt="micro_service"></p>
<h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h2><p>从根本上来说，容器只是一个正在运行的进程，应用了一些添加的封装特性以便它能和主机以及其他容器分离开。对于容器隔离最重要的概念之一就是每个容器和它自身的文件系统交互。文件系统是由<code>docker image</code>来提供的。一个<code>image</code>包含了一切运行所需的东西– 代码或者二进制，运行依赖以及其他任何文件系统对象。</p>
<h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p><code>docker</code>实例之间虽然都是互相隔离的，但是隔离的只是它们的环境，但是它们容器之前也需要互相联系，数据之间的传递，不然做拆分就没有任何的意义，用–link 来做容器之间的连接。同时在创建容器时需要设定好宿主机和容器之间的端口映射，这样可以通过访问宿主机的端口来访问容器的服务。<br>对于容器来说，如果把一些数据存放在容器中，那么当容器被删除时，那么存放在容器中的数据也会被删除，这是不合理的，所以数据应该放在宿主机中，然后映射进容器中，这样当容器被删除时，数据仍然存在于宿主机中</p>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>想要把应用编写成一个 docker 镜像，需要编写 DokcerFile 文件</p>
<p>这是一个 dockerFile 文件例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM php:7.4.8-fpm</span><br><span class="line">MAINTAINER liubucai</span><br><span class="line">ENV REDIS_VERSION=5.3.1</span><br><span class="line">ENV SWOOLE_VERSION=4.4.16</span><br><span class="line">ENV PROTOBUF_VERSION=0.12.3</span><br><span class="line">ENV PSR_VERSION=1.0.0</span><br><span class="line"></span><br><span class="line">RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie main non-free contri</span></span><br><span class="line"><span class="string">b"</span> &gt;&gt; /etc/apt/sources.list \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie main non-free co</span></span><br><span class="line"><span class="string">ntrib"</span> &gt;&gt;/etc/apt/sources.list \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; apt-get update &amp;&amp; apt-get upgrade \</span><br><span class="line">&amp;&amp; <span class="built_in">printf</span> <span class="string">"%s %s %s %s %s\n"</span> Yes, <span class="keyword">do</span> as I say! | apt-get install libtin</span><br><span class="line">fo5=5.9+20140913-1+deb8u3 \</span><br><span class="line">&amp;&amp; apt-get install -y libncurses5 procps \</span><br><span class="line">&amp;&amp; <span class="built_in">printf</span> <span class="string">"%s %s %s %s %s\n"</span> Yes, <span class="keyword">do</span> as I say! | apt-get install zlib1g</span><br><span class="line">=1:1.2.8.dfsg-2+b1 \</span><br><span class="line">&amp;&amp; apt-get install -y libssl-dev libzip-dev wget zip vim \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; docker-php-source extract \</span><br><span class="line">&amp;&amp; docker-php-ext-install bcmath sockets pdo_mysql pcntl opcache \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; wget https://github.com/allegro/php-protobuf/archive/master.zip \</span><br><span class="line">&amp;&amp; unzip master.zip &amp;&amp; rm -rf master.zip \</span><br><span class="line">&amp;&amp; mv php-protobuf-master /usr/src/php/ext/ \</span><br><span class="line">&amp;&amp; docker-php-ext-install php-protobuf-master \</span><br><span class="line">&amp;&amp; curl -sS https://getcomposer.org/installer | php \</span><br><span class="line">&amp;&amp; mv composer.phar /usr/<span class="built_in">local</span>/bin/composer \</span><br><span class="line">&amp;&amp; <span class="built_in">cd</span> /usr/src/php/ext/php-protobuf-master/ &amp;&amp; composer install \</span><br><span class="line">&amp;&amp; wget https://github.com/protocolbuffers/protobuf/releases/download/v</span><br><span class="line">3.12.3/protobuf-php-3.12.3.zip \</span><br><span class="line">&amp;&amp; unzip protobuf-php-3.12.3.zip \</span><br><span class="line">&amp;&amp; <span class="built_in">cd</span> protobuf-3.12.3/ \</span><br><span class="line">&amp;&amp; ./configure --prefix=/usr/<span class="built_in">local</span>/protobuf \</span><br><span class="line">&amp;&amp; make &amp;&amp; make install \</span><br><span class="line">&amp;&amp; <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/protobuf/bin:<span class="variable">$PATH</span> \</span><br><span class="line">&amp;&amp; apt-get -y install npm \</span><br><span class="line">&amp;&amp; npm install -g require &amp;&amp; npm install -g browserify &amp;&amp; npm install g</span><br><span class="line">oogle-protobuf \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; pecl install redis-<span class="variable">$&#123;REDIS_VERSION&#125;</span> &amp;&amp; docker-php-ext-enable redis \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">"install redis ok !"</span> \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; <span class="built_in">printf</span> <span class="string">"yes\n yes\n yes\n yes\n"</span> | pecl install swoole-$&#123;SWOOLE_VE</span><br><span class="line">RSION&#125; \</span><br><span class="line">&amp;&amp; docker-php-ext-enable swoole \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">"install swoole ok !"</span> \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; pecl install psr-<span class="variable">$&#123;PSR_VERSION&#125;</span> &amp;&amp; docker-php-ext-enable psr \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">"install psr ok !"</span> \</span><br><span class="line"><span class="comment"># \</span></span><br><span class="line">&amp;&amp; pecl install zip &amp;&amp; docker-php-ext-enable zip</span><br><span class="line"><span class="comment">#VOLUME ["/var/log","/usr/local/etc/","/var/run","/var/www/html"]</span></span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line">EXPOSE 9000</span><br><span class="line"><span class="comment">#CMD php-fpm -R -D &amp;&amp; tail -f /dev/null</span></span><br></pre></td></tr></table></figure>

<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>当宿主机中拥有几十个 docker 服务时，如果一个一个的执行<code>docker run</code> 无疑是很让人崩溃的以及怀疑世界 ing，因此可以采用 docker compose 才对 docker 实例进行管理，只要写好 docker compose 的配置文件, 然后执行 <code>docker compose start</code> 那么就会执行配置文件中的 docker 实例（假设宿主机中已经启动对应的容器）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">networks:</span><br><span class="line">    xxx-game-net:</span><br><span class="line">        driver: bridge <span class="comment"># 以网桥的形式连接docker</span></span><br><span class="line">services:</span><br><span class="line">    nginx:</span><br><span class="line">        image: nginx:latest <span class="comment"># 安装的版本</span></span><br><span class="line">        container_name: nginx-xxx</span><br><span class="line">        restart: always</span><br><span class="line">        ports:</span><br><span class="line">            - 6688:80</span><br><span class="line">        volumes: <span class="comment"># 映射配置文件到容器中</span></span><br><span class="line">            - ./conf/nginx/conf.d/:/etc/nginx/conf.d</span><br><span class="line">            - ../html:/usr/share/nginx/html</span><br><span class="line">            - ./<span class="built_in">log</span>/nginx:/var/<span class="built_in">log</span>/nginx</span><br><span class="line">        depends_on: <span class="comment"># 启动的依赖</span></span><br><span class="line">            - mysql</span><br><span class="line">            - redis</span><br><span class="line">            - php-fpm</span><br><span class="line">        networks:</span><br><span class="line">            - xxx-game-net</span><br><span class="line"> mysql:</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    container_name: mysql-xxx</span><br><span class="line">    <span class="built_in">command</span>: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">        - 6666:3306</span><br><span class="line">    volumes:</span><br><span class="line">        - ./conf/mysql/conf.d/:/etc/mysql/conf.d</span><br><span class="line">        - ./data/mysql:/var/lib/mysql</span><br><span class="line">    environment:</span><br><span class="line">        MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    networks:</span><br><span class="line">        - xxx-game-net</span><br><span class="line">php-fpm:</span><br><span class="line">    build: .</span><br><span class="line">    container_name: php-fpm-xxx</span><br><span class="line">    volumes:</span><br><span class="line">        - ../:/data/www</span><br><span class="line">    networks:</span><br><span class="line">        - xxx-game-net</span><br><span class="line">redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    container_name: redis-xxx</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">        - 6668:6379</span><br><span class="line">    volumes:</span><br><span class="line">        - ./data/redis:/data</span><br><span class="line">    networks:</span><br><span class="line">        - xxx-game-net</span><br></pre></td></tr></table></figure>

<p>—–OVER</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>今日随笔(8-6)</title>
    <url>/2020/08/06/essay-4/</url>
    <content><![CDATA[<p>先看代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">[...[1,2,3]].forEach(item=&gt;console.log(item))</span><br></pre></td></tr></table></figure>

<p>乍一看，是不是感觉挺正常的，在浏览器的log窗口应该能输出1，2，3，才对<br>然后在浏览器跑一下，发现</p>
<p><img src="/images/essay-4/unexpected_error.png.png" alt="error"></p>
<p>然后emm排查了一下，语法是没问题的，浏览器版本是最新的开发版本，es6的语法肯定是支持的，那问题其实就是a=1 后面漏了分号，所以代码就成了这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const a = 1[...[1,2,3]].forEach(item=&gt;console.log(item))</span><br></pre></td></tr></table></figure>

<p>那代码成了这样那肯定不能正确解析了～</p>
<p>果然，漏写分号不是好习惯～</p>
]]></content>
  </entry>
  <entry>
    <title>今日随笔(2020-10-11)</title>
    <url>/2020/10/11/essay-5/</url>
    <content><![CDATA[<h3 id="命令行文件的上传与下载"><a href="#命令行文件的上传与下载" class="headerlink" title="命令行文件的上传与下载"></a>命令行文件的上传与下载</h3><p>文件的上传和下载命令都是scp</p>
<p><strong>上传</strong><br>从服务器上下载文件 scp username@servername:/path/filename /Users/mac/Desktop（本地目录，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp root@47.98.37.170:/root/test.txt /Users/mac/Desktop就是将服务器上的/root/test.txt下载到本地的/Users/mac/Desktop目录下。注意两个地址之间有空格！</span><br></pre></td></tr></table></figure>

<p><strong>下载</strong><br>上传本地文件到服务器 scp /path/filename username@servername:/path ;</p>
<p>note： 下载命令就是将两个路径换一个位置就行了。</p>
<h3 id="TS-4-0的一些更新"><a href="#TS-4-0的一些更新" class="headerlink" title="TS 4.0的一些更新"></a>TS 4.0的一些更新</h3><h4 id="类型解构"><a href="#类型解构" class="headerlink" title="类型解构"></a>类型解构</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Strings = [string, string];</span><br><span class="line"><span class="built_in">type</span> Numbers = number[]</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Unbounded = [...Strings, ...Numbers, boolean];</span><br><span class="line"><span class="comment"># // [string, string, ...Array&lt;number | boolean&gt;]</span></span><br><span class="line"><span class="comment"># 按照官方的解释就是解构一个已知长度的类型的时候，那么最后的结果类型也是没有任何限制的，在解构类型之后添加的类型声明都要添加到被解构类型的类型中去</span></span><br></pre></td></tr></table></figure>

<p>—待续哈，明天更新</p>
]]></content>
      <tags>
        <tag>TypeScript Upload</tag>
      </tags>
  </entry>
  <entry>
    <title>今日随笔(2020-12-27)</title>
    <url>/2020/12/27/essay-6/</url>
    <content><![CDATA[<ol>
<li>在vue ts class给数组添加值时报错<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> default class App&#123;</span><br><span class="line">    list =[]</span><br><span class="line">    <span class="function"><span class="title">_push</span></span>()&#123;</span><br><span class="line">        this.list.push(1)</span><br><span class="line">        <span class="comment"># error </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>由于定义的list是never类型的数组，所以不能够直接添加元素，所以在定义数组的时候需要显示定义类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list = [] as number[]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>line-height 属性同样会影响伪元素的高度</li>
<li>ts class 自定义vue双向绑定<br>v-model默认监听input事件，如果是checkbox或者radio<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Modle(<span class="string">'change'</span>) value:any</span><br><span class="line"><span class="comment"># 这样vue会监听change，$emit('change')改变外部绑定的值</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>今日随笔</title>
    <url>/2021/01/10/essay-7/</url>
    <content><![CDATA[<p><img src="/images/essay-7/essay.png" alt="essay"></p>
]]></content>
  </entry>
  <entry>
    <title>理解 flex-basis</title>
    <url>/2020/11/14/flex/</url>
    <content><![CDATA[<p>上个html代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"parent"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"child"</span>&gt;Child&lt;/div&gt;</span><br><span class="line">  &lt;div class=<span class="string">"child"</span>&gt;Child&lt;/div&gt;</span><br><span class="line">  &lt;div class=<span class="string">"child"</span>&gt;Child&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>css≠</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  flex: 0 1 auto; /* Default flex value */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<html>
<style>
body{
    body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
    Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}
}
.parent {
  display: flex;
}
.child {
  flex: 0 1 auto; /* Default flex value */
  /* 上面的代码相当于是
  *flex-grow:0; flex-shrink:1;flex-basis:auto;s
  *
  */
}
.child-grow{
    flex:1 0 auto;
}
.child-flex{
    flex:1 1 auto
}
</style>
<div class="parent">
  <div class="child">Child</div>
  <div class="child">Child</div>
  <div class="child">Child</div>
</div>
</html>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  flex: [flex-grow] [flex-shrink] [flex-basis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="showCssText"><span></span></span></p>
<p><button id="toggle">toggle</button></p>
<script>
const btn = document.getElementById("toggle");
btn.addEventListener('click',function(){
        const span = document.getElementById('showCssText');
        [...document.getElementsByClassName('child')].forEach(item=>{
            const classList = item.classList;
            // console.log(classList)
            if(classList.length === 1 ){
                classList.add('child-grow')
                span.innerText = 'flex:1 0 auto;'
            }else if(classList.length === 2){
                classList.add('child-flex')
                span.innerText = 'flex:1 1 auto'
            }else{
                classList.remove('child-flex')
                classList.remove('child-grow')
                span.innerText = 'flex: 0 1 auto; '
            }
        })
})
</script>


<p>flex-basic 默认是auto，告诉元素保持一个理想的尺寸；但是默认情况下的元素宽度是多少？auto告诉元素它的宽度由它的内容决定。为了让子元素占据父元素的所有空间，可以给子元素的宽度设置为<code>width:100%</code>,或者<code>flex-basis:100%</code>,或者<code>flex-grow:1</code>。</p>
<p>当给flex 的第三值 ，也就是 flex-basis 设置成1000px时，它会试着占据1000px的空间，如果不行，它会等比例占据其他元素的空间，但是其他元素内的文本长度同样会影响这个元素的位置分配；但是在更小的屏幕上可能会发现实际宽度并没有1000px，这是因为给了shrink，这个值告诉元素需要它等值缩小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.child-three &#123;</span><br><span class="line">  flex: 0 1 1000px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果grow 和 shrink都是0，那么元素不会等比例压缩，basis如果超出父元素宽度，那直接超出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.child-three &#123;</span><br><span class="line">  flex: 0 0 1000px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>git常用命令集合</title>
    <url>/2019/08/05/git-command/</url>
    <content><![CDATA[<h5 id="查看当前工作区状态"><a href="#查看当前工作区状态" class="headerlink" title="查看当前工作区状态"></a>查看当前工作区状态</h5><p><code>git status</code></p>
<h5 id="提交当前工作区文件到暂存区"><a href="#提交当前工作区文件到暂存区" class="headerlink" title="提交当前工作区文件到暂存区"></a>提交当前工作区文件到暂存区</h5><p><code>git add</code></p>
<h5 id="提交暂存区的修改到当前分支"><a href="#提交暂存区的修改到当前分支" class="headerlink" title="提交暂存区的修改到当前分支"></a>提交暂存区的修改到当前分支</h5><p><code>git commit</code></p>
<a id="more"></a>
<h5 id="把当前分支提交的修改推送到远程仓库去"><a href="#把当前分支提交的修改推送到远程仓库去" class="headerlink" title="把当前分支提交的修改推送到远程仓库去"></a>把当前分支提交的修改推送到远程仓库去</h5><p><code>git push origin master</code></p>
<h5 id="查看仓库提交记录"><a href="#查看仓库提交记录" class="headerlink" title="查看仓库提交记录"></a>查看仓库提交记录</h5><p><code>git log</code></p>
<h5 id="回退提交记录和工作区"><a href="#回退提交记录和工作区" class="headerlink" title="回退提交记录和工作区"></a>回退提交记录和工作区</h5><p><code>git reset --hard &lt;commitid&gt;</code></p>
<h5 id="回退提交记录"><a href="#回退提交记录" class="headerlink" title="回退提交记录"></a>回退提交记录</h5><p><code>git reset --soft &lt;commitid&gt;</code></p>
<h5 id="保存当前尚未添加到暂存区以及尚未提交到本地分支的代码-一般用于当修改文件的时候突然想要拉取远程仓库代码的尴尬情况-，stash是本地的，当push-pull的时候不会把statsh的代码传输到远程仓库去"><a href="#保存当前尚未添加到暂存区以及尚未提交到本地分支的代码-一般用于当修改文件的时候突然想要拉取远程仓库代码的尴尬情况-，stash是本地的，当push-pull的时候不会把statsh的代码传输到远程仓库去" class="headerlink" title="保存当前尚未添加到暂存区以及尚未提交到本地分支的代码(一般用于当修改文件的时候突然想要拉取远程仓库代码的尴尬情况)，stash是本地的，当push pull的时候不会把statsh的代码传输到远程仓库去"></a>保存当前尚未添加到暂存区以及尚未提交到本地分支的代码(一般用于当修改文件的时候突然想要拉取远程仓库代码的尴尬情况)，stash是本地的，当push pull的时候不会把statsh的代码传输到远程仓库去</h5><p><code>git stash</code></p>
<h5 id="在工作区显示刚刚在statsh保存的代码以及文件"><a href="#在工作区显示刚刚在statsh保存的代码以及文件" class="headerlink" title="在工作区显示刚刚在statsh保存的代码以及文件"></a>在工作区显示刚刚在statsh保存的代码以及文件</h5><p><code>git stash apply</code></p>
<h5 id="查看保存在stash的记录"><a href="#查看保存在stash的记录" class="headerlink" title="查看保存在stash的记录"></a>查看保存在stash的记录</h5><p><code>git stash list</code></p>
<h5 id="撤销某一个操作，并且把当前撤销操作当成一次新的commit提交"><a href="#撤销某一个操作，并且把当前撤销操作当成一次新的commit提交" class="headerlink" title="撤销某一个操作，并且把当前撤销操作当成一次新的commit提交"></a>撤销某一个操作，并且把当前撤销操作当成一次新的commit提交</h5><p><code>git revert HEAD|&lt;commitid&gt;</code></p>
<h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p><code>git push origin --delete &lt;branchName&gt;</code></p>
<h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><p><code>git branch -d|-D &lt;branchName&gt;</code></p>
<h5 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h5><p><code>git branch</code></p>
<h5 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h5><p><code>git branch -a</code></p>
<h5 id="切换分支（如果本地要新建并且切换一个新的分支，要新加上-b参数，查看分支不需要加-b参数）"><a href="#切换分支（如果本地要新建并且切换一个新的分支，要新加上-b参数，查看分支不需要加-b参数）" class="headerlink" title="切换分支（如果本地要新建并且切换一个新的分支，要新加上-b参数，查看分支不需要加-b参数）"></a>切换分支（如果本地要新建并且切换一个新的分支，要新加上-b参数，查看分支不需要加-b参数）</h5><p><code>git checkout （-b） &lt;branchName&gt;</code></p>
<h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><p><code>git rm &lt;fileName&gt;</code></p>
<h5 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h5><p><code>git rm -r &lt;fileName&gt;</code></p>
<h5 id="下载指定仓库-这个就不用多说了"><a href="#下载指定仓库-这个就不用多说了" class="headerlink" title="下载指定仓库(这个就不用多说了)"></a>下载指定仓库(这个就不用多说了)</h5><p><code>git clone &lt;repoUrl&gt;</code></p>
<h5 id="添加子模块到当前仓库中"><a href="#添加子模块到当前仓库中" class="headerlink" title="添加子模块到当前仓库中"></a>添加子模块到当前仓库中</h5><p><code>git submodule add &lt;repo url&gt;</code></p>
<h5 id="clone带有子模块的仓库时需要更新子模块"><a href="#clone带有子模块的仓库时需要更新子模块" class="headerlink" title="clone带有子模块的仓库时需要更新子模块"></a>clone带有子模块的仓库时需要更新子模块</h5><p><code>git submodule update --init --recursive</code></p>
<h5 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h5><p><code>git init</code></p>
<h5 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h5><p><code>git remote add [option_name] [repo_url]</code></p>
<h5 id="从远程仓库拉取文件"><a href="#从远程仓库拉取文件" class="headerlink" title="从远程仓库拉取文件"></a>从远程仓库拉取文件</h5><p><code>git pull origin master</code><br><code>git pull origin master --allow-unrelated-histories</code></p>
<h5 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h5><p><code>git remote -v</code></p>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
    <style>
        .weather {
            width: 100%;
            height: 500px;
            /* background: #212125; */
            display: flex;
            justify-content: flex-start;
            align-content: center;
            color: #e6e8db;
        }
        .cloudy {
            position: relative;
            width: 300px;
            height: 300px;
            border-radius: 100%;
            background: linear-gradient(to top right, #1b9ce2 0, #e0e2e5 90%);
            box-shadow: 0 0 0 10px currentColor inset, 0 0 100px -10px;
        }
        .cloud {
            position: absolute;
            top: 25%;
            left: 40%;
            width: 100px;
            height: 30px;
            border-radius: 20px;
            background-color: #fff;
            box-shadow: 0 0 20px 10px currentColor inset, 0 0 100px -10px #c9e8de;
            animation: move 4000ms infinite ease-in-out;
        }
        .cloud::after {
            left: 45px;
            height: 35px;
            width: 35px;
        }
        .cloud::before {
            left: 15px;
            height: 50px;
            width: 50px;
        }
        .cloud::before,
        .cloud::after {
            content: '';
            position: inherit;
            border-radius: 100%;
            background-color: inherit;
            box-shadow: inherit;
            bottom: 40%;
        }
        @keyframes move {
            50% {
                transform: translateX(-10px);
            }
        }
    </style>
</head>

<body>
    <div class="weather">
        <div class="cloudy">
            <span class="cloud"></span>
        </div>
    </div>

</body>

</html>]]></content>
      <categories>
        <category>tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo搭建个人博客</title>
    <url>/2019/08/05/hexo-config/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装Node</li>
<li>安装hexo-cli</li>
<li>确保有github账号</li>
<li>安装git</li>
</ol>
<a id="more"></a>
<h2 id="构建hexo项目"><a href="#构建hexo项目" class="headerlink" title="构建hexo项目"></a>构建hexo项目</h2><h3 id="初始化hexo项目-项目名一定要用这个格式，xxx代表的是你的GitHub账号的名称"><a href="#初始化hexo项目-项目名一定要用这个格式，xxx代表的是你的GitHub账号的名称" class="headerlink" title="初始化hexo项目,项目名一定要用这个格式，xxx代表的是你的GitHub账号的名称"></a>初始化hexo项目,项目名一定要用这个格式，xxx代表的是你的GitHub账号的名称</h3><p><code>hexo init xxx.github.io</code></p>
<h3 id="进入文件夹"><a href="#进入文件夹" class="headerlink" title="进入文件夹"></a>进入文件夹</h3><p><code>cd xxx.github.io</code></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p><code>npm i</code></p>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p><code>hexo server</code></p>
<h3 id="搭建新的post-新搭建的post支持markdown语法，只要专注写文就OK"><a href="#搭建新的post-新搭建的post支持markdown语法，只要专注写文就OK" class="headerlink" title="搭建新的post,新搭建的post支持markdown语法，只要专注写文就OK"></a>搭建新的post,新搭建的post支持markdown语法，只要专注写文就OK</h3><p><code>hexo new post_name</code></p>
<h2 id="生成静态文件并部署"><a href="#生成静态文件并部署" class="headerlink" title="生成静态文件并部署"></a>生成静态文件并部署</h2><h3 id="配置根目录下的-config-yml文件"><a href="#配置根目录下的-config-yml文件" class="headerlink" title="配置根目录下的_config.yml文件"></a>配置根目录下的_config.yml文件</h3><p>  ①url是你要部署的地址(github地址或者自己的网站地址，如果不是部署在根目录下，url填写为具体部署的文件夹路径，root为/fileName/),fileName为具体的要部署的文件夹名称<br>  ②配置deploy参数，type为git，repo为仓库地址，ssh和https均可以，branch为要部署的分支</p>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p><code>npm install hexo-deployer-git --save</code></p>
<h3 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h3><p><code>hexo clean</code></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><p><code>hexo generate</code><br>可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h3 id="部署到服务器上"><a href="#部署到服务器上" class="headerlink" title="部署到服务器上"></a>部署到服务器上</h3><p><code>hexo deploy</code><br>可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>  我选择的是next，拥有丰富而简单的配置，结合第三方服务，打造属于您自己的博客,在hexo根目录运行以下命令，会在themes文件夹下生成一个next的子模块<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git submodule add https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>  在根目录下的_config.yml配置theme：next主题就可以生效了(关于更多submodule用法自行google)</p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p> 部署完成后就可以直接访问了，在浏览器输入栏中输入xxx.github.io即可（xxx为你的GitHub账号名称）</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>记得把你的代码push到你的remote repo上，不然只能在一台电脑做开发啦</li>
<li>另外，由于在当前仓库下有子模块存在，因此当你在另外一台电脑clone你的项目的时候，子模块是不会自动更新的,所以请运行以下命令来更新子模块，否则项目不完整<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2020/01/08/intranet-contacts/</url>
    <content><![CDATA[<p>内网穿透就是把本地服务映射到具有公网IP地址的服务器上，通过访问在公网上的机器，就可以访问到内网</p>
<a id="more"></a>
<p>工具挺多的，今天刚用的ngrok，感觉不太稳定，不过能凑活用吧，内网穿透这玩意儿对移动端开发来说挺方便的，把电脑上的本地服务映射到外网端口，然后这样手机也就可以访问在电脑上的服务了，也能热更</p>
<p>使用也挺方便的，google搜索ngrok，然后下载</p>
<p><img src="/images/intranet-contacts/demo1.png" alt="图片"></p>
<p>然后就是这样了</p>
<p><img src="/images/intranet-contacts/demo2.png" alt="图片"></p>
<p>然后你发现不管本地还是ngrok给你生成的地址，你都可以访问到本地开启的服务，但是每次开启的时候IP都不一样hhh</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>item</title>
    <url>/2020/10/07/item/</url>
    <content><![CDATA[<h3 id="Proposal-for-a-item-method-on-all-the-built-in-indexables"><a href="#Proposal-for-a-item-method-on-all-the-built-in-indexables" class="headerlink" title="Proposal for a .item() method on all the built-in indexables"></a>Proposal for a .item() method on all the built-in indexables</h3><p>这个方法是给有索引对象内置的一个方法，那么这个方法接收一个 number 类型的 index，对象能够根据 index 来确定值。那其实看到这会有个问题，具备索引的对象自己就能根据索引来确定值了，那么这个方法出现的意义是为什么？它其实是用负值的 index 来获取值，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const arr =[1,2,3]</span><br><span class="line">arr.item(-1) // 3</span><br></pre></td></tr></table></figure>

<p>是这样的用法。<br>那么这个方法是挂载在 String，Array，TypeArray 这三个数据结构的原型链上。<br>然后对于 dom 结构中类型 document.getElementById()这样的返回 NodeList 结构在经过 Array.from 转化之后同样会挂载 item 方法</p>
<p>但是这个方法目前还处于 stage3 阶段，因此是不能直接使用的 hhhh。但是官方给出了 polyfill</p>
<p>Like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> item(n) &#123;</span><br><span class="line">	<span class="comment"># ToInteger() abstract op</span></span><br><span class="line">	n = Math.trunc(n) || 0;</span><br><span class="line">	<span class="comment"># Allow negative indexing from the end</span></span><br><span class="line">	<span class="keyword">if</span>(n &lt; 0) n += this.length;</span><br><span class="line">	<span class="comment"># OOB access is guaranteed to return undefined</span></span><br><span class="line">	<span class="keyword">if</span>(n &lt; 0 || n &gt;= this.length) <span class="built_in">return</span> undefined;</span><br><span class="line">	<span class="comment"># Otherwise, this is just normal property access</span></span><br><span class="line">	<span class="built_in">return</span> this[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Other TypedArray constructors omitted for brevity.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> C of [Array, String, Uint8Array]) &#123;</span><br><span class="line">    Object.defineProperty(C.prototype, <span class="string">"item"</span>,</span><br><span class="line">                          &#123; value: item,</span><br><span class="line">                            writable: <span class="literal">true</span>,</span><br><span class="line">                            enumerable: <span class="literal">false</span>,</span><br><span class="line">                            configurable: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript浮点数精度问题</title>
    <url>/2019/10/10/javascript-float-num/</url>
    <content><![CDATA[<h3 id="浮点数陷阱"><a href="#浮点数陷阱" class="headerlink" title="浮点数陷阱"></a>浮点数陷阱</h3><p>原文：<a href="https://zhuanlan.zhihu.com/ne-fe" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/ne-fe</a></p>
<p>众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。</p>
<a id="more"></a>
<h3 id="浮点数的储存"><a href="#浮点数的储存" class="headerlink" title="浮点数的储存"></a>浮点数的储存</h3><p>首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。</p>
<p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p>
<p>64位比特又可分为三个部分：</p>
<ul>
<li>符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数</li>
<li>指数位E：中间的 11 位存储指数（exponent），用来表示次方数</li>
<li>尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li>
</ul>
<p><img src="/images/javascript_float_num/demo1.png" alt="图片"></p>
<p>实际数字就可以用以下公式来计算：<br><img src="/images/javascript_float_num/demo2.png" alt="图片"></p>
<p>公式推导过程见维基百科<a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noopener">wiki</a></p>
<h3 id="为什么0-1-0-2-0-30000000000000004"><a href="#为什么0-1-0-2-0-30000000000000004" class="headerlink" title="为什么0.1+0.2 =0.30000000000000004?"></a>为什么0.1+0.2 =0.30000000000000004?</h3><p>0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011…。<br>转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。<br>接着0.1+0.2计算步骤为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.00011001100110011001100110011001100110011001100110011010 +</span><br><span class="line">0.0011001100110011001100110011001100110011001100110011010 =</span><br><span class="line">0.0100110011001100110011001100110011001100110011001100111</span><br><span class="line">// 转成十进制正好是 0.30000000000000004</span><br></pre></td></tr></table></figure>

<p>因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度，如果整数大于 9007199254740992 会出现什么情况呢？<br>由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.pow(2, 1023)</span><br><span class="line">//8.98846567431158e+307</span><br><span class="line"></span><br><span class="line">//Math.pow(2, 1024)</span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure>

<p>那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？</p>
<ul>
<li>(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数</li>
<li>(2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数</li>
<li>… 依次跳过更多2的倍数<br>下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系<br><img src="/images/javascript_float_num/demo3.jfif" alt="real number"></li>
</ul>
<p>要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多</p>
<h3 id="toPrecision-vs-toFixed"><a href="#toPrecision-vs-toFixed" class="headerlink" title="toPrecision vs toFixed"></a>toPrecision vs toFixed</h3><p>数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。</p>
<p>不同点就需要注意一下</p>
<ul>
<li>toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。</li>
<li>toFixed 是小数点后指定位数取整，从小数点开始数起。</li>
</ul>
<p>两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。</p>
<p>如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。</p>
<p>原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！</p>
<p>解法：使用专业的四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100 还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><a href="https://github.com/dt-fe/number-precision">https://github.com/dt-fe/number-precision</a></li>
<li>BigInt</li>
<li>Number.EPSILON,表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。如果两个数的差值小于这个，就认为这两个数相等</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>jsonp实现</title>
    <url>/2019/11/28/jsonp/</url>
    <content><![CDATA[<p>由于浏览器的同源策略，所以当不同源发送请求时，会发生跨域，请求返回的结果被浏览器所拦截，其中一个解决办法就是用jsonp,jquery中的ajax中就支持了jsonp的数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line"> url: &apos;http://twitter.com/status/user_timeline/padraicb.json?count=10&apos;,</span><br><span class="line"> dataType: &apos;jsonp&apos;,</span><br><span class="line"> success: function onSuccess() &#123; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="什么是jsonp？"><a href="#什么是jsonp？" class="headerlink" title="什么是jsonp？"></a>什么是jsonp？</h3><p>jsonp就是我们开发人员利用了script标签的特性来绕过了浏览器的同源策略，因为script加载资源的时候不受浏览器同源策略的影响，但是这个策略（同源策略）不允许读取与当前网站不同源的回复，只允许发送请求，不允许读取请求</p>
<p>一个网站的origin由三分部分组成，首先就是URI的格式（http://）,接着是主机名（比如：baidu.com），最后是端口号（比如：443）。像 <a href="http://logrocket.com" target="_blank" rel="noopener">http://logrocket.com</a> 和 https:////logrocket.com 是两个不同的origin因为URI的格式不同。</p>
<h3 id="它怎么工作的？"><a href="#它怎么工作的？" class="headerlink" title="它怎么工作的？"></a>它怎么工作的？</h3><p>假如本地端口启动在localhost：8080，我们发送一个请求到提供json api的服务上去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.server.com/api/person/1</span><br></pre></td></tr></table></figure>

<p>然后响应的话可能长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;Maciej&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Cieslar&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是由于同源策略的限制，我们可以发送请求到服务端，但是服务端返回的请求被浏览器给拦截了，因为网站跟服务器不同源。</p>
<p>script元素可以代替我们自己发送请求，同源策略不限制它，它能够加载并且执行外链资源的js，这样的话比如在 <a href="https://logrocket.com的网站可以从不同来源的提供商加载google" target="_blank" rel="noopener">https://logrocket.com的网站可以从不同来源的提供商加载google</a> Map库，比如CDN</p>
<p>通过给script中的src赋值成想要访问的请求，script标签将会获取到响应，并且在浏览器中执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://www.server.com/api/person/1&quot; async=&quot;true&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但是问题在于，script会自动解析并且执行返回的js代码。在这种情况下，上面返回的代码会是JSON格式的。JSON会被解析成js代码，因此浏览器会抛出一个错误因为JSON不是有效的JS代码<br><img src="https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png?w=730&ssl=1" alt="图片"></p>
<p>因此我们必须返回一个正常运行的JS代码这样script解析并且运行的时候浏览器才不会抛出错误。我们只要把返回的JSON赋值给JS变量或者作为函数的参数就行，毕竟本质上来说，JSON也属于JS对象格式。</p>
<p>因此与其返回纯JSON格式，服务器倒不如返回JS代码。在返回的代码中，将JSON对象放在返回的函数中作为参数传递，函数的名字需要由客户端来传递，提供的函数名字在查询参数中叫做callback</p>
<p>在查询中提供回调函数的名字后，我们在全局上下文中创建了一个函数（function），这个函数在响应被解析并且执行的时候回调用一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.server.com/api/person/1?callback=callbackName</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">callbackName(&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;Maciej&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Cieslar&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为callbackName在接收到回调的时候callbackName挂载到window上，因此上面的代码其实就是相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.callbackName(&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;Maciej&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Cieslar&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这段代码会在window上下文执行，这个函数将由script下载的代码来执行</p>
<p>为了让jsonp能够正常工作，前后端都需要支持。当对于函数的命名没有标准的规范的时候，前端通常会给发送的函数命名为callback</p>
<h3 id="创建一个jsonp的实现"><a href="#创建一个jsonp的实现" class="headerlink" title="创建一个jsonp的实现"></a>创建一个jsonp的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let jsonpID = 0;</span><br><span class="line"></span><br><span class="line">function jsonp(url, timeout = 7500) &#123;</span><br><span class="line">  const head = document.querySelector(&apos;head&apos;);</span><br><span class="line">  jsonpID += 1;</span><br><span class="line"></span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;);</span><br><span class="line">    const callbackName = `jsonpCallback$&#123;jsonpID&#125;`;</span><br><span class="line"></span><br><span class="line">    script.src = encodeURI(`$&#123;url&#125;?callback=$&#123;callbackName&#125;`);</span><br><span class="line">    script.async = true;</span><br><span class="line"></span><br><span class="line">    const timeoutId = window.setTimeout(() =&gt; &#123;</span><br><span class="line">      cleanUp();</span><br><span class="line"></span><br><span class="line">      return reject(new Error(&apos;Timeout&apos;));</span><br><span class="line">    &#125;, timeout);</span><br><span class="line"></span><br><span class="line">    window[callbackName] = data =&gt; &#123;</span><br><span class="line">      cleanUp();</span><br><span class="line"></span><br><span class="line">      return resolve(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    script.addEventListener(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">      cleanUp();</span><br><span class="line"></span><br><span class="line">      return reject(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    function cleanUp() &#123;</span><br><span class="line">      window[callbackName] = undefined;</span><br><span class="line">      head.removeChild(script);</span><br><span class="line">      window.clearTimeout(timeoutId);</span><br><span class="line">      script = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，jsonpID是一个共享的变量，它会确保每个请求都有独一无二的函数名字。<br>首先我们把head对象的引用保存在一个叫head的变量中，然后我们会增加jsonpID来确保函数名唯一。在函数内部返回一个promise，我们创建一个script标签以及由jsonpCallback和独一无二的ID组成的callbackName,然后我们把提供的url放到script标签的src属性上，设置callbackName = callbackName，这个实现不支持添加参数，只能get请求，可以添加async确保不会阻塞浏览器</p>
<p>返回的结果有三种可能</p>
<ul>
<li>要么正确  </li>
<li>要么错误  </li>
<li>要么超时<br>在上面的代码中都做了处理</li>
</ul>
<p>在cleanUp函数中抽象清理过程，三个函数-超时，成功，失败-看起来都长一样 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const timeoutId = window.setTimeout(() =&gt; &#123;</span><br><span class="line">  cleanUp();</span><br><span class="line"></span><br><span class="line">  return reject(new Error(&apos;Timeout&apos;));</span><br><span class="line">&#125;, timeout);</span><br><span class="line"></span><br><span class="line">window[callbackName] = data =&gt; &#123;</span><br><span class="line">  cleanUp();</span><br><span class="line"></span><br><span class="line">  return resolve(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">script.addEventListener(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  cleanUp();</span><br><span class="line"></span><br><span class="line">  return reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后在请求完成后调用cleanUp函数,注销挂载在window上的callbackName，移除script节点，清除定时器，将script置空，让script能被浏览器正常GC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function cleanUp() &#123;</span><br><span class="line">  window[callbackName] = undefined;</span><br><span class="line">  head.removeChild(script);</span><br><span class="line">  window.clearTimeout(timeoutId);</span><br><span class="line">  script = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再把script插入到head头中，script将会在插入的时候自动发送请求,<br>来个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsonp(</span><br><span class="line">  &apos;https://gist.github.com/maciejcieslar/1c1f79d5778af4c2ee17927de769cea3.json&apos;</span><br><span class="line">)</span><br><span class="line">  .then(console.log)</span><br><span class="line">  .catch(console.error);</span><br></pre></td></tr></table></figure>

<p>PS：当初被问的时候就不会，好气啊</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第1003之检查替换后的词是否有效</title>
    <url>/2019/08/08/leetcode-1003/</url>
    <content><![CDATA[<p>描述：: 给定有效字符串 “abc”。<br>对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。（X 或 Y 可以为空。）那么，X + “abc” + Y 也同样是有效的。<br>例如，如果 S = “abc”，则有效字符串的示例是：”abc”，”aabcbc”，”abcabc”，”abcabcababcc”。无效字符串的示例是：”abccba”，”ab”，”cababc”，”bac”。<br>如果给定字符串 S 有效，则返回 true；否则，返回 false</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; S</span><br><span class="line"> * @<span class="built_in">return</span> &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isValid = <span class="keyword">function</span>(S) &#123;</span><br><span class="line">    <span class="built_in">let</span> temp= <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span>(S.indexOf(<span class="string">'abc'</span>)!=-1)&#123;</span><br><span class="line">        temp= S.split(<span class="string">'abc'</span>).filter(item=&gt;item).join(<span class="string">""</span>);</span><br><span class="line">        S = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    const isFlag=(str)=&gt;&#123;</span><br><span class="line">         <span class="built_in">return</span> str ==<span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isFlag(S);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第70之爬楼梯</title>
    <url>/2019/08/08/leetcode-70/</url>
    <content><![CDATA[<p>描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。<br>两种写法，一种递归，一种开循环。<br>写递归有一个问题，当数据量庞大的时候，递归会爆栈，开循环就不存在爆栈的问题，因为循环只是在一个调用栈执行的，并且不会像递归一样重复计算值。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 爬楼梯</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @<span class="built_in">return</span> &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var climbStairs = <span class="keyword">function</span>(n) &#123;</span><br><span class="line">    <span class="built_in">let</span> ans =[1,2];</span><br><span class="line">    <span class="keyword">if</span>(n==1||n==2)&#123;</span><br><span class="line">        <span class="built_in">return</span> ans[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i = 2;i&lt;n;i++)&#123;</span><br><span class="line">        ans[i]=ans[i-1]+ans[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ans[n-1]</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">else</span> &#123;</span><br><span class="line">    //     <span class="built_in">return</span> climbStairs(n-1)+climbStairs(n-2);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(<span class="string">"climbStairs(44):"</span>, climbStairs(44));</span><br><span class="line">// climbStairs(3)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第73之矩阵置0</title>
    <url>/2019/08/08/leetcode-73/</url>
    <content><![CDATA[<p>描述：: 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @<span class="built_in">return</span> &#123;void&#125; Do not <span class="built_in">return</span> anything, modify matrix <span class="keyword">in</span>-place instead.</span><br><span class="line"> */</span><br><span class="line">var setZeroes = <span class="keyword">function</span>(matrix) &#123;</span><br><span class="line">    <span class="built_in">let</span> columns=new Set(),rows=new Set();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> row =0;row&lt;matrix.length;row++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> column =0;column&lt;matrix[row].length;column++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][column]==0)&#123;</span><br><span class="line">                columns.add(column);</span><br><span class="line">                rows.add(row);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> row =0;row&lt;matrix.length;row++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> column =0;column&lt;matrix[row].length;column++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(rows.has(row)||columns.has(column))&#123;</span><br><span class="line">               matrix[row][column]=0;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> matrix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题解：将0所在的行列储存起来作为标记，第二次循环的时候判断元素当前所在行或者列是否在标记的行或列即可</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第289之生命游戏</title>
    <url>/2019/08/08/leetcode_289/</url>
    <content><![CDATA[<p>描述：根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * leetcode 生命游戏</span><br><span class="line"> * @param &#123;number[][]&#125; board</span><br><span class="line"> * @<span class="built_in">return</span> &#123;void&#125; Do not <span class="built_in">return</span> anything, modify board <span class="keyword">in</span>-place instead.</span><br><span class="line"> */</span><br><span class="line">var gameOfLife = <span class="keyword">function</span>(board) &#123;</span><br><span class="line">    //额外空间法</span><br><span class="line">  <span class="built_in">let</span> tempArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> [...arr] = board[i];</span><br><span class="line">    tempArr.push(arr);</span><br><span class="line">  &#125;</span><br><span class="line">  const flag = (point, data, flag) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> count = 0;</span><br><span class="line">    <span class="built_in">let</span> top = 0,</span><br><span class="line">      bottom = data.length - 1;</span><br><span class="line">    //上下左右四个边界</span><br><span class="line">    //八个点 循环三层</span><br><span class="line">    <span class="keyword">if</span> (top &lt; point.x) &#123;</span><br><span class="line">      //说明当前节点的上一层节点存在至少一个节点</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = point.y - 1; i &lt;= point.y + 1; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[point.x - 1][i] == flag) &#123;</span><br><span class="line">          ++count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = point.y - 1; i &lt;= point.y + 1; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[point.x][i] == flag &amp;&amp; i != point.y) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bottom &gt; point.x) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = point.y - 1; i &lt;= point.y + 1; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[point.x + 1][i] == flag) &#123;</span><br><span class="line">          ++count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> count;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> x = 0; x &lt; board.length; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> y = 0; y &lt; board[0].length; y++) &#123;</span><br><span class="line">      const point = &#123;</span><br><span class="line">        x,</span><br><span class="line">        y</span><br><span class="line">      &#125;;</span><br><span class="line">      const count = flag(point, board, 1);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; 2 &amp;&amp; board[x][y] == 1) &#123;</span><br><span class="line">        tempArr[x][y] = 0;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((count == 2 || count == 3) &amp;&amp; board[x][y] == 1) &#123;</span><br><span class="line">        tempArr[x][y] = 1;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; 3 &amp;&amp; board[x][y] == 1) &#123;</span><br><span class="line">        tempArr[x][y] = 0;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == 3 &amp;&amp; board[x][y] == 0) &#123;</span><br><span class="line">        tempArr[x][y] = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> Object.assign(board, tempArr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// console.log(<span class="string">"gameOfLife([\r\n    [0,1,0],\r\n    [0,0,1],\r\n    [1,1,1],\r\n    [0,0,0]\r\n  ]):"</span>, gameOfLife([</span><br><span class="line">//     [0,1,0],</span><br><span class="line">//     [0,0,1],</span><br><span class="line">//     [1,1,1],</span><br><span class="line">//     [0,0,0]</span><br><span class="line">//   ]));</span><br><span class="line">// gameOfLife([</span><br><span class="line">//     [0,1,0],</span><br><span class="line">//     [0,0,1],</span><br><span class="line">//     [1,1,1],</span><br><span class="line">//     [0,0,0]</span><br><span class="line">//   ]);</span><br><span class="line"></span><br><span class="line">var _gameOfLife = <span class="keyword">function</span>(board) &#123;</span><br><span class="line">    //原地算法</span><br><span class="line">  const flag = (point, data, flag) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> count = 0;</span><br><span class="line">    <span class="built_in">let</span> top = 0,</span><br><span class="line">      bottom = data.length - 1;</span><br><span class="line">    </span><br><span class="line">    //上下左右四个边界</span><br><span class="line">    //八个点 循环三层</span><br><span class="line">    <span class="keyword">if</span> (top &lt; point.x) &#123;</span><br><span class="line">      //说明当前节点的上一层节点存在至少一个节点</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = point.y - 1; i &lt;= point.y + 1; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[point.x - 1][i] == flag[0]||data[point.x - 1][i] == flag[1]) &#123;</span><br><span class="line">          ++count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = point.y - 1; i &lt;= point.y + 1; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((data[point.x ][i] == flag[0]||data[point.x ][i] == flag[1]) &amp;&amp; i != point.y) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bottom &gt; point.x) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = point.y - 1; i &lt;= point.y + 1; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[point.x +1][i] == flag[0]||data[point.x +1][i] == flag[1]) &#123;</span><br><span class="line">          ++count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> count;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> x = 0; x &lt; board.length; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> y = 0; y &lt; board[0].length; y++) &#123;</span><br><span class="line">      const point = &#123;</span><br><span class="line">        x,</span><br><span class="line">        y</span><br><span class="line">      &#125;;</span><br><span class="line">      //alive -&gt; dead -2</span><br><span class="line">      //dead -&gt; alive 2</span><br><span class="line">      const count = flag(point, board, [1,-2]);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; 2 &amp;&amp; board[x][y] == 1) &#123;</span><br><span class="line">        board[x][y] = -2;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((count == 2 || count == 3) &amp;&amp; board[x][y] == 1) &#123;</span><br><span class="line">        board[x][y] = 1;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; 3 &amp;&amp; board[x][y] == 1) &#123;</span><br><span class="line">        board[x][y] = -2;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == 3 &amp;&amp; board[x][y] == 0) &#123;</span><br><span class="line">        board[x][y] = 2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> x = 0; x &lt; board.length; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> y = 0; y &lt; board[0].length; y++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[x][y] == -2) &#123;</span><br><span class="line">        board[x][y]=0;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(board[x][y]==2)&#123;</span><br><span class="line">        board[x][y]=1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> board;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"\r\n_gameOfLife([\r\n    [0,1,0],\r\n    [0,0,1],\r\n    [1,1,1],\r\n    [0,0,0]\r\n  ]):"</span>, </span><br><span class="line">_gameOfLife([</span><br><span class="line">    [0,1,0],[0,0,1],[1,1,1],[0,0,0]</span><br><span class="line">  ]));</span><br><span class="line"></span><br><span class="line">_gameOfLife([</span><br><span class="line">    [0,1,0],[0,0,1],[1,1,1],[0,0,0]</span><br><span class="line">  ])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第55之跳跃游戏</title>
    <url>/2019/08/08/leetcode_55/</url>
    <content><![CDATA[<p> 描述:给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @<span class="built_in">return</span> &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">var canJump = <span class="keyword">function</span>(nums) &#123;</span><br><span class="line">    const length = nums.length;</span><br><span class="line">    <span class="built_in">let</span> lastIndex = nums.length-1;</span><br><span class="line">    const res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i=lastIndex;i&gt;=0;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+i&gt;=lastIndex)&#123;</span><br><span class="line">             </span><br><span class="line">                lastIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> lastIndex == 0 ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/08/13/listNode/</url>
    <content><![CDATA[<p>链表相比数组而言，链表对数据的插入数据的空间复杂度为o(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*链表节点</span><br><span class="line">*param &#123;*&#125; val</span><br><span class="line">*param &#123;ListNode&#125; next</span><br><span class="line">**/</span><br><span class="line">function ListNode(val,next=null)&#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*将数组转为链表</span><br><span class="line">*param &#123;array&#125; a</span><br><span class="line">*param &#123;ListNode&#125; </span><br><span class="line">**/</span><br><span class="line">const getListFromArray=a=&gt;&#123;</span><br><span class="line">    let dummy = new ListNode()</span><br><span class="line">    let pre =dummy;</span><br><span class="line">    a.forEach(x =&gt; &#123;</span><br><span class="line">        return pre=pre.next=new ListNode(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序遍历链表"><a href="#顺序遍历链表" class="headerlink" title="顺序遍历链表"></a>顺序遍历链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let listNodeArr = getListFromArray(arr);</span><br><span class="line">while(listNodeArr!=null)&#123;</span><br><span class="line">    console.log(listNodeArr.val);</span><br><span class="line">    listNodeArr=listNodeArr.next;</span><br><span class="line">&#125;</span><br><span class="line">//1 2 3 4 5 6</span><br></pre></td></tr></table></figure>

<h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><p>第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var removeNthFromEnd = function(head, n) &#123;</span><br><span class="line">    let dummy=new ListNode(0);</span><br><span class="line">    dummy.next=head;</span><br><span class="line">    let slow=dummy;</span><br><span class="line">    let fast=dummy;</span><br><span class="line">    for(let i =1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!slow)return head.next;</span><br><span class="line">    while(slow!=null)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast.next=fast.next.next;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"> removeNthFromEnd(listNodeArr,4);</span><br></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    let slow = head, fast = head</span><br><span class="line">    while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        if (slow === fast) &#123; return true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    if(!head || !head.next) return null;</span><br><span class="line">    </span><br><span class="line">    let slow = head;</span><br><span class="line">    let fast = head;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if(!fast || !fast.next) return null;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast =fast.next.next;</span><br><span class="line">        if(slow === fast) break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    slow = head;</span><br><span class="line">    while (slow !== fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png" alt="图片"></p>
<p>我们利用已知的条件：慢指针移动 1 步，快指针移动 2 步，来说明它们相遇在环的入口处。（下面证明中的 tortoise 表示慢指针，hare 表示快指针）<br>2⋅distance(tortoise)=distance(hare)<br>2(F+a)=F+a+b+a<br>2F+2a=F+2a+b<br>F=b<br>​因为 F=b，指针从 hh 点出发和从链表的头出发，最后会遍历相同数目的节点后在环的入口处相遇。</p>
<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; headA</span><br><span class="line"> * @param &#123;ListNode&#125; headB</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> * 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line"> * 思路：想法特别精妙，两个链表长度不一致，短+长拼接和长+短拼接，最后节点相等时不是相交节点就是（null===null）</span><br><span class="line"> * 举栗子：[0,9,1,2,4]和[3,2,4] 两个链表拼接后[0,9,1,2,4,3,2,4]和[3,2,4,0,9,1,2,4]相交节点在2开始相同</span><br><span class="line"> */</span><br><span class="line">var getIntersectionNode = function(headA, headB) &#123;</span><br><span class="line">  if (headA === null || headB === null) return null;</span><br><span class="line">  let curA = headA;</span><br><span class="line">  let curB = headB;</span><br><span class="line">  // curA===curB说明相交或者全部节点走完直接返回</span><br><span class="line">  while (curA !== curB) &#123;</span><br><span class="line">    //A节点走完走B 实现A+B</span><br><span class="line">    curA = curA === null ? headB : curA.next;</span><br><span class="line">    curB = curB === null ? headA : curB.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return curA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<html>
  <head><meta name="generator" content="Hexo 3.9.0">
    <style>
      .css-82kbtk-Text {
        font-family: monospace;
        white-space: pre;
        user-select: none;
        font-size: 12px;
        line-height: 14px;
        color: rgb(38, 50, 56);
        max-height: 100px;
        margin: 0px 20px;
        overflow: auto;
    }
    </style>
  </head>
  <body>
    <div class="css-82kbtk-Text"> 
     _   _      _ _    __        __         _     _ 
    | | | | ___| | | __\ \      / /__  _ __| | __| |
    | |_| |/ _ \ | |/ _ \ \ /\ / / _ \| '__| |/ _` |
    |  _  |  __/ | | (_) \ V  V / (_) | |  | | (_| |
    |_| |_|\___|_|_|\___/ \_/\_/ \___/|_|  |_|\__,_|
    </div>
  </body>
</html>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>listNode</tag>
      </tags>
  </entry>
  <entry>
    <title>元素定位</title>
    <url>/2020/12/31/location/</url>
    <content><![CDATA[<ol>
<li><p>focus</p>
<ul>
<li><p>Options</p>
<p>An optional object providing options to control aspects of the focusing process. This object may contain the following property:</p>
<ul>
<li><p>preventScroll Optional</p>
<p> A Boolean value indicating whether or not the browser should scroll the document to bring the newly-focused element into view. A value of false for preventScroll (the default) means that the browser will scroll the element into view after focusing it. If preventScroll is set to true, no scrolling will occur.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>计算元素的scrollTop，让滚动列表的scrollTop的值等于元素的scrollTop</p>
</li>
<li><p>scrollIntoView</p>
<p> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView" target="_blank" rel="noopener">文档</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2020/08/07/mianshi/</url>
    <content><![CDATA[<p>今天面了一家公司，电面。差不多是这些题目</p>
<ol>
<li>动画</li>
<li>浏览器储存</li>
<li>缓存机制 – 强缓存和协商缓存</li>
<li>vue响应式原理 – 2和3</li>
<li>react事件</li>
<li>浏览器安全和工程化</li>
<li>http协议</li>
<li>Promise</li>
<li>typescript</li>
<li>浏览器性能优化</li>
<li>vue3相比vue2的优点</li>
<li>webpack优化</li>
<li>首屏优化</li>
<li>元素隐藏</li>
</ol>
<a id="more"></a>

<h3 id="怎么让元素隐藏"><a href="#怎么让元素隐藏" class="headerlink" title="怎么让元素隐藏"></a>怎么让<code>元素隐藏</code></h3><p>两个属性:</p>
<ol>
<li>display</li>
<li>visible</li>
</ol>
<p>两个属性有什么区别：</p>
<ol>
<li><code>display:none</code> 销毁dom元素</li>
<li><code>visble：hidden</code> 不销毁dom元素</li>
</ol>
<p>哪个会产生回流，哪个会产生重绘</p>
<ol>
<li><code>display</code> 会产生回流，因为影响了周围的元素位置</li>
<li><code>visible</code> 只会产生重绘</li>
</ol>
<h3 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h3><p>一、 哪些属性可以产生动画</p>
<ol>
<li><code>animation</code></li>
<li><code>key-frames</code></li>
<li><code>requestAnimationFrame</code></li>
</ol>
<p>三者有什么不同</p>
<ol>
<li><code>animation</code>和<code>requestAnimationFrame</code>没有时间轴的概念。产生的动画是连续的。</li>
</ol>
<p>如果在JS主线程中有一个阻塞任务，那么三种不同方式产生的动画会卡顿吗？为什么？</p>
<p><strong>wdm，触及到我的知识盲区</strong></p>
<h3 id="浏览器储存相关"><a href="#浏览器储存相关" class="headerlink" title="浏览器储存相关"></a>浏览器储存相关</h3><p>一、浏览器有哪些储存方式</p>
<ol>
<li>cookie</li>
<li>sessionStorage</li>
<li>localStorge</li>
</ol>
<p>二、有哪些区别</p>
<ol>
<li>cookie储存发数据比较小，大概4k</li>
<li>sessionStorage储存数据有时间限制，并且储存在sessionStorage的数据会在当前页面会话结束时清除</li>
<li>localStorage储存数据没有时间限制，localStorage中的数据除非手动清除，否则数据不会消失</li>
</ol>
<p>三、如果要让localStorage实现数据有过期的效果该怎么实现</p>
<p>在把数据存进localStorage的时候同时存放时间参数。每次取值的时候根据时间参数来比对数据是否过期</p>
<h3 id="资源缓存相关"><a href="#资源缓存相关" class="headerlink" title="资源缓存相关"></a>资源缓存相关</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>在http1.0时期，使用的是expire来判断资源是否过期。这个字段存放的是具体的过期时间，比如2020年八月九日，但是这样会有一个问题，当服务器时间和本地浏览器时间不一致的时候，给出具体过期时间会对资源是否过期判断错误，因此在http1.1对时候新加了cache-control字段，这个字段用来存放资源的过期时长，用max-age记录。当强缓存没有命中的时候那么进行协商缓存。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存主要有两个字段一个是<code>If-modified-Since</code>，这个值跟<code>Last-modifed</code>配对，一个是<code>Etag</code>，这个跟<code>If-Match</code>配对,两个主要记录的东西不同。前者是记录文件的修改时间，后者是根据文件内容生成一个Etage值，对于如何生成Etag值，并没有明确规定。而通常生成Etage的值是使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号。<br>对于<code>if-modifued-since</code>来说，假如文件只是修改了格式，但是内容并没有改变，但是对这个值来说，仍然会告诉浏览器资源无效并且返回新的资源，这明显是不太合适的<br>对于<code>Etag</code>来说，当且仅当文件内容有所变更时，此时Etag值就会相应的更新，因此就可以告诉浏览器缓存的资源已经过期。ETag头的另一个典型用例是缓存未更改的资源。 如果用户再次访问给定的URL（设有ETag字段），显示资源过期了且不可用，客户端就发送值为ETag的If-None-Match header字段。服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用（新鲜）</p>
<h3 id="vue响应式原理相关"><a href="#vue响应式原理相关" class="headerlink" title="vue响应式原理相关"></a>vue响应式原理相关</h3><h4 id="两者实现方式的区别"><a href="#两者实现方式的区别" class="headerlink" title="两者实现方式的区别"></a>两者实现方式的区别</h4><p>vue2是使用了Object.defineProperty来实现的数据监听<br>vue3是使用了Proxy来实现的数据监听</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假如有一个响应式数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const obj = reactive(&#123;a:1&#125;)</span><br><span class="line">const computed_obj = computed(()=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> obj.a+1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为什么对a修改之后，computed_obj也会相应的进行修改?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在执行obj.a的时候，就会执行track方法</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> track(target: object, <span class="built_in">type</span>: TrackOpTypes, key: unknown) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === undefined) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = new Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = new Set()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    <span class="comment"># 这个activeEffect就是在这之前执行的依赖函数</span></span><br><span class="line">    <span class="comment"># dep 就是 target[key]的依赖</span></span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="built_in">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此当响应式对象更改时，其对应的依赖项会执行一遍，因此此时computed函数就会执行一次。</p>
<h3 id="react事件相关"><a href="#react事件相关" class="headerlink" title="react事件相关"></a>react事件相关</h3><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p> setState什么时候是同步的？什么时候是异步的？</p>
<p> 当事件是合成事件时，即由react控制的事件时，就是异步的；<br> 如果是由addEventlistener监听时或者在定时器中执行时，那就是同步的。</p>
<h3 id="浏览器安全以及工程化相关"><a href="#浏览器安全以及工程化相关" class="headerlink" title="浏览器安全以及工程化相关"></a>浏览器安全以及工程化相关</h3><h4 id="数据传输安全"><a href="#数据传输安全" class="headerlink" title="数据传输安全"></a>数据传输安全</h4><p> 使用https传输数据，服务端从第三方平台获取非堆成加密的公钥和私钥，客户端从服务端获取公钥，然后在客户端随机生成哈希串，然后用公钥对这个哈希串加密，然后把加密后的哈希串发送给服务端，服务端用私钥对这个哈希串进行解密，这个时候客户端和服务端就有了共同的哈希串，然后客户端和服务端用这个哈希串对明文进行加密传输。</p>
<h4 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h4><p>工程化即系统化、模块化、规范化的一个过程。</p>
<p>工程化需要做什么：</p>
<ol>
<li><p>统一团队成员的编码规范，便于团队协作和代码维护，包括：</p>
<ul>
<li>目录结构，文件命名规范</li>
<li>编码规范：eslint stylelint等</li>
</ul>
</li>
<li><p>开发流程的规范</p>
<ul>
<li>应对各项风险，需求变更等</li>
<li>code review机制</li>
</ul>
</li>
<li><p>前后端接口规范，其他文档规范</p>
</li>
<li><p>使用版本管理工具来安全高效等管理代码</p>
<ul>
<li>对git对使用</li>
<li>规范commit描述</li>
<li>创建merge request ，code review通过后才可以进行merge</li>
</ul>
</li>
<li><p>使用合适对技术栈编码，来提高开发效率以及维护难度</p>
<ul>
<li>用模块化对方式来组织代码，包括js模块化，css模块化</li>
<li>采用组件化对编程思想，处理UI层</li>
<li>将数据层和UI层分离</li>
</ul>
</li>
<li><p>提高代码可靠性，引入单元测试</p>
</li>
</ol>
<h3 id="http协议相关"><a href="#http协议相关" class="headerlink" title="http协议相关"></a>http协议相关</h3><p>http请求中分为哪些部分？</p>
<ol>
<li>请求头</li>
<li>请求体</li>
</ol>
<p>http2.0 相比较之前的协议有哪些改进？</p>
<ol>
<li>多路复用，复用tcp连接，并且可以不按顺序，和二进制分帧一起解决队头堵塞问题</li>
<li>二进制分帧</li>
<li>头部压缩，传递方法的时候只传递索引，服务端根据索引去索引表查询方法</li>
<li>允许服务端推送，这样客户端不用发起请求获得后续资源<br>http传输是根据什么协议传输？为什么？</li>
</ol>
<ul>
<li>tcp/ip协议，安全可靠</li>
</ul>
<p>http传输在哪个层进行传输？</p>
<ul>
<li>应用层</li>
</ul>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const data = Promise.resolve(2)</span><br></pre></td></tr></table></figure>

<p>这个就算是使用了resolve，那么data也不会被赋值成2，而是一个promise对象<br>，只有在调用了then方法后才会得到真正对值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Promise.resolve(2).<span class="keyword">then</span>(res=&gt;console.log(res))</span><br><span class="line"><span class="comment"># 这时候就会输出22</span></span><br></pre></td></tr></table></figure>

<p>同时 then方法接受两个函数类型对参数，一个是onfulfilled，一个是onrejected，前者在调用resolve的时候进入，后者则是在调用reject或者抛出错误的时候调用，因此catch也可以被叫做是then的语法糖，因为catch方法可以等于then(null,onRejected)</p>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>在ts中 interface 和 type 的区别？</p>
<p><strong>相同点：</strong></p>
<ol>
<li>都可以描述一个对象或者函数✅</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SetUser &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> User = &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> SetUser = (name: string, age: number)=&gt; void;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>都允许拓展✅</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interface extends interface</span></span><br><span class="line"></span><br><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type extends type</span></span><br><span class="line"><span class="built_in">type</span> Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> User = Name &amp; &#123; age: number  &#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interface extends type</span></span><br><span class="line"><span class="built_in">type</span> Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type extends interface</span></span><br><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不同点：</strong></p>
<ol>
<li><p>type 可以声明基本类型别名，联合类型，元组等类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本类型别名</span></span><br><span class="line"><span class="built_in">type</span> Name = string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 联合类型</span></span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="built_in">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure>
</li>
<li><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class="line"><span class="built_in">let</span> div = document.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">type</span> B = typeof div</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>interface 可以进行声明合并</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面两个接口哦可以合并成下面这个接口声明</span></span><br><span class="line">interface User&#123;</span><br><span class="line">    name:string,</span><br><span class="line">    age:number,</span><br><span class="line">    sex:string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器性能优化"><a href="#浏览器性能优化" class="headerlink" title="浏览器性能优化"></a>浏览器性能优化</h3><p>采用chrome标签的performace 来 查看 页面渲染过程中可能发生卡顿的 片段，查看在执行过程中 耗时过长的函数，配合火焰图查看函数调用栈深度</p>
<ol>
<li>使用RequestAnimationFrame函数实现动画，或者新建图层来实现动画</li>
<li>使用Web Workers来执行耗费大量时间的任务</li>
<li>降低样式计算复杂度，</li>
<li>避免动态修改样式<h3 id="v3相比v2优点"><a href="#v3相比v2优点" class="headerlink" title="v3相比v2优点"></a>v3相比v2优点</h3>v3 有更棒的tree-shaking<br>v3 的dom diff性能优化，只监听变量，而对于静态节点不进行比较<br>v3 有更好的ts支持<br>v3 能够根据数据索引值来对数据进行监听了<br>v3 体积更小<h3 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h3>见面试2<h3 id="首屏渲染优化"><a href="#首屏渲染优化" class="headerlink" title="首屏渲染优化"></a>首屏渲染优化</h3></li>
</ol>
<ul>
<li>减少请求资源数<ul>
<li>图片合成雪碧图</li>
<li>webpack的html-webpack-plugin</li>
</ul>
</li>
<li>减少资源体积<ul>
<li>webpack对图片体积的压缩，转base64</li>
<li>不在视口区域的元素不渲染</li>
<li>非重点文件延迟加载defer</li>
<li>重点登陆页可以考虑ssr</li>
</ul>
</li>
<li>loading过程可以采用骨架屏</li>
<li>组件动态加载</li>
<li>路由动态加载</li>
<li>图片懒加载</li>
<li>图片格式尽量采用webp或者avif</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试总结(2)</title>
    <url>/2020/08/30/mianshi2/</url>
    <content><![CDATA[<h2 id="https握手过程"><a href="#https握手过程" class="headerlink" title="https握手过程"></a>https握手过程</h2><ol>
<li>服务端生成公私钥</li>
<li>服务端把公钥，加密的hash算法以及个人信息发送给CA</li>
<li>CA把服务端发送来的明文信息用服务端发来的hash算法加密生成密文，然后用CA的私钥对密文进行加密生成签名</li>
<li>CA把证书发还给服务端，证书内容包括签名，以及证书的颁发对象以及 颁发者等信息。</li>
<li>服务端把证书和明文信息一起发送给客户端</li>
<li>客户端接收服务端发送的证书，用内置在操作系统的公钥对签名进行解密，然后用服务端发来对hash算法对明文进行加密，如果两次生成的字符串相等，那么数据是可信的</li>
<li>客户端在本地随机生成random1，发送给服务端</li>
<li>服务端在本地随机生成random2，发送给客户端</li>
<li>客户端在本地随机生成random3，然后用服务端发来的公钥对random3加密发送给服务端</li>
<li>客户端服务端根据三个随机random各自生成对称密钥</li>
<li>用生成的对称密钥加密一段握手信息，发送给服务端。双端验证。</li>
<li>后续加密用生成的对称密钥加密<a id="more"></a>
<h2 id="输入URL到页面渲染过程"><a href="#输入URL到页面渲染过程" class="headerlink" title="输入URL到页面渲染过程"></a>输入URL到页面渲染过程</h2></li>
<li>浏览器进程拼接URL，加协议</li>
<li>网络进程根据URl做DNS解析</li>
<li>请求的资源返回给渲染进程</li>
<li>渲染进程根据返回的状态码以及content-type来进行后续的流程</li>
<li>是html类型则进行渲染流程</li>
<li>生成CSSOM以及DOM</li>
<li>生成Render树。</li>
<li>根据render树生成图层树</li>
<li>渲染进程对图层进行绘制，把图层绘制拆分成一个个的绘制指令，绘制指令组成绘制列表</li>
<li>渲染进程的合成线程来进行实际的绘制操作</li>
<li>合成线程在光栅化线程中执行光栅化（把图层转化成位图）</li>
<li>光栅化采用GPU加速，因此实际绘制过程在GPU进程</li>
<li>光栅化结束渲染进程通知浏览器进程</li>
<li>浏览器进程接收drawquard命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</li>
<li>done！</li>
</ol>
<h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><p>略</p>
<h2 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h2><p>parseInt Number 两者区别<br>略</p>
<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>找本地缓存，没找到请求域名服务器</p>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>略</p>
<h2 id="强缓存-协商缓存"><a href="#强缓存-协商缓存" class="headerlink" title="强缓存 协商缓存"></a>强缓存 协商缓存</h2><ul>
<li><p>强缓存：</p>
<ul>
<li>Cache-Control</li>
<li>Expire</li>
</ul>
</li>
<li><p>协商缓存：</p>
<ul>
<li>If-Modified-Since</li>
<li>Etag<br>其他略</li>
</ul>
</li>
</ul>
<h2 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h2><p>数据劫持 ➕ 发布订阅</p>
<h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><p>依赖收集 + 依赖更细</p>
<h2 id="react-fiber"><a href="#react-fiber" class="headerlink" title="react fiber"></a>react fiber</h2><ol>
<li>根据component生成fiber树</li>
<li>每个节点都对应一个fiber节点</li>
<li>当前渲染在屏幕上的是current树</li>
<li>current树有一个是alternate的指针指向wip树</li>
<li>wip也有相同的指针指向current树</li>
<li>wip树是fork了一份current树，这个叫做double buffering</li>
<li>有两个阶段，一个是render，一个是commit</li>
<li>render阶段可以被打断，commit阶段不可以被打断</li>
<li>render阶段的任务主要根据插入的顺序来执行，通过使用requestIdlecallback这个api来实现任务的调度</li>
<li>高优先级的任务可以打断低优先级的任务执行，比如用户输入等需要及时反馈的任务属于高优先级，而对于数据获取这类的任务属于低优先级</li>
<li>react内部通过使用messageChannel来实现reqeustIdleCallback的polyfill</li>
</ol>
<h2 id="xss防御"><a href="#xss防御" class="headerlink" title="xss防御"></a>xss防御</h2><ol>
<li>转码</li>
<li>白名单</li>
<li>过滤</li>
</ol>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><ol>
<li>SameSite<ul>
<li>Lax</li>
<li>Strict</li>
<li>None</li>
</ul>
</li>
<li>x-frame-option</li>
<li>csp<ul>
<li>default-src</li>
<li>image-src</li>
<li>media-src</li>
<li>script-src</li>
</ul>
</li>
<li>token</li>
<li>refer/origin</li>
</ol>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol>
<li><p>webpack</p>
<ul>
<li>缩小构建体积（分包，tree-shaking，剔除第三方库不需要的模块）</li>
<li>缓存（cache-loader，hard-source-webpack-plugin，dll）</li>
<li>预加载（preload）</li>
<li>减少请求资源数（mini-css-extract-plugin，html-webpack-plugin）</li>
</ul>
</li>
<li><p>差异化服务</p>
</li>
<li><p>图片懒加载（非可视区域图片用placeholder替代或者低质量图片）</p>
</li>
<li><p>减少时间复杂度</p>
</li>
<li><p>非必要文件异步加载或动态加载模块</p>
</li>
<li><p>对核心内容启用SSR</p>
</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>CORS</p>
<p>img</p>
<p>script</p>
]]></content>
      <tags>
        <tag>article</tag>
        <tag>conclusion</tag>
      </tags>
  </entry>
  <entry>
    <title>mutationObserver</title>
    <url>/2019/12/18/mutationObserver/</url>
    <content><![CDATA[<h3 id="MutationObserver-一个监听dom元素变化的接口"><a href="#MutationObserver-一个监听dom元素变化的接口" class="headerlink" title="MutationObserver,一个监听dom元素变化的接口"></a>MutationObserver,一个监听dom元素变化的接口</h3><p>dom元素观察者，监视 DOM 变动的接口，但是事件是异步的，需要等所有dom元素渲染完之后才执行<br>实例化一个observer对象,回调函数接收两个参数，一个是改变的属性所组成的一个对象数组，一个是实例本身</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const observer = new MutationObserver(mutationCallback);</span><br></pre></td></tr></table></figure>

<p>以下是它的属性介绍<br>|  属性   | 类型  | 描述  |<br>|  —-  | —-  | —- |<br>| childList  | Boolean |是否观察子节点的变动<br>| attributes  | Boolean |是否观察属性的变动<br>| characterData  | Boolean |是否节点内容或节点文本的变动<br>| subtree  | Boolean |是否观察所有后代节点的变动<br>| attributeOldValue  | Boolean |观察 attributes 变动时，是否记录变动前的属性值<br>| characterDataOldValue  | Boolean |观察 characterData 变动时，是否记录变动前的属性值<br>| attributeFilter  | Boolean |表示需要观察的特定属性（比如[‘class’,’src’]），不在此数组中的属性变化时将被忽略</p>
<p>实例初始化后,实例调用observe来监听targetNode属性的变化，需要监听的属性放在config中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">    attributes:true,</span><br><span class="line">    childList:true,</span><br><span class="line">    subtree:true</span><br><span class="line">&#125;</span><br><span class="line">const targetNode = document.getElementById(&apos;test&apos;);</span><br><span class="line">observer.observe(targetNode,config)</span><br></pre></td></tr></table></figure>

<p>回调函数中可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mutationCallback = (mutationList)=&gt;&#123;</span><br><span class="line">  for(let mutation of mutationList)&#123;</span><br><span class="line">    const type = mutation.type;</span><br><span class="line">    switch(type)&#123;</span><br><span class="line">      case &apos;childList&apos;:</span><br><span class="line">        console.log(&apos;A child node has added or removed&apos;);</span><br><span class="line">        break;</span><br><span class="line">      case &apos;attributes&apos;:</span><br><span class="line">        console.log(`the $&#123;mutation.attributaName&#125; attribute was modified`);</span><br><span class="line">        break;</span><br><span class="line">      case &apos;subtree&apos;:</span><br><span class="line">        console.log(&apos;the subtree was modified&apos;;)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本这样就可以完成了一个对dom元素的监听了</p>
<p>当不想监听dom元素变化的时候,可以用disconnect来取消监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">observer.disconnnet()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mutation</tag>
      </tags>
  </entry>
  <entry>
    <title>npm包的发布</title>
    <url>/2020/09/02/npm-pkg/</url>
    <content><![CDATA[<p><strong>趁趁趁着还不太忙，补个npm包的发布</strong></p>
<ul>
<li>那么首先就是<code>npm init -y</code>初始化一个npm仓库</li>
<li>然后<code>touch index.js</code>创建index文件</li>
<li>安装<code>chalk figlet commander</code>这几个包，⚠️一定一定要装开发依赖！！</li>
<li>然后coding</li>
<li>要记得在package文件加上bin字段，value是对象，key是要在<code>terminal</code>运行的命令，key对应的对象是要执行的文件</li>
<li>⚠️一定一定要记得在执行的文件的头部要加<code>#!/usr/bin/env node</code>(心塞，查了好久才找到)！！！</li>
<li>coding结束要用<code>npm link</code>本地调试一个，记住npm的repo不要定位到淘宝的去！！</li>
<li>没有账号的记得注册，然后用npm login 登陆一下</li>
<li>npm publish，⚠️一定一定要记得改版本号！！如果publish的时候403了，maybe是你的包重名了，记得去npm上查一下你的包有没有跟别人的重了(踩坑踩的那叫一踩一个准hhh)<br>Done！</li>
</ul>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>provide of vue3</title>
    <url>/2020/06/28/provide/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好奇provide怎么实现的，然后呢就去扒了下源码hhh，看了下provide的function，有点懵,provide的代码在runtime-core/src/apiInject.ts里面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> interface InjectionKey&lt;T&gt; extends Symbol &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string, value: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!currentInstance) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(`provide() can only be used inside setup().`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">let</span> provides = currentInstance.provides</span><br><span class="line">    <span class="comment"># by default an instance inherits its parent's provides object</span></span><br><span class="line">    <span class="comment"># but when it needs to provide values of its own, it creates its</span></span><br><span class="line">    <span class="comment"># own provides object using parent provides object as prototype.</span></span><br><span class="line">    <span class="comment"># this way in `inject` we can simply look up injections from direct</span></span><br><span class="line">    <span class="comment"># parent and let the prototype chain do the work.</span></span><br><span class="line">    const parentProvides =</span><br><span class="line">      currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><br><span class="line">    <span class="keyword">if</span> (parentProvides === provides) &#123;</span><br><span class="line">      provides = currentInstance.provides = Object.create(parentProvides)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># TS doesn't allow symbol as index type</span></span><br><span class="line">    provides[key as string] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>有点纳闷为啥parentProvides === provides 的时候就可以判断当前的实例调用了provide，然后我用尤大的那个vite写了个demo，父元素调用provide，子元素也调用provide<br><br>App.vue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;HelloWorld msg=<span class="string">"Hello Vue 3.0 + Vite"</span> /&gt;</span><br><span class="line">  &#123;&#123;foo&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from <span class="string">'./components/HelloWorld.vue'</span></span><br><span class="line">import &#123;provide,inject&#125; from <span class="string">'vue'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props,ctx)&#123;</span><br><span class="line">	  provide(<span class="string">'foo'</span>,1)</span><br><span class="line">	  // console.log(ctx,props)</span><br><span class="line">	  <span class="built_in">return</span> &#123;</span><br><span class="line">		  foo:inject(<span class="string">'foo'</span>)</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>

<p>HelloWorld.vue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">	&lt;button @click=<span class="string">"count++"</span>&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">		Edit</span><br><span class="line">		&lt;code&gt;components/HelloWorld.vue&lt;/code&gt;</span><br><span class="line">		to <span class="built_in">test</span> hot module replacement.</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">	&#123;&#123;foo&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref ,provide,inject,defineComponent&#125; from <span class="string">'vue'</span>;</span><br><span class="line"><span class="built_in">export</span> default defineComponent(&#123;</span><br><span class="line">	name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		msg: String</span><br><span class="line">	&#125;,</span><br><span class="line">	setup(props,ctx ) &#123;</span><br><span class="line">		// debugger</span><br><span class="line">		const count = ref(0);</span><br><span class="line">		provide(<span class="string">'bar'</span>,2)</span><br><span class="line">		// debugger</span><br><span class="line">		// console.log(ctx.provide)</span><br><span class="line">		const foo = inject(<span class="string">'foo'</span>)</span><br><span class="line">		<span class="built_in">return</span> &#123;</span><br><span class="line">			count,</span><br><span class="line">			foo</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>

<p>在debug的时候在调用栈里面发现在调用mount的时候以此调用了render,patch,processComponent,mountComponent..这些方法，render和patch应该是和dom相关，然后看processComponent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (n1 == null) &#123;</span><br><span class="line">          <span class="keyword">if</span> (n2.shapeFlag &amp; 512 /* COMPONENT_KEPT_ALIVE */) &#123;</span><br><span class="line">              parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          updateComponent(n1, n2, optimized);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>emmm看起来还是跟dom相关,直接看渲染组件的时候干了啥吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123;</span><br><span class="line">       const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense)); //看这个实例</span><br><span class="line">       //省略代码</span><br><span class="line">       // setup() is async. This component relies on async logic to be resolved</span><br><span class="line">       // before proceeding</span><br><span class="line">       //省略代码</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<br>
createComponentInstance

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createComponentInstance(vnode, parent, suspense) &#123;</span><br><span class="line">    // inherit parent app context - or - <span class="keyword">if</span> root, adopt from root vnode</span><br><span class="line">    // 继承父级app上下文，如果是root，调整为根节点</span><br><span class="line">    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><br><span class="line">    const instance = &#123;</span><br><span class="line">        //省略</span><br><span class="line">        provides: parent ? parent.provides : Object.create(appContext.provides),</span><br><span class="line">        //省略</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">'production'</span>)) &#123;</span><br><span class="line">        instance.ctx = createRenderContext(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        instance.ctx = &#123; _: instance &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    instance.root = parent ? parent.root : instance;</span><br><span class="line">    instance.emit = emit.bind(null, instance);</span><br><span class="line">    <span class="built_in">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果instance如果有父元素的话，instance里面的provides是会继承父节点中的provides<br>所以这就是为啥provide方法中判断当前的provide和父元素的是否相等，因为如果当前节点调用provide方法的话，那么当前元素的provide一定是和父元素的provide的引用地址相同的，所以当前的provide就可以把父元素的provide当做原型链来生成一个新的object<br><br><br>然后我回头看了下provide方法的注解，默认情况下实例是继承父元素的provides的，操啊，我花这么多时间是干啥啊！</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式模块</title>
    <url>/2020/07/09/reactive/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue3 出了 beta，了解一下响应式数据的实现</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p>下面这些是在 reactive 中导入的外部文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import &#123; isObject, toRawType, def, hasOwn, makeMap &#125; from <span class="string">'@vue/shared'</span><span class="comment">##这些都是通用方法</span></span><br><span class="line"><span class="comment">## 两个handler，待会儿说为啥</span></span><br><span class="line">import &#123;</span><br><span class="line">  mutableHandlers,</span><br><span class="line">  readonlyHandlers,</span><br><span class="line">  shallowReactiveHandlers,</span><br><span class="line">  shallowReadonlyHandlers</span><br><span class="line">&#125; from <span class="string">'./baseHandlers'</span></span><br><span class="line">import &#123;</span><br><span class="line">  mutableCollectionHandlers,</span><br><span class="line">  readonlyCollectionHandlers,</span><br><span class="line">  shallowCollectionHandlers</span><br><span class="line">&#125; from <span class="string">'./collectionHandlers'</span></span><br><span class="line"><span class="comment">## 然后是ref，是为了给primitive类型的value做reactive</span></span><br><span class="line">import &#123; UnwrapRef, Ref &#125; from <span class="string">'./ref'</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后是常量定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 枚举类型</span></span><br><span class="line"><span class="built_in">export</span> const enum ReactiveFlags &#123;</span><br><span class="line">  SKIP = <span class="string">'__v_skip'</span>,</span><br><span class="line">  IS_REACTIVE = <span class="string">'__v_isReactive'</span>,</span><br><span class="line">  IS_READONLY = <span class="string">'__v_isReadonly'</span>,</span><br><span class="line">  RAW = <span class="string">'__v_raw'</span>,</span><br><span class="line">  REACTIVE = <span class="string">'__v_reactive'</span>,</span><br><span class="line">  READONLY = <span class="string">'__v_readonly'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## 所监听数据中的属性接口</span></span><br><span class="line">interface Target &#123;</span><br><span class="line">  [ReactiveFlags.SKIP]?: boolean</span><br><span class="line">  [ReactiveFlags.IS_REACTIVE]?: boolean</span><br><span class="line">  [ReactiveFlags.IS_READONLY]?: boolean</span><br><span class="line">  [ReactiveFlags.RAW]?: any</span><br><span class="line">  [ReactiveFlags.REACTIVE]?: any</span><br><span class="line">  [ReactiveFlags.READONLY]?: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>typeof Map = &#39;function&#39;</code>以及 Set 里面的四个类型都是，所以这里的 collectionTypes 要变成 new Set<function></function></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const collectionTypes = new Set&lt;Function&gt;([Set, Map, WeakMap, WeakSet])</span><br></pre></td></tr></table></figure>

<p>然后是判断 key 是否存在的函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#</span></span><br><span class="line"> <span class="comment"># Make a map and return a function for checking if a key</span></span><br><span class="line"> <span class="comment"># is in that map.</span></span><br><span class="line"> <span class="comment"># IMPORTANT: all calls of this function must be prefixed with</span></span><br><span class="line"> <span class="comment"># \/\*#\_\_PURE\_\_\*\/</span></span><br><span class="line"> <span class="comment"># So that rollup can tree-shake them if necessary.</span></span><br><span class="line"> <span class="comment">#</span></span><br><span class="line"> <span class="comment"># 这个方法是干嘛用的注释写的很清楚了，很显然这是一个闭包，返回的函数是用来判断# key是否存在map中,在调用方法时要在前片加例子中的pure 让rollup能够tree-shake</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> makeMap(</span><br><span class="line">  str: string,</span><br><span class="line">  expectsLowerCase?: boolean</span><br><span class="line">): (key: string) =&gt; boolean &#123;</span><br><span class="line">  const map: Record&lt;string, boolean&gt; = Object.create(null)</span><br><span class="line">  const list: Array&lt;string&gt; = str.split(<span class="string">','</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    map[list[i]] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> expectsLowerCase ? val =&gt; !!map[val.toLowerCase()] : val =&gt; !!map[val]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isObservableType = /*<span class="comment">#__PURE__*/ makeMap(</span></span><br><span class="line">  <span class="string">'Object,Array,Map,Set,WeakMap,WeakSet'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 判断value是否能被代理</span></span><br><span class="line">const canObserve = (value: Target): boolean =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    !value[ReactiveFlags.SKIP] &amp;&amp;</span><br><span class="line">    isObservableType(toRawType(value)) &amp;&amp;</span><br><span class="line">    !Object.isFrozen(value)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## only unwrap nested ref,用来给嵌套的ref解套</span></span><br><span class="line"><span class="built_in">type</span> UnwrapNestedRefs&lt;T&gt; = T extends Ref ? T : UnwrapRef&lt;T&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 函数定义</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> reactive(target: object) &#123;</span><br><span class="line">  <span class="comment">## if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">## 如果传进来的数据是只读的，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) &#123;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">## 否则就创建响应式对象</span></span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者的注释都写的很明白了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只有在属性中不带skip并且类型属于'Object,Array,Map,Set,WeakMap,WeakSet'并且属性没有被冻结的对象才能够被代理</span></span><br><span class="line">const canObserve = (value: Target): boolean =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    !value[ReactiveFlags.SKIP] &amp;&amp;</span><br><span class="line">    isObservableType(toRawType(value)) &amp;&amp;</span><br><span class="line">    !Object.isFrozen(value)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty</span><br><span class="line"><span class="built_in">export</span> const hasOwn = (</span><br><span class="line">  val: object,</span><br><span class="line">  key: string | symbol</span><br><span class="line">): key is keyof typeof val =&gt; hasOwnProperty.call(val, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createReactiveObject(</span><br><span class="line">  target: Target,</span><br><span class="line">  isReadonly: boolean,</span><br><span class="line">  baseHandlers: ProxyHandler&lt;any&gt;,</span><br><span class="line">  collectionHandlers: ProxyHandler&lt;any&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      console.warn(`value cannot be made reactive: <span class="variable">$&#123;String(target)&#125;</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># target is already a Proxy, return it.</span></span><br><span class="line">  <span class="comment"># exception: calling readonly() on a reactive object</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># target already has corresponding Proxy</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    hasOwn(target, isReadonly ? ReactiveFlags.READONLY : ReactiveFlags.REACTIVE)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> isReadonly</span><br><span class="line">      ? target[ReactiveFlags.READONLY]</span><br><span class="line">      : target[ReactiveFlags.REACTIVE]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># only a whitelist of value types can be observed.</span></span><br><span class="line">  <span class="keyword">if</span> (!canObserve(target)) &#123;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  const observed = new Proxy(</span><br><span class="line">    target,</span><br><span class="line">    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  def(</span><br><span class="line">    target,</span><br><span class="line">    isReadonly ? ReactiveFlags.READONLY : ReactiveFlags.REACTIVE,</span><br><span class="line">    observed</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># def函数，显然是在obj定义一个可编写不可枚举的key,将target的响应式对象储存在自身的属性上，这样可以解决自己嵌套自己的无限循环（禁止套娃）</span></span><br><span class="line"><span class="built_in">export</span> const def = (obj: object, key: string | symbol, value: any) =&gt; &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里要说明为什么对 target 执行代理的时候 handler 要根据 target 的 contstructor 来调用不同的 handler，拿 Map 举例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const map = new Map()</span><br><span class="line">const proxy = new Proxy(map,&#123;&#125;)</span><br><span class="line">proxy.set(1,1)</span><br></pre></td></tr></table></figure>

<p>一执行肯定就报错<code>Uncaught TypeError: Method Map.prototype.set called on incompatible receiver [object Object]</code>,提示信息告诉我们代码可以变成这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">var proxy = new Proxy(map, &#123;&#125;);</span><br><span class="line">Map.prototype.set.call(proxy, 1, 1);</span><br></pre></td></tr></table></figure>

<p>所以这段代码<code>Map.prototype.set.call(proxy, 1, 1);</code>为什么这个报错，就是这个问题的核心</p>
<p>那首先，Map 这个呢把数据储存在自己的私有内部插槽中，类型[MapData]这样，然后这个插槽是跟 Map 对象自身绑定的。而 Proxy 不能完全模仿这样的行为，巧的是，这样的插槽 Proxy 学不来，所以在给它们做代理的时候把调用的实例重新指向 Map 这类结构的实例再进行调用实例方法就行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const PRIVATE = new WeakMap();</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">PRIVATE.set(obj, <span class="string">"private stuff"</span>);</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(obj, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">PRIVATE.get(proxy) === undefined // <span class="literal">true</span></span><br><span class="line">PRIVATE.get(obj) === <span class="string">"private stuff"</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>所以在上面创建响应式对象的时候要根据 target 的类型是判断用哪个的 handler</p>
<p>之前的枚举类型中有定义了<code>IS_REACTIVE</code>和<code>IS_READONLY</code>，就是用来判断<code>isReactive</code>和<code>isReadonly</code>，由于创建只读对象的<code>readonly</code>方法和创建响应式对象的<code>reactive</code>都是通过<code>createReactiveObject</code>方法来进行调用的，所以可以通过判断响应式或者只读属性来判断是否是被代理过的对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isReactive(value: unknown): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (isReadonly(value)) &#123;</span><br><span class="line">    <span class="built_in">return</span> isReactive((value as Target)[ReactiveFlags.RAW])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isReadonly(value: unknown): boolean &#123;</span><br><span class="line">  <span class="built_in">return</span> !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_READONLY])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isProxy(value: unknown): boolean &#123;</span><br><span class="line">  <span class="built_in">return</span> isReactive(value) || isReadonly(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 获取原始数据</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(observed: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    (observed &amp;&amp; toRaw((observed as Target)[ReactiveFlags.RAW])) || observed</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 这个方法就是不让value值被代理，之前的canObserve中有对SKIP的判断</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> markRaw&lt;T extends object&gt;(value: T): T &#123;</span><br><span class="line">  def(value, ReactiveFlags.SKIP, <span class="literal">true</span>)</span><br><span class="line">  <span class="built_in">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>toRaw</code>这个方法我曾经把它改成这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(observed: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">       observed ? toRaw((observed as Target)[ReactiveFlags.RAW]) : observed</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后跑了单测，发现所有有关 toRaw 的测试用例都报错，我靠.然后写了个小 demo 跑了一下，上面这个代码在进入倒数第二个调用栈的时候，observed 是 truthy，然后进入最后一个调用栈的时候是返回 undefined 的，然后返回倒数第二个调用栈的时候还是 undefined，这样一直到第一个栈返回的结果一直都是 undefined.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(observed: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    (observed &amp;&amp; toRaw((observed as Target)[ReactiveFlags.RAW])) || observed</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码的时候，同样的进入最后一个调用栈的时候返回的是 undefined，但是返回倒数第二个调用栈的时候 <code>observed &amp;&amp; undefined</code>是 fasly 值，所以倒数第二个调用栈返回的是一个具体的值<code>observed</code>,有、东西，智商捉急了。</p>
<p>然后还剩几个方法,这个不用说，很明显是设置只读对象，handler 也是有所区别的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">readonly</span>&lt;T extends object&gt;(</span><br><span class="line">  target: T</span><br><span class="line">): Readonly&lt;UnwrapNestedRefs&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    readonlyHandlers,</span><br><span class="line">    readonlyCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝，只有第一层的数据才是响应式</span></span><br><span class="line"><span class="comment"># Return a reactive-copy of the original object, where only the root level</span></span><br><span class="line"><span class="comment"># properties are reactive, and does NOT unwrap refs nor recursively convert</span></span><br><span class="line"><span class="comment"># returned properties.</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> shallowReactive&lt;T extends object&gt;(target: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    shallowReactiveHandlers,</span><br><span class="line">    shallowCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浅只读，不会对ref解套</span></span><br><span class="line"><span class="comment"># Return a reactive-copy of the original object, where only the root level</span></span><br><span class="line"><span class="comment"># properties are readonly, and does NOT unwrap refs nor recursively convert</span></span><br><span class="line"><span class="comment"># returned properties.</span></span><br><span class="line"><span class="comment"># This is used for creating the props proxy object for stateful components.</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> shallowReadonly&lt;T extends object&gt;(</span><br><span class="line">  target: T</span><br><span class="line">): Readonly&lt;&#123; [K <span class="keyword">in</span> keyof T]: UnwrapNestedRefs&lt;T[K]&gt; &#125;&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    shallowReadonlyHandlers,</span><br><span class="line">    readonlyCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h4><br>
<br>
导入方法
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import &#123; reactive, <span class="built_in">readonly</span>, toRaw, ReactiveFlags &#125; from <span class="string">'./reactive'</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line">import &#123; track, trigger, ITERATE_KEY &#125; from <span class="string">'./effect'</span></span><br><span class="line">import &#123;</span><br><span class="line">  isObject,</span><br><span class="line">  hasOwn,</span><br><span class="line">  isSymbol,</span><br><span class="line">  hasChanged,</span><br><span class="line">  isArray,</span><br><span class="line">  extend</span><br><span class="line">&#125; from <span class="string">'@vue/shared'</span></span><br><span class="line">import &#123; isRef &#125; from <span class="string">'./ref'</span></span><br></pre></td></tr></table></figure>

<p>获取Symbol的属性名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const builtInSymbols = new Set(</span><br><span class="line">  Object.getOwnPropertyNames(Symbol)</span><br><span class="line">    .map(key =&gt; (Symbol as any)[key])</span><br><span class="line">    .filter(isSymbol)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>看名字就知道干嘛的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const get = /*<span class="comment">#__PURE__*/ createGetter()</span></span><br><span class="line">const shallowGet = /*<span class="comment">#__PURE__*/ createGetter(false, true)</span></span><br><span class="line">const readonlyGet = /*<span class="comment">#__PURE__*/ createGetter(true)</span></span><br><span class="line">const shallowReadonlyGet = /*<span class="comment">#__PURE__*/ createGetter(true, true)</span></span><br></pre></td></tr></table></figure>

<p>对数组的这三个方法插桩，看的时候有个问题，为什么有个条件分支是<code>res === -1 || res === false</code>的时候继续执行，什么情况下会进入这个分支？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const arrayInstrumentations: Record&lt;string, Function&gt; = &#123;&#125;</span><br><span class="line">;[<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>].forEach(key =&gt; &#123;</span><br><span class="line">  arrayInstrumentations[key] = <span class="keyword">function</span>(...args: any[]): any &#123;</span><br><span class="line">    const arr = toRaw(this) as any</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0, l = (this as any).length; i &lt; l; i++) &#123;</span><br><span class="line">      track(arr, TrackOpTypes.GET, i + <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">## we run the method using the original args first (which may be reactive)</span></span><br><span class="line">    <span class="comment">## console.log(key,...args)</span></span><br><span class="line">    const res = arr[key](...args)</span><br><span class="line">    <span class="keyword">if</span> (res === -1 || res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">## if that didn't work, run it again using raw values.</span></span><br><span class="line">      <span class="built_in">return</span> arr[key](...args.map(toRaw))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">## return res</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>把 if 的条件分支注释，只留下<code>return res</code>这个分支，然后跑单测，发现 reactiveArray.spec.ts 这个测试文件的测试用例<code>× Array identity methods should work with raw values (16 ms)</code>测试不通过。发现是在这里的时候不能测试通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const raw = &#123;&#125;</span><br><span class="line">const arr = reactive([&#123;&#125;, &#123;&#125;])</span><br><span class="line">arr.push(raw)</span><br><span class="line"><span class="comment">## 省略其他代码</span></span><br><span class="line"><span class="comment"># should work also for the observed version</span></span><br><span class="line">const observed = arr[2]</span><br><span class="line">expect(arr.indexOf(observed)).toBe(2)</span><br></pre></td></tr></table></figure>

<p>然后将测试不通过代码拷贝到 vite 的 app 中进行调试，发现是 observed 这个值不再是跟 raw 一样的{},猜测是劫持了数组的 get 方法并且对返回值进行了修改。然后进入到<code>createGetter</code>这个方法，其中有个逻辑,如果参数是对象，那么就要转成响应式对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">    <span class="comment"># Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">    <span class="comment"># here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">    <span class="comment"># and reactive here to avoid circular dependency.</span></span><br><span class="line">    <span class="built_in">return</span> isReadonly ? <span class="built_in">readonly</span>(res) : reactive(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，<code>typeof {} === &#39;object&#39;</code>，所以这个时候的 observed 不再是单纯的<code>{}</code>，它是一个响应式的<code>{}</code>，所以就能解释为什么在<code>res === -1 || res === false</code>的时候还要进行次函数执行的过程，这是为了防止获取到的值是经过转换的值，所以在分支里面的参数要对参数进行一次还原，SKR。</p>
<p>下面这个就是劫持了 get 的方法，一条条逻辑看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createGetter(isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> get(target: object, key: string | symbol, receiver: object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="built_in">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      <span class="built_in">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? (target as any)[ReactiveFlags.READONLY]</span><br><span class="line">          : (target as any)[ReactiveFlags.REACTIVE])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const targetIsArray = isArray(target)</span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="built_in">return</span> Reflect.get(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const res = Reflect.get(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isSymbol(key)</span><br><span class="line">        ? builtInSymbols.has(key)</span><br><span class="line">        : key === `__proto__` || key === `__v_isRef`</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRef(res)) &#123;</span><br><span class="line">      <span class="comment"># ref unwrapping, only for Objects, not for Arrays</span></span><br><span class="line">      <span class="comment"># 对于ref的解套，仅仅针对object，不针对数组.</span></span><br><span class="line">      <span class="built_in">return</span> targetIsArray ? res : res.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment"># Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment"># here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment"># and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="built_in">return</span> isReadonly ? <span class="built_in">readonly</span>(res) : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看这个,老样子，先注释，跑单测，看结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="built_in">return</span> !isReadonly</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:<br><img src="/images/reactive/code3.png" alt="code3"><br>可以看到是<code>reactivity/reactive/Array › should make Array reactive</code>这个测试用例中的某个用例出现了问题，来看具体问题代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const observed = reactive(original)</span><br><span class="line">expect(observed).not.toBe(original)</span><br><span class="line"><span class="comment"># 下面这段是问题代码</span></span><br><span class="line">expect(isReactive(observed)).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>看<code>isReactive</code>方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isReactive(value: unknown): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (isReadonly(value)) &#123;</span><br><span class="line">    <span class="built_in">return</span> isReactive((value as Target)[ReactiveFlags.RAW])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那现在可以看出，是在数组访问<code>ReactiveFlags.IS_REACTIVE</code>这个 key 的时候被劫持了，然后进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      return !isReadonly</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个逻辑，至于为什么返回结果要对<code>isReadonly</code>取反，很显然，在<code>createReactiveObject</code>的时候 reactive 和 readonly 是互斥的关系，那么一个对象不是只读很显然就是响应式,那如果是原始对象呢？很显然，原始对象没有<code>__v_isReactive</code>这个属性，那么会返回 undefined，用!!转义就是 false；然后<code>key === ReactiveFlags.IS_READONLY</code>这个分支的逻辑就跟<code>REACTIVE</code>的逻辑一样的。</p>
<p>然后我把第三个分支给注释，WDM，直接爆栈了。。。<br><br><br><code>RangeError: Maximum call stack size exceeded at Object.get (&lt;anonymous&gt;)</code><br>四个测试用例没通过，我选了其中一个测试用例来复现<code>Array identity methods should work with raw values</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> const raw = &#123;&#125;</span><br><span class="line"> const arr = reactive([&#123;&#125;, &#123;&#125;])</span><br><span class="line"> arr.push(raw)</span><br><span class="line">console.log(arr.indexOf(raw))</span><br></pre></td></tr></table></figure>

<p>然后跟着代码走，先进入 indexOf 的这个方法，这个方法是被劫持的,走到这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>].forEach(key =&gt; &#123;</span><br><span class="line">    arrayInstrumentations[key] = <span class="keyword">function</span> (...args) &#123;</span><br><span class="line">        <span class="comment"># 1 这里需要获取当前数组的原始数据,然后会在this中访问__v_raw属性，接着就进入劫持的get方法</span></span><br><span class="line">        const arr = toRaw(this);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> i = 0, l = this.length; i &lt; l; i++) &#123;</span><br><span class="line">            track(arr, <span class="string">"get"</span> /* GET */, i + <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># we run the method using the original args first (which may be reactive)</span></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        const res = arr[key](...args);</span><br><span class="line">        <span class="keyword">if</span> (res === -1 || res === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment"># if that didn't work, run it again using raw values.</span></span><br><span class="line">            <span class="built_in">return</span> arr[key](...args.map(toRaw));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当1执行的时候，跳到get的时候此时的key是__v_raw</span></span><br><span class="line"><span class="comment"># 这里截取get方法的一部分，第三个分支被我删去，此时不会直接return，而是继续往下执行，此时</span></span><br><span class="line"><span class="comment"># 的return res是undefined,然后在返回toRaw方法的时候直接看第一层调用栈observed&amp;&amp;undefinde||observed,很明显这时候的arr返回的是observed，因此此时的arr并不是原始数据，当执行到2处时，又一次进入get方# 法，此时的key是indexOf，然后此时会返回 return Reflect.get(arrayInstrumentations, # key, receiver);而arrayInstrumentations['indexOf']这个方法又进入了1这个过程，从而造# 成调用栈爆栈的问题</span></span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">"__v_isReactive"</span> /* IS_REACTIVE */) &#123;</span><br><span class="line">        <span class="built_in">return</span> !isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"__v_isReadonly"</span> /* IS_READONLY */) &#123;</span><br><span class="line">        <span class="built_in">return</span> isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line">    const targetIsArray = isArray(target);</span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">        <span class="built_in">return</span> Reflect.get(arrayInstrumentations, key, receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个 Symbol 的判断逻辑一直没有理解，我 TM</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    isSymbol(key)</span><br><span class="line">      ? builtInSymbols.has(key)</span><br><span class="line">      : key === `__proto__` || key === `__v_isRef`</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我在单测里面执行测试用例的自定义 Symbol 访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const customSymbol = Symbol()</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.asyncIterator]: &#123; a: 1 &#125;,</span><br><span class="line">  [Symbol.unscopables]: &#123; b: <span class="string">'1'</span> &#125;,</span><br><span class="line">  [customSymbol]: &#123; c: [1, 2, 3] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const objRef = ref(obj)</span><br><span class="line">expect(objRef.value[Symbol.asyncIterator]).toBe(obj[Symbol.asyncIterator])</span><br><span class="line">expect(objRef.value[Symbol.unscopables]).toBe(obj[Symbol.unscopables])</span><br><span class="line"><span class="comment"># 这两句log语句都是输出 &#123; c: [ 1, 2, 3 ] &#125;原始数据</span></span><br><span class="line">console.log(objRef.value[customSymbol])</span><br><span class="line">console.log(obj[customSymbol])</span><br></pre></td></tr></table></figure>

<p>然后我在 demo 里面也复制了这段代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const customSymbol = Symbol()</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.asyncIterator]: &#123; a: 1 &#125;,</span><br><span class="line">  [Symbol.unscopables]: &#123; b: <span class="string">'1'</span> &#125;,</span><br><span class="line">  [customSymbol]: &#123; c: [1, 2, 3] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debugger</span><br><span class="line">const objRef = ref(obj)</span><br><span class="line"><span class="comment"># 结果下面两个log 一个输出 代理过的Object，一个输出Objectt原始数据</span></span><br><span class="line">console.log(objRef.value[customSymbol])</span><br><span class="line">console.log(obj[customSymbol])</span><br></pre></td></tr></table></figure>

<p>我就先不管它了。</p>
<p>然后是<code>createSetter</code>,是 set 方法的插桩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createSetter(shallow = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="built_in">set</span>(</span><br><span class="line">    target: object,</span><br><span class="line">    key: string | symbol,</span><br><span class="line">    value: unknown,</span><br><span class="line">    receiver: object</span><br><span class="line">  ): boolean &#123;</span><br><span class="line">    const oldValue = (target as any)[key]</span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      value = toRaw(value)</span><br><span class="line">      <span class="comment"># 这里就是判断赋值的时候新值如果不是ref，并且旧值是ref的情况下的赋值</span></span><br><span class="line">      <span class="comment"># 这里有个条件是判断当前target是非数组，但是当我把这个条件删除的时候，210个测试用例仍然测试通过，所以这个条件不知道是干啥的。</span></span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        oldValue.value = value</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const hadKey = hasOwn(target, key)</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment"># don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="comment"># 这个等于是在什么情况下发生的，把里面的逻辑拿出来，找到没有通过的测试用例，发现就一个，是在effect模块，emm先记录，等读到的时候再看---effect-settter</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="comment"># 这里就是判断要set的key是否存在target上，如果不存在，就触发添加数据的依赖，如果存在，就触发更新数据的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># Reflect要返回boolean来判断是否设置成功</span></span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># hasChange方法用来判断值是否有所改变，&amp;&amp;后面的判断语句是用来过滤NaN的，因为NaN是唯一一个自身不相等的数</span></span><br><span class="line"><span class="built_in">export</span> const hasChanged = (value: any, oldValue: any): boolean =&gt;</span><br><span class="line">  value !== oldValue &amp;&amp; (value === value || oldValue === oldValue)</span><br></pre></td></tr></table></figure>

<p>附一张疑问图<br><img src="/images/reactive/code5.png" alt="confused"><br><img src="/images/reactive/code6.png" alt="confused"><br>剩下几个的逻辑就很单一了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除逻辑 删除成功并且在target有这个key存在然后触发更新</span></span><br><span class="line"><span class="keyword">function</span> deleteProperty(target: object, key: string | symbol): boolean &#123;</span><br><span class="line">  const hadKey = hasOwn(target, key)</span><br><span class="line">  const oldValue = (target as any)[key]</span><br><span class="line">  const result = Reflect.deleteProperty(target, key)</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 静态方法 Reflect.has() 作用与 in 操作符 相同。</span></span><br><span class="line"><span class="keyword">function</span> has(target: object, key: string | symbol): boolean &#123;</span><br><span class="line">  const result = Reflect.has(target, key)</span><br><span class="line">  track(target, TrackOpTypes.HAS, key)</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。不包括原型链喔</span></span><br><span class="line"><span class="keyword">function</span> ownKeys(target: object): (string | number | symbol)[] &#123;</span><br><span class="line">  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)</span><br><span class="line">  <span class="built_in">return</span> Reflect.ownKeys(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 baseHandlers 剩下的代码就是一些 handler 了，没有逻辑</p>
<h4 id="collectionHandler"><a href="#collectionHandler" class="headerlink" title="collectionHandler"></a>collectionHandler</h4><p>导入文件，类型声明，以及一些方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import &#123; toRaw, reactive, <span class="built_in">readonly</span>, ReactiveFlags &#125; from <span class="string">'./reactive'</span></span><br><span class="line">import &#123; track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY &#125; from <span class="string">'./effect'</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line">import &#123;</span><br><span class="line">  isObject,</span><br><span class="line">  capitalize,</span><br><span class="line">  hasOwn,</span><br><span class="line">  hasChanged,</span><br><span class="line">  toRawType</span><br><span class="line">&#125; from <span class="string">'@vue/shared'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> CollectionTypes = IterableCollections | WeakCollections</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> IterableCollections = Map&lt;any, any&gt; | Set&lt;any&gt;</span><br><span class="line"><span class="built_in">type</span> WeakCollections = WeakMap&lt;any, any&gt; | WeakSet&lt;any&gt;</span><br><span class="line"><span class="built_in">type</span> MapTypes = Map&lt;any, any&gt; | WeakMap&lt;any, any&gt;</span><br><span class="line"><span class="built_in">type</span> SetTypes = Set&lt;any&gt; | WeakSet&lt;any&gt;</span><br><span class="line"></span><br><span class="line">const toReactive = &lt;T extends unknown&gt;(value: T): T =&gt;</span><br><span class="line">  isObject(value) ? reactive(value) : value</span><br><span class="line"></span><br><span class="line">const toReadonly = &lt;T extends unknown&gt;(value: T): T =&gt;</span><br><span class="line">  isObject(value) ? <span class="built_in">readonly</span>(value) : value</span><br><span class="line"></span><br><span class="line">const toShallow = &lt;T extends unknown&gt;(value: T): T =&gt; value</span><br><span class="line"></span><br><span class="line">const getProto = &lt;T extends CollectionTypes&gt;(v: T): any =&gt;</span><br><span class="line">  Reflect.getPrototypeOf(v)</span><br></pre></td></tr></table></figure>

<p>看 get 方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> get(</span><br><span class="line">  target: MapTypes,</span><br><span class="line">  key: unknown,</span><br><span class="line">  wrap: typeof toReactive | typeof toReadonly | typeof toShallow</span><br><span class="line">) &#123;</span><br><span class="line">  target = toRaw(target)</span><br><span class="line">  const rawKey = toRaw(key)</span><br><span class="line">  <span class="comment"># 这里的key不等于rawKey的话那么必然是这个key是响应式对象</span></span><br><span class="line">  <span class="comment"># 然后这里track应该是收集依赖，具体逻辑不知道，先这样看</span></span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    track(target, TrackOpTypes.GET, key)</span><br><span class="line">  &#125;</span><br><span class="line">  track(target, TrackOpTypes.GET, rawKey)</span><br><span class="line">  const &#123; has, get &#125; = getProto(target)</span><br><span class="line">  <span class="comment"># 判断是key在target上还是rawKey在target上，wrap是属于toReactive|toReadonly|toShallow三个函数中的其中一个，if里面是在组合调用函数</span></span><br><span class="line">  <span class="keyword">if</span> (has.call(target, key)) &#123;</span><br><span class="line">    <span class="built_in">return</span> wrap(get.call(target, key))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.call(target, rawKey)) &#123;</span><br><span class="line">    <span class="built_in">return</span> wrap(get.call(target, rawKey))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>啊，然后看 set 方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>(this: MapTypes, key: unknown, value: unknown) &#123;</span><br><span class="line">  value = toRaw(value)</span><br><span class="line">  <span class="comment"># 这里肯定要把this转成原生数据类型，而不能用Proxy，原因之前有讲了，这里的has调用绑定到了代理之前的数据实例</span></span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const &#123; has, get, <span class="built_in">set</span> &#125; = getProto(target)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> hadKey = has.call(target, key)</span><br><span class="line">  <span class="comment">## 这个是我自己改的，果然 ，测试用例没通过，调了下，果然还是得用实例自带的方法来判断，用Object.prototype.hasOwnProperty还是不能用来对Map这类结构进行判断的</span></span><br><span class="line">  <span class="comment">## let hadKey = hasOwn(target,key as any)</span></span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    <span class="comment"># 这个逻辑跟之前的对数组的indexOf插桩的方法一个道理，都是考虑了key值为响应式对象的情况</span></span><br><span class="line">    key = toRaw(key)</span><br><span class="line">    hadKey = has.call(target, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    checkIdentityKeys(target, has, key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldValue = get.call(target, key)</span><br><span class="line">  const result = set.call(target, key, value)</span><br><span class="line">  <span class="comment"># 更新依赖----&gt;要么add要么set</span></span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>has 和 add 方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> has(this: CollectionTypes, key: unknown): boolean &#123;</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const rawKey = toRaw(key)</span><br><span class="line">  <span class="comment"># 响应对象</span></span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    track(target, TrackOpTypes.HAS, key)</span><br><span class="line">  &#125;</span><br><span class="line">  track(target, TrackOpTypes.HAS, rawKey)</span><br><span class="line">  const has = getProto(target).has</span><br><span class="line">  <span class="comment"># 这里用到了或运算符考虑到了Set里面放置了响应式对象的情况</span></span><br><span class="line">  <span class="comment"># 所以单独只使用一个判断的话测试用例是不能全部通过的</span></span><br><span class="line">  <span class="built_in">return</span> has.call(target, key) || has.call(target, rawKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个方法 就 嗯  一目了然</span></span><br><span class="line"><span class="keyword">function</span> add(this: SetTypes, value: unknown) &#123;</span><br><span class="line">  <span class="comment"># 可能会有疑问，这里的添加不是把value都做了一个转换吗？为什么Set里面会有响应式对象？</span></span><br><span class="line">  <span class="comment"># 这个方法只是劫持了Set方法的add，所以只有Set转变成响应式对象后调用了add方法，加入进去的value才只是普通的value值</span></span><br><span class="line">  value = toRaw(value)</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const proto = getProto(target)</span><br><span class="line">  const hadKey = proto.has.call(target, value)</span><br><span class="line">  const result = proto.add.call(target, value)</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.ADD, value, value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码，在 set 转为响应式对象前后分别把响应式对象 entry 加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const raw = new Set();</span><br><span class="line">const entry = reactive(&#123;&#125;);</span><br><span class="line">raw.add(entry);</span><br><span class="line">const <span class="built_in">set</span> = reactive(raw);</span><br><span class="line">// console.log(set.has(entry));</span><br><span class="line">set.add(entry)</span><br></pre></td></tr></table></figure>

<p>看 log 结果<br><img src="/images/reactive/code7.png" alt="code7"></p>
<p>从图里可以很明显的看出 添加了两个相同的对象，但是一个是原始值，一个是代理对象，说明之前那个问题，Set 结构里面是可以有代理对象的，只要在 Set 被 reactive 之前加入就行，在被 reactive 之后添加的数据就只是原始数据，而不是代理对象了，这里的原始数据指的是没有被 Proxy</p>
<p>deleteEntry 跟 set 逻辑有点相似,区别就在于调用的方法不一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> deleteEntry(this: CollectionTypes, key: unknown) &#123;</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const &#123; has, get, delete: del &#125; = getProto(target)</span><br><span class="line">  <span class="built_in">let</span> hadKey = has.call(target, key)</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    key = toRaw(key)</span><br><span class="line">    hadKey = has.call(target, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    checkIdentityKeys(target, has, key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldValue = get ? get.call(target, key) : undefined</span><br><span class="line">  <span class="comment"># forward the operation before queueing reactions</span></span><br><span class="line">  const result = del.call(target, key)</span><br><span class="line">  <span class="keyword">if</span> (hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear 方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> clear(this: IterableCollections) &#123;</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const hadItems = target.size !== 0</span><br><span class="line">  const oldTarget = __DEV__</span><br><span class="line">    ? target instanceof Map</span><br><span class="line">      ? new Map(target)</span><br><span class="line">      : new Set(target)</span><br><span class="line">    : undefined</span><br><span class="line">  <span class="comment"># forward the operation before queueing reactions</span></span><br><span class="line">  const result = getProto(target).clear.call(target)</span><br><span class="line">  <span class="comment"># 告诉有收集这个target的对象们可以把它的值置空了</span></span><br><span class="line">  <span class="keyword">if</span> (hadItems) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unction createForEach(isReadonly: boolean, shallow: boolean) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> forEach(</span><br><span class="line">    this: IterableCollections,</span><br><span class="line">    callback: Function,</span><br><span class="line">    <span class="comment"># 以为这个参数没有用，注释掉跑了下测试，只有一个用例报错，断言写的是callback内部的this等于thisArg</span></span><br><span class="line">    thisArg?: unknown</span><br><span class="line">  ) &#123;</span><br><span class="line">    const observed = this</span><br><span class="line">    <span class="comment"># 本来以为这里的observed算是重复变量，</span></span><br><span class="line">    <span class="comment"># 所以下一行可以改成</span></span><br><span class="line">    <span class="comment"># const target = toRaw(this)</span></span><br><span class="line">    <span class="comment"># 但是注意到wrappedCallback这个函数也用到了，取得是外层作用域的this，因此需要一个储存this的临时变量</span></span><br><span class="line">    const target = toRaw(observed)</span><br><span class="line">    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive</span><br><span class="line">    !isReadonly &amp;&amp; track(target, TrackOpTypes.ITERATE, ITERATE_KEY)</span><br><span class="line">    <span class="comment"># important: create sure the callback is</span></span><br><span class="line">    <span class="comment"># 1. invoked with the reactive map as `this` and 3rd arg</span></span><br><span class="line">    <span class="comment"># 2. the value received should be a corresponding reactive/readonly.</span></span><br><span class="line">    <span class="keyword">function</span> wrappedCallback(value: unknown, key: unknown) &#123;</span><br><span class="line">      <span class="built_in">return</span> callback.call(thisArg, wrap(value), wrap(key), observed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 这句我一开始以为是遍历原型链上所有的属性以及方法并且进行this重定向，后来我对这句进行了一次debug，我发现下面这句应该是等同于</span></span><br><span class="line">    <span class="comment"># return getProto(target)['forEach'].call(target,wrappedCallback)</span></span><br><span class="line">    <span class="comment"># 我觉得这样写应该更容易理解吧～</span></span><br><span class="line">    <span class="built_in">return</span> getProto(target).forEach.call(target, wrappedCallback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对迭代方法进行一个插桩，返回闭包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createIterableMethod(</span><br><span class="line">  method: string | symbol,</span><br><span class="line">  isReadonly: boolean,</span><br><span class="line">  shallow: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(</span><br><span class="line">    this: IterableCollections,</span><br><span class="line">    ...args: unknown[]</span><br><span class="line">  ): Iterable &amp; Iterator &#123;</span><br><span class="line">    const target = toRaw(this)<span class="comment">#获取原始数据</span></span><br><span class="line">    const isMap = target instanceof Map</span><br><span class="line">    const isPair = method === <span class="string">'entries'</span> || (method === Symbol.iterator &amp;&amp; isMap)</span><br><span class="line">    const isKeyOnly = method === <span class="string">'keys'</span> &amp;&amp; isMap</span><br><span class="line">    <span class="comment"># 考虑这里对apply可以用call来调用吗？</span></span><br><span class="line">    <span class="comment"># 但是是不行，因为这里的arg是一个数组，而call的参数需要是一个参数或者多个参数，就是说call的参数只能是一个个的传！</span></span><br><span class="line">    <span class="comment"># 并且这里的innerIterator返回的并不是一个array，而是一个iterator</span></span><br><span class="line">    const innerIterator = getProto(target)[method].apply(target, args)</span><br><span class="line">    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive</span><br><span class="line">    !isReadonly &amp;&amp;</span><br><span class="line">      track(</span><br><span class="line">        target,</span><br><span class="line">        TrackOpTypes.ITERATE,</span><br><span class="line">        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY</span><br><span class="line">      )</span><br><span class="line">    <span class="comment"># return a wrapped iterator which returns observed versions of the</span></span><br><span class="line">    <span class="comment"># values emitted from the real iterator</span></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      <span class="comment"># iterator protocol</span></span><br><span class="line">      <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">        const &#123; value, <span class="keyword">done</span> &#125; = innerIterator.next()</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">done</span></span><br><span class="line">          ? &#123; value, <span class="keyword">done</span> &#125;</span><br><span class="line">          : &#123;</span><br><span class="line">              <span class="comment"># 只有在调用entries方法或者是Map类型对时候才需要返回【key，value】，并且让返回对数据保持响应式结构</span></span><br><span class="line">              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),</span><br><span class="line">              <span class="keyword">done</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment"># iterable protocol</span></span><br><span class="line">      <span class="comment"># mdn对于重写迭代器有提到需要返回自身，否则会发生意料之外对错误</span></span><br><span class="line">      [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="built_in">return</span> this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">之后的函数都是通过条件来调用之前的函数，就跳哟拉～</span><br><span class="line"></span><br><span class="line">待续...(reactive还没看完)</span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>跟 reactive 类似，同样也是让一个 value 值变成一个响应式对象，但是不同的是 reactive 只能让 object 变成响应式对象，却不包括 primitive 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 收集 触发依赖</span></span><br><span class="line">import &#123; track, trigger &#125; from <span class="string">'./effect'</span></span><br><span class="line"><span class="comment"># 枚举类型</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line"><span class="comment"># 通用方法</span></span><br><span class="line">import &#123; isObject, hasChanged &#125; from <span class="string">'@vue/shared'</span></span><br><span class="line">import &#123; reactive, isProxy, toRaw &#125; from <span class="string">'./reactive'</span></span><br><span class="line">import &#123; CollectionTypes &#125; from <span class="string">'./collectionHandlers'</span></span><br></pre></td></tr></table></figure>

<p>要定义一个独一无二的字段 Symbol 类型，并且不想让 ide 识别出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> const RefSymbol: unique symbol</span><br><span class="line"><span class="built_in">export</span> interface Ref&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">   <span class="comment">#Type differentiator only.</span></span><br><span class="line">   <span class="comment">#We need this to be in public d.ts but don't want it to show up in IDE</span></span><br><span class="line">   <span class="comment">#autocomplete, so we use a private Symbol instead.</span></span><br><span class="line">   <span class="comment">#</span></span><br><span class="line">  [RefSymbol]: <span class="literal">true</span></span><br><span class="line">  value: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toRefs 的类型声明，每个在 T 里面的值都是 ref 类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> ToRefs&lt;T = any&gt; = &#123; [K <span class="keyword">in</span> keyof T]: Ref&lt;T[K]&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>由于 reactive 仅接受 object 作为入参，所以对于 primitive 的值就返回它的值而不是调用 reactive</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const convert = &lt;T extends unknown&gt;(val: T): T =&gt;</span><br><span class="line">  isObject(val) ? reactive(val) : val</span><br></pre></td></tr></table></figure>

<p>ref 直接调用了<code>createRef</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> ref(value?: unknown) &#123;</span><br><span class="line">  <span class="built_in">return</span> createRef(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># createRef直接返回一个object，</span></span><br><span class="line"><span class="comment"># const count = ref(1)</span></span><br><span class="line"><span class="comment"># ==&gt;count = &#123;</span></span><br><span class="line"><span class="comment">#         __v_isRef:true,</span></span><br><span class="line"><span class="comment">#         value:1</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="keyword">function</span> createRef(rawValue: unknown, shallow = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="built_in">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> value = shallow ? rawValue : convert(rawValue)</span><br><span class="line">  const r = &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">      track(r, TrackOpTypes.GET, <span class="string">'value'</span>)</span><br><span class="line">      <span class="built_in">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> value(newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(toRaw(newVal), rawValue)) &#123;</span><br><span class="line">        rawValue = newVal</span><br><span class="line">        value = shallow ? newVal : convert(newVal)</span><br><span class="line">        trigger(</span><br><span class="line">          r,</span><br><span class="line">          TriggerOpTypes.SET,</span><br><span class="line">          <span class="string">'value'</span>,</span><br><span class="line">          __DEV__ ? &#123; newValue: newVal &#125; : void 0</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 reactive 只是针对于 object 的，对于内部的 prop 是没有做代理的，因此一旦解构，解构出来的值就已经失去了响应性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRefs&lt;T extends object&gt;(object: T): ToRefs&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isProxy(object)) &#123;</span><br><span class="line">    console.warn(`toRefs() expects a reactive object but received a plain one.`)</span><br><span class="line">  &#125;</span><br><span class="line">  const ret: any = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (const key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    ret[key] = toRef(object, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRef&lt;T extends object, K extends keyof T&gt;(</span><br><span class="line">  object: T,</span><br><span class="line">  key: K</span><br><span class="line">): Ref&lt;T[K]&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    get value(): any &#123;</span><br><span class="line">      <span class="built_in">return</span> object[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> value(newVal) &#123;</span><br><span class="line">      object[key] = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; as any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LIKE THIS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  const obj = reactive(&#123;count:10,age:10]&#125;)</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    ...obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const obj = f()</span><br><span class="line"><span class="built_in">let</span> &#123;count,age&#125; = obj</span><br><span class="line">count <span class="comment"># 10</span></span><br><span class="line">count++</span><br><span class="line">count <span class="comment"># 11</span></span><br><span class="line">obj.count <span class="comment">#10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  const obj = reactive(&#123;count:10,age:10]&#125;)</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    ...toRefs(obj)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const obj = f()</span><br><span class="line">const &#123;count&#125;  = obj <span class="comment"># 这样解构出来的count是一个ref类型，它具备有响应性</span></span><br><span class="line">count.value <span class="comment"># 10</span></span><br><span class="line">count.value++</span><br><span class="line">count.value <span class="comment">#11</span></span><br><span class="line">obj.count.value <span class="comment"># 11</span></span><br></pre></td></tr></table></figure>

<p>看看这个很长很长的类型声明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> interface RefUnwrapBailTypes &#123;&#125;</span><br><span class="line"><span class="comment"># 首先如果T是Ref类型的，那么把ref类型里面推断的数据类型作为类型传递给UnwrapRefSimple</span></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> UnwrapRef&lt;T&gt; = T extends Ref&lt;infer V&gt;</span><br><span class="line">  ? UnwrapRefSimple&lt;V&gt;</span><br><span class="line">  : UnwrapRefSimple&lt;T&gt;</span><br><span class="line"><span class="comment"># 然后UnwrapRefSimple根据传进来的类型来决定返回什么类型</span></span><br><span class="line"><span class="built_in">type</span> UnwrapRefSimple&lt;T&gt; = T extends</span><br><span class="line">  | Function</span><br><span class="line">  | CollectionTypes</span><br><span class="line">  | BaseTypes</span><br><span class="line">  | Ref</span><br><span class="line">  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]</span><br><span class="line">  ? T</span><br><span class="line">  : T extends Array&lt;any&gt;</span><br><span class="line">    ? &#123; [K <span class="keyword">in</span> keyof T]: UnwrapRefSimple&lt;T[K]&gt; &#125;</span><br><span class="line">    : T extends object ? UnwrappedObject&lt;T&gt; : T</span><br></pre></td></tr></table></figure>

<p>这里的 T[P]要用 UnwrapRef 嵌套应该是要考虑对象中有 ref 的情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> UnwrappedObject&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: UnwrapRef&lt;T[P]&gt; &#125; &amp; SymbolExtract&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两个枚举</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line"><span class="comment"># 两个工具方法</span></span><br><span class="line">import &#123; EMPTY_OBJ, isArray &#125; from <span class="string">'@vue/shared'</span></span><br></pre></td></tr></table></figure>

<p>储存依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The main WeakMap that stores &#123;target -&gt; key -&gt; dep&#125; connections.</span></span><br><span class="line"><span class="comment"># Conceptually, it's easier to think of a dependency as a Dep class</span></span><br><span class="line"><span class="comment"># which maintains a Set of subscribers, but we simply store them as</span></span><br><span class="line"><span class="comment"># raw Sets to reduce memory overhead.</span></span><br><span class="line"><span class="built_in">type</span> Dep = Set&lt;ReactiveEffect&gt;</span><br><span class="line"><span class="built_in">type</span> KeyToDepMap = Map&lt;any, Dep&gt;</span><br><span class="line">const targetMap = new WeakMap&lt;any, KeyToDepMap&gt;()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> interface ReactiveEffect&lt;T = any&gt; &#123;</span><br><span class="line">  (...args: any[]): T</span><br><span class="line">  _isEffect: <span class="literal">true</span></span><br><span class="line">  id: number</span><br><span class="line">  <span class="comment"># 是否停止监听</span></span><br><span class="line">  active: boolean</span><br><span class="line">  <span class="comment"># 原始函数</span></span><br><span class="line">  raw: () =&gt; T</span><br><span class="line">  <span class="comment"># 依赖数组</span></span><br><span class="line">  deps: Array&lt;Dep&gt;</span><br><span class="line">  <span class="comment"># 选项</span></span><br><span class="line">  options: ReactiveEffectOptions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> interface ReactiveEffectOptions &#123;</span><br><span class="line">  <span class="comment"># 判断是否立即执行</span></span><br><span class="line">  lazy?: boolean</span><br><span class="line">  computed?: boolean</span><br><span class="line">  scheduler?: (job: ReactiveEffect) =&gt; void</span><br><span class="line">  onTrack?: (event: DebuggerEvent) =&gt; void</span><br><span class="line">  onTrigger?: (event: DebuggerEvent) =&gt; void</span><br><span class="line">  onStop?: () =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> DebuggerEvent = &#123;</span><br><span class="line">  effect: ReactiveEffect</span><br><span class="line">  target: object</span><br><span class="line">  <span class="built_in">type</span>: TrackOpTypes | TriggerOpTypes</span><br><span class="line">  key: any</span><br><span class="line">&#125; &amp; DebuggerEventExtraInfo</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> interface DebuggerEventExtraInfo &#123;</span><br><span class="line">  newValue?: any</span><br><span class="line">  oldValue?: any</span><br><span class="line">  oldTarget?: Map&lt;any, any&gt; | Set&lt;any&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 储存effect的数组</span></span><br><span class="line">const effectStack: ReactiveEffect[] = []</span><br><span class="line"><span class="built_in">let</span> activeEffect: ReactiveEffect | undefined</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> const ITERATE_KEY = Symbol(__DEV__ ? <span class="string">'iterate'</span> : <span class="string">''</span>)</span><br><span class="line"><span class="built_in">export</span> const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? <span class="string">'Map key iterate'</span> : <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>判断是否是 effect 函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isEffect(fn: any): fn is ReactiveEffect &#123;</span><br><span class="line">  <span class="built_in">return</span> fn &amp;&amp; fn._isEffect === <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 effect 函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> effect&lt;T = any&gt;(</span><br><span class="line">  fn: () =&gt; T,</span><br><span class="line">  options: ReactiveEffectOptions = EMPTY_OBJ</span><br><span class="line">): ReactiveEffect&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  const effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="comment"># 如果没有lazy参数，那么effect 函数立即执行</span></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> uid = 0</span><br><span class="line"><span class="comment"># 删除effect里面的依赖的依赖的effect（很拗口）</span></span><br><span class="line"><span class="keyword">function</span> cleanup(effect: ReactiveEffect) &#123;</span><br><span class="line">  const &#123; deps &#125; = effect</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createReactiveEffect&lt;T = any&gt;(</span><br><span class="line">  fn: (...args: any[]) =&gt; T,</span><br><span class="line">  options: ReactiveEffectOptions</span><br><span class="line">): ReactiveEffect&lt;T&gt; &#123;</span><br><span class="line">  const effect = <span class="keyword">function</span> reactiveEffect(...args: unknown[]): unknown &#123;</span><br><span class="line">    <span class="comment"># 把这句注释，一个用例报错 reactivity/effect › stop with scheduler</span></span><br><span class="line">    <span class="comment"># 提示我们 在把effect调用了stop之后，scheduler不在执行</span></span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="built_in">return</span> options.scheduler ? undefined : fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 问个问题，if代码块里面的语句push了一次，然后pop了一次，那么为什么还需要判断effect是否存在effect栈中</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      <span class="comment"># 这里要删除effect的依赖项，是为了处理effect里面有条件语句的情况，</span></span><br><span class="line">      <span class="comment"># 分支不处于激活状态时，修改分支上的属性不应该执行effect</span></span><br><span class="line">      cleanup(effect)</span><br><span class="line">      try &#123;</span><br><span class="line">        enableTracking()</span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="built_in">return</span> fn(...args)</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - 1]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; as ReactiveEffect</span><br><span class="line">  effect.id = uid++</span><br><span class="line">  effect._isEffect = <span class="literal">true</span></span><br><span class="line">  effect.active = <span class="literal">true</span></span><br><span class="line">  effect.raw = fn</span><br><span class="line">  effect.deps = []</span><br><span class="line">  effect.options = options</span><br><span class="line">  <span class="built_in">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提个问题，在 effect 函数里面的 if 语句块里面执行了一次<code>effectStack.push</code>,然后又执行了<code>effectStack.pop</code>,但是为什么要在 if 语句里面判断 effect 是否存在 effectStack 中，所以我把这个 if 语句删除，这是为了防止套娃。在 effect 里面调用 effect 本身，避免无限递归（小声 bb，我只看懂了这层）</p>
<p>track 函数，这是为了收集依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> track(target: object, <span class="built_in">type</span>: TrackOpTypes, key: unknown) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === undefined) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = new Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = new Set()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 在收集依赖前执行了cleanup方法</span></span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="built_in">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> trigger(</span><br><span class="line">  target: object,</span><br><span class="line">  <span class="built_in">type</span>: TriggerOpTypes,</span><br><span class="line">  key?: unknown,</span><br><span class="line">  newValue?: unknown,</span><br><span class="line">  oldValue?: unknown,</span><br><span class="line">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  const depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    // never been tracked</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const effects = new Set&lt;ReactiveEffect&gt;()</span><br><span class="line">  const add = (effectsToAdd: Set&lt;ReactiveEffect&gt; | undefined) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(effect =&gt; &#123;</span><br><span class="line">      <span class="comment"># 判断是否需要收集依赖或者effect是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123;</span><br><span class="line">          effects.add(effect)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment"># the effect mutated its own dependency during its execution.</span></span><br><span class="line">          <span class="comment"># this can be caused by operations like foo.value++</span></span><br><span class="line">          <span class="comment"># do not trigger or we end in an infinite loop</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment"># collection being cleared</span></span><br><span class="line">    <span class="comment"># trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach((dep, key) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'length'</span> || key &gt;= (newValue as number)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== void 0) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#如果是增加或者删除数据的行为，还要再往相应队列中增加监听函数</span></span><br><span class="line">    <span class="comment"># also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    const isAddOrDelete =</span><br><span class="line">      <span class="built_in">type</span> === TriggerOpTypes.ADD ||</span><br><span class="line">      (<span class="built_in">type</span> === TriggerOpTypes.DELETE &amp;&amp; !isArray(target))</span><br><span class="line">    <span class="comment"># 这个逻辑需要什么时候走到，比如对数据进行push操作时，劫持的key其实是length，此时的key确实不是0，但是depsMap.get(0)其实是为空的</span></span><br><span class="line">    <span class="comment"># 而depsMap.get('length')才是真的有相应effect，所以需要补充第二个逻辑</span></span><br><span class="line">    <span class="comment"># 假如第一个逻辑和第二个逻辑都执行了，那还是只会执行一次effect的</span></span><br><span class="line">    <span class="comment"># 理由是add中的effects这是一个set结构，自动去重</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isAddOrDelete ||</span><br><span class="line">      (<span class="built_in">type</span> === TriggerOpTypes.SET &amp;&amp; target instanceof Map)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">#如果原始数据是数组，则key为length，否则为迭代行为标识符</span></span><br><span class="line">      add(depsMap.get(isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target instanceof Map) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const run = (effect: ReactiveEffect) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="built_in">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 这里对computed进行区分，因为computed 对象中自带scheduler函数</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># 运行所有计算数据的监听方法</span></span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computed</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> computed&lt;T&gt;(getter: ComputedGetter&lt;T&gt;): ComputedRef&lt;T&gt;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  options: WritableComputedOptions&lt;T&gt;</span><br><span class="line">): WritableComputedRef&lt;T&gt;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="built_in">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? () =&gt; &#123;</span><br><span class="line">          console.warn(<span class="string">'Write operation failed: computed value is readonly'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> dirty = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">let</span> value: T</span><br><span class="line">  <span class="built_in">let</span> computed: ComputedRef&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  const runner = effect(getter, &#123;</span><br><span class="line">    lazy: <span class="literal">true</span>,</span><br><span class="line">    scheduler: () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        dirty = <span class="literal">true</span></span><br><span class="line">        trigger(computed, TriggerOpTypes.SET, <span class="string">'value'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  computed = &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    [ReactiveFlags.IS_READONLY]:</span><br><span class="line">      isFunction(getterOrOptions) || !getterOrOptions.set,</span><br><span class="line"></span><br><span class="line">    // expose effect so computed can be stopped</span><br><span class="line">    effect: runner,</span><br><span class="line">    get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">       <span class="comment"># 跑单测可以发现这个是为了防止重复计算的。</span></span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = runner()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"># 收集依赖</span></span><br><span class="line">      track(computed, TrackOpTypes.GET, <span class="string">'value'</span>)</span><br><span class="line">      <span class="built_in">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> value(newValue: T) &#123;</span><br><span class="line">      setter(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; as any</span><br><span class="line">  <span class="built_in">return</span> computed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OVER</p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript读书笔记</title>
    <url>/2019/08/05/readingNote-JS/</url>
    <content><![CDATA[<h2 id="new运算符的实现"><a href="#new运算符的实现" class="headerlink" title="new运算符的实现"></a>new运算符的实现</h2><h3 id="定义一个函数，以及原型链的方法"><a href="#定义一个函数，以及原型链的方法" class="headerlink" title="定义一个函数，以及原型链的方法"></a>定义一个函数，以及原型链的方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Testfoo(name) &#123;</span><br><span class="line">    console.log(this[name]) </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Testfoo.prototype.sayHello= <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'hello'</span>);</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">//使用new运算符</span><br><span class="line"><span class="built_in">let</span> aaa = new Testfoo();</span><br><span class="line">aaa.sayHello();//输出hello</span><br><span class="line">//不使用new运算符</span><br><span class="line"><span class="built_in">let</span> testObj  = &#123;&#125;;//创建空对象</span><br><span class="line">testObj=Object.create(Testfoo.prototype);//创建一个具有Testfoo的原型链的空方法</span><br><span class="line">Testfoo.call(testObj);//指定this</span><br><span class="line">console.log(<span class="string">'testObj'</span>,testObj.sayHello());//输出hello</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="call和bind实现"><a href="#call和bind实现" class="headerlink" title="call和bind实现"></a>call和bind实现</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Function.prototype.myCall = <span class="keyword">function</span>(ctx, ...argv) &#123;</span><br><span class="line">	ctx = typeof ctx === <span class="string">'object'</span> ? ctx || global : &#123;&#125; // 当 ctx 是对象的时候默认设置为 ctx；如果为 null 则设置为 window 否则为空对象</span><br><span class="line">	const fn = Symbol(<span class="string">'fn'</span>)</span><br><span class="line">	ctx[fn] = this</span><br><span class="line">	ctx[fn](...argv)</span><br><span class="line">        delete ctx[fn]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> objCall = &#123; fn: <span class="string">'functionName'</span>, a: 10 &#125;;</span><br><span class="line">Testfoo.myCall(objCall, <span class="string">'a'</span>);//输出10</span><br></pre></td></tr></table></figure>

<p>ctx代表当前对象，this指针指向的是调用该方法的函数，将this指针指向的方法的引用地址赋值给当前对象内的fn字段。然后调用方法，这样this指针指向的方法的内部this指针的指向就是当前对象，这样就可以实现了this指针的绑定，</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind=<span class="keyword">function</span>(ctx,...arg1)&#123;</span><br><span class="line">    <span class="built_in">return</span> (...arg2)=&gt;&#123;</span><br><span class="line">        <span class="built_in">return</span> this.call(ctx,...arg2,...arg1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> obj2=&#123;a:1&#125;;</span><br><span class="line"><span class="keyword">function</span> addTwoNum(x,y)&#123;</span><br><span class="line">    console.log(x+y,this.a);</span><br><span class="line">&#125;</span><br><span class="line">addTwoNum.myBind(obj2,2)(2);//4 1;</span><br><span class="line">addTwoNum.myBind(obj2,2,2)();//4 1</span><br><span class="line">addTwoNum.myBind(obj2)(2,2);//4 1</span><br></pre></td></tr></table></figure>

<h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><p>iteraotr接口部署在Symbol.iterator上，一些内置类型拥有默认的迭代器行为，其他类型（如 Object）则没有。下表中的内置类型拥有默认的@@iterator方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype[@@iterator]</span><br><span class="line">TypedArray.prototype[@@iterator](</span><br><span class="line">String.prototype[@@iterator]</span><br><span class="line">Map.prototype[@@iterator]</span><br><span class="line">Set.prototype[@@iterator]</span><br></pre></td></tr></table></figure>

<p>遍历接口可以是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function DiyIterator()&#123;</span><br><span class="line">    var arr=[1,2,3];</span><br><span class="line">    var it=arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">    for(var v,res;(res=it.next())&amp;&amp;!res.done;)&#123;</span><br><span class="line">        v=res.value;</span><br><span class="line">        console.log(v);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function DiyIterator()&#123;</span><br><span class="line">    var arr=[1,2,3];</span><br><span class="line">   for(let item of arr)&#123;</span><br><span class="line">       console.log(item);//1,2,3</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String, Array, TypedArray, Map and Set 是所有内置可迭代对象， 因为它们的原型对象都有一个 @@iterator 方法.Object没有部署iterator接口，所以当执行这样的语句时，就会报错<br><img src="https://user-gold-cdn.xitu.io/2019/6/27/16b998bea55f3d96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片"></p>
<p>遍历对象可以用for..in..(for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。),或者用Object.entries(),Object.keys(),Object.values(),或者可以自己实现一个iterator接口，然后就成了这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function seriesIterator()&#123;</span><br><span class="line">    let task=&#123;</span><br><span class="line">        [Symbol.iterator]()&#123;</span><br><span class="line">            var steps=this.action.slice();</span><br><span class="line">            return &#123;</span><br><span class="line">                [Symbol.iterator]()&#123;return this&#125;,</span><br><span class="line">                next(...args)&#123;</span><br><span class="line">                    if(steps.length&gt;0)&#123;</span><br><span class="line">                        //为存放function的数组部署iterator接口</span><br><span class="line">                        let res=steps.shift()(...args);</span><br><span class="line">                        console.log(res);</span><br><span class="line">                        return &#123;</span><br><span class="line">                            value:res,done:false</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        return &#123;done:true&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                return(v)&#123;</span><br><span class="line">                    steps.length=0;</span><br><span class="line">                    return &#123;value:v,done:true&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        action:[]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.action.push(</span><br><span class="line">        function step1(x)&#123;</span><br><span class="line">            console.log(&apos;step 1:&apos;,x);</span><br><span class="line">            return x*2;</span><br><span class="line">        &#125;,</span><br><span class="line">        function step2(x,y)&#123;</span><br><span class="line">            console.log(`step 2 $&#123;x&#125; $&#123;y&#125;`);</span><br><span class="line">            return x+(y*2);</span><br><span class="line">        &#125;,</span><br><span class="line">        function step3(x,y,z)&#123;</span><br><span class="line">            console.log(`step 3 $&#123;x&#125; $&#123;y&#125; $&#123;z&#125;`);</span><br><span class="line">            return (x*y)+z;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    let it=task[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">    it.next(10);</span><br><span class="line">    it.next(10,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/6/27/16b99940ab1c985c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片"></p>
<p>根据MDN文档，如果一个迭代器 @@iterator 没有返回一个迭代器对象，那么它就是一个不符合标准的迭代器，这样的迭代器将会在运行期抛出异常，甚至非常诡异的 Bug。所以 需要返回this，next就是具体的逻辑，科科~</p>
<h2 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h2><h3 id="第一种就是常见的递归"><a href="#第一种就是常见的递归" class="headerlink" title="第一种就是常见的递归"></a>第一种就是常见的递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr=[1,2,3,[3,2,1,[1,2,3]]];</span><br><span class="line">const bianpinghua1= arr =&gt;&#123;</span><br><span class="line">    return arr.reduce((sum,cur)=&gt;&#123;</span><br><span class="line">        return sum.concat(Array.isArray(cur)?bianpinghua1(cur):cur);</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line">const testArr = bianpinghua1(arr)//[ 1, 2, 3, 3, 2, 1, 1, 2, 3 ]</span><br></pre></td></tr></table></figure>

<h3 id="第二种用es6的generator"><a href="#第二种用es6的generator" class="headerlink" title="第二种用es6的generator"></a>第二种用es6的generator</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function*  bianpinghua(arr)&#123; </span><br><span class="line">    if(Array.isArray(arr))&#123;</span><br><span class="line">        for(let i of arr)&#123;</span><br><span class="line">            yield* bianpinghua(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else</span><br><span class="line">        yield arr;</span><br><span class="line">&#125;</span><br><span class="line">for(let i of bianpinghua(arr))&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种用es6-我也不知道具体哪个时候出的api-的flat"><a href="#第三种用es6-我也不知道具体哪个时候出的api-的flat" class="headerlink" title="第三种用es6+(我也不知道具体哪个时候出的api)的flat"></a>第三种用es6+(我也不知道具体哪个时候出的api)的flat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr =[1,2,[3,4]];</span><br><span class="line">let temp =arr.flat(Infinity);</span><br><span class="line">console.lg(temp);//[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var  let const"></a>var  let const</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var声明的变量支持变量提升，提升到当前作用域的顶层，level低于函数声明式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">    var name =&apos;Jack&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样输出的name是undefined，var name = ‘Jack’ 在解析器中分为var name ; name = ‘Jack’ 两步，而var的变量提升了var name;所以上述代码在解析器中的眼里是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var name;</span><br><span class="line">    console.log(name);</span><br><span class="line">    name=&apos;Jack&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h3><p>let 和 const 声明的变量不会像var一样造成变量提升,let 和const 声明的变量只有在声明之后才能使用, let声明的变量会造成TDZ(暂时性死区)，在声明变量之前调用会抛出错误 ReferenceError<br>const 声明的变量不允许重新赋值，但是允许修改引用地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tempObj =&#123;</span><br><span class="line">    a :1</span><br><span class="line">&#125;</span><br><span class="line">console.log(tempObj);//&#123;a:1&#125;</span><br><span class="line">tempObj.a=2;</span><br><span class="line">console.log(tempObj)//&#123;a:2&#125;</span><br></pre></td></tr></table></figure>

<p>可以选择使用Object.freeze()来冻结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tempObj =&#123;</span><br><span class="line">    a :1</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(tempObj)</span><br><span class="line">console.log(tempObj);//&#123;a:1&#125;</span><br><span class="line">tempObj.a=2;</span><br><span class="line">console.log(tempObj)//&#123;a:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>   在JS里有两类任务，一种是同步任务，一种是异步任务，其中异步任务又含有宏任务(Macrotasks)和微任务(Microtasks )，setTimeout setInterval setImmediate<br>I/O UI渲染 就是异步任务中宏任务的典型代表,而微任务中的代表是Pormise,在JS执行顺序中，最先执行的是同步任务，接着是异步任务中的微任务，再接着是宏任务，微任务和宏任务的是放在不同的执行队列中，只有微任务执行完了才会执行开始调用宏任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  function test()&#123;</span><br><span class="line">      console.log(2);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(1);</span><br><span class="line">  test();</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">      console.log(3);</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise((resolve,rejected)=&gt;&#123;</span><br><span class="line">      resolve(4);</span><br><span class="line">      console.log(6);</span><br><span class="line">  &#125;).then(res=&gt;&#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">// 1 2 6 4 3</span><br></pre></td></tr></table></figure>

<p>console.log(1)和test 均属于同步任务，所以他们两个最先执行，输出1，2 ，setTimeou和promise均属于异步任务，因此它们都被推到全局API中的任务队列中等待执行栈中的任务执行完毕，等执行栈中的任务执行完毕时，就执行microTask queue中的微任务，等微任务执行完成时，再去寻找macroTask queue中是否还有寻找执行的宏任务；对promise来说 new Promise()里面的程序是属于同步任务的,而pormise的then方法才是属于异步任务中的微任务。</p>
<h2 id="数组常见方法的使用"><a href="#数组常见方法的使用" class="headerlink" title="数组常见方法的使用"></a>数组常见方法的使用</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function extractId(data)&#123;</span><br><span class="line">    return data.map(item=&gt;item.id);</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    &#123;</span><br><span class="line">        id:1,</span><br><span class="line">        name:&apos;Tom&apos;,</span><br><span class="line">        age:1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:2,</span><br><span class="line">        name:&apos;Jack&apos;,</span><br><span class="line">        age:2</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">console.log(extractId(arr));//[1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function extractIdAndAge(data)&#123;</span><br><span class="line">    return data.map(item=&gt;[item.id,item.age]);</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    &#123;</span><br><span class="line">        id:1,</span><br><span class="line">        name:&apos;Tom&apos;,</span><br><span class="line">        age:2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:2,</span><br><span class="line">        name:&apos;Jack&apos;,</span><br><span class="line">        age:1</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">console.log(extractId(arr));//[ [ 1, 2 ], [ 2, 1 ] ]</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。filter方法返回的元素的boolean值为真</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(data)&#123;</span><br><span class="line">    return data.filter(item=&gt;item)</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    undefined,null,NaN,0,false,&apos;&apos;,1</span><br><span class="line">]</span><br><span class="line">console.log(arr)//1</span><br><span class="line">因为undefined,null, NaN , 0 ,false ，&apos;&apos;转为boolean值后均为false</span><br></pre></td></tr></table></figure>

<h3 id="every-some"><a href="#every-some" class="headerlink" title="every,some"></a>every,some</h3><p>every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。若收到一个空数组，此方法在一切情况下都会返回 true。every遍历的数组的每个元素都需要满足判断条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(data)&#123;</span><br><span class="line">    return data.every(item=&gt;item&gt;1)</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    2,3,4,0,0,1,1,null,undefined</span><br><span class="line">]</span><br><span class="line">console.log(test(arr))//false，因为0&lt;1,null 和undefined与数字比较时会转成数字0</span><br><span class="line">let arr1= [</span><br><span class="line">    2,3,4,5,6,7,8</span><br><span class="line">]</span><br><span class="line">console.log(test(arr1));//true</span><br></pre></td></tr></table></figure>

<p>some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。只要一个符合条件，就返回true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(data)&#123;</span><br><span class="line">    return data.some(item=&gt;item&gt;1)</span><br><span class="line">&#125;</span><br><span class="line">let arr =[</span><br><span class="line">    2,3,4,0,0,1,1,null,undefined</span><br><span class="line">]</span><br><span class="line">console.log(test(arr))//true</span><br></pre></td></tr></table></figure>

<h3 id="splice、slice"><a href="#splice、slice" class="headerlink" title="splice、slice"></a>splice、slice</h3><p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。<br>splice(startNumber,deleteCount,…item)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr=[1,2,3];</span><br><span class="line">arr.splice(0,1);//arr-&gt;[2,3]</span><br><span class="line"></span><br><span class="line">arr.splice(0,0,1);//arr-&gt;[ 1, 2, 3, 4, 5, 6, 7, 8 ]</span><br></pre></td></tr></table></figure>

<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。不给slice添加参数时默认返回所有元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1= [</span><br><span class="line">    2,3,4,5,6,7,8</span><br><span class="line">]</span><br><span class="line">let temp =arr1.slice(0,2)</span><br><span class="line">console.log(temp,arr1);//[ 2, 3 ] [ 2, 3, 4, 5, 6, 7, 8 ]</span><br></pre></td></tr></table></figure>

<h3 id="push-pop-shift-unshift"><a href="#push-pop-shift-unshift" class="headerlink" title="push pop shift unshift"></a>push pop shift unshift</h3><p>pop 返回数组最后一个元素，改变原数组<br>shift 返回数组第一个元素，改变原数组<br>push  向数组的末尾添加元素<br>unshift 向数组的头部添加元素</p>
<h3 id="includes-indexof-lastIndexOf"><a href="#includes-indexof-lastIndexOf" class="headerlink" title="includes indexof lastIndexOf"></a>includes indexof lastIndexOf</h3><p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">console.log(arr.includes(1))//true</span><br></pre></td></tr></table></figure>

<p>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>lastIndexOf与此类似，返回给定元素的最后一个索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr =[1,2,3,1];</span><br><span class="line">console.log(arr.indexOf(1))//0</span><br><span class="line">console.log(arr.lastIndexOf(2))//3</span><br><span class="line">console.log(arr.indexOf(4))//-1</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换有两种，要么是显示类型转换，要么是隐式类型转换</p>
<h3 id="显示类型转换见W3C"><a href="#显示类型转换见W3C" class="headerlink" title="显示类型转换见W3C"></a>显示类型转换见<a href="https://www.w3school.com.cn/js/js_type_conversion.asp" target="_blank" rel="noopener">W3C</a></h3><hr>
<h3 id="隐式类型转换常见于运算符比较隐式转换，参考ES规范11-9-3"><a href="#隐式类型转换常见于运算符比较隐式转换，参考ES规范11-9-3" class="headerlink" title="隐式类型转换常见于运算符比较隐式转换，参考ES规范11.9.3"></a>隐式类型转换常见于运算符比较隐式转换，参考<a href="http://yanhaijing.com/es5/#199" target="_blank" rel="noopener">ES规范</a>11.9.3</h3><hr>
<pre><code>若Type(x)与Type(y)相同， 则
若Type(x)为Undefined， 返回true。
若Type(x)为Null， 返回true。
若Type(x)为Number， 则
若x为NaN， 返回false。
若y为NaN， 返回false。
若x与y为相等数值， 返回true。
若x 为 +0 且 y为−0， 返回true。
若x 为 −0 且 y为+0， 返回true。
返回false。
若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false。
若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false。
当x和y为引用同一对象时返回true。否则，返回false。
若x为null且y为undefined， 返回true。
若x为undefined且y为null， 返回true。
若Type(x) 为 Number 且 Type(y)为String， 返回comparison x == ToNumber(y)的结果。
若Type(x) 为 String 且 Type(y)为Number，
返回比较ToNumber(x) == y的结果。
若Type(x)为Boolean， 返回比较ToNumber(x) == y的结果。
若Type(y)为Boolean， 返回比较x == ToNumber(y)的结果。
若Type(x)为String或Number，且Type(y)为Object，返回比较x == ToPrimitive(y)的结果。
若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) == y的结果。
返回false。</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]==![]</span><br><span class="line">//等式右边的显然是显示转换，根据规则，所有对象或数组的boolean总是为true,那么取反也就是false,那么等式就变成[]==false,接下来是等式的隐式类型转换，明显等式左边的是一个数组，那么就调用它的ToPrimitive方法，返回&apos;&apos;，因此等式变成&apos;&apos;==false，</span><br><span class="line">//接着进行基本类型转换,&apos;&apos;-&gt;0,false-&gt;0，最后等式变成0==0，所以结果是true</span><br><span class="line">1==&apos;1&apos;//true</span><br><span class="line">1==null//fasle</span><br><span class="line">1==undefined//false</span><br><span class="line">1==true//true</span><br><span class="line">1==[]//false</span><br><span class="line">&#123;&#125;==0//Unexpected token ==,这是因为AST把第一个&#123;&#125;不是解析成对象，而是解析成一个block(代码块),因此其实等式左边是没有值的，因此抛出一个异常,有疑问自行google AST explorer</span><br><span class="line">0==&#123;&#125;//true</span><br><span class="line">&#123;&#125;+1==1//true ,对于加法运算，JS会把运算符两侧的对象调用toPrimitive方法，因此等式变成&apos;&apos;+1==1-&gt;&apos;1&apos;==1-&gt;1==1</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JS中对闭包的解释是在函数中调用另一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(a)&#123;</span><br><span class="line">    return function inner()&#123;</span><br><span class="line">        return ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = 2;</span><br><span class="line">const testVim = test(a);//testVim 在没有销毁时始终占有function inner的内存地址</span><br><span class="line"></span><br><span class="line">console.log(&quot;testVim:&quot;, testVim());//3</span><br><span class="line">console.log(&quot;testVim:&quot;, testVim());//4</span><br><span class="line">console.log(&quot;testVim:&quot;, testVim());//5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    document.body.style.fontSize = size + &apos;px&apos;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var size12 = makeSizer(12);</span><br><span class="line">var size14 = makeSizer(14);</span><br><span class="line">var size16 = makeSizer(16);</span><br></pre></td></tr></table></figure>

<p>size12，size14 和 size16 三个函数将分别把 body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&apos;size-12&apos;).onclick = size12;</span><br><span class="line">document.getElementById(&apos;size-14&apos;).onclick = size14;</span><br><span class="line">document.getElementById(&apos;size-16&apos;).onclick = size16;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot; id=&quot;size-12&quot;&gt;12&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; id=&quot;size-14&quot;&gt;14&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; id=&quot;size-16&quot;&gt;16&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="统计同一个字符串中出现次数最多的字符"><a href="#统计同一个字符串中出现次数最多的字符" class="headerlink" title="统计同一个字符串中出现次数最多的字符"></a>统计同一个字符串中出现次数最多的字符</h2><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>用正则匹配，\w可以用.代替</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str =&apos;aaaaaaaabbbbbccccccccccccc&apos;;</span><br><span class="line">let getMaxCount = (str)=&gt;&#123;</span><br><span class="line">    const reg = /(\w)\1+/g;</span><br><span class="line">    const result = str.match(reg);</span><br><span class="line">    let finalResult = result.map(item=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            length:item.length,</span><br><span class="line">            item:item[0]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).sort((a,b)=&gt;&#123;</span><br><span class="line">        return a.length-b.length&lt;0</span><br><span class="line">    &#125;);</span><br><span class="line">    // console.log(finalResult)</span><br><span class="line">    return finalResult[0];</span><br><span class="line">&#125;</span><br><span class="line">getMaxCount(str);</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let getMaxCount_2 = (str)=&gt;&#123;</span><br><span class="line">    let temp = str.split(&quot;&quot;);</span><br><span class="line">    let result  = temp.reduce((obj,cur)=&gt;&#123;</span><br><span class="line">        obj[cur] = ++obj[cur]||1;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">    let max = &#123;</span><br><span class="line">        len:0,</span><br><span class="line">        item:&apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    for(let index in result)&#123;</span><br><span class="line">        if(result[index]&gt;max.len)&#123;</span><br><span class="line">            max.len = result[index];</span><br><span class="line">            max.item = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">getMaxCount_2(str);</span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isUnique = (arr)=&gt;&#123;</span><br><span class="line">    const equals = (a, b) =&gt; &#123;</span><br><span class="line">        if (a === b) return true;</span><br><span class="line">        if (a instanceof Date &amp;&amp; b instanceof Date) return a.getTime() === b.getTime();</span><br><span class="line">        if (!a || !b || (typeof a !== &apos;object&apos; &amp;&amp; typeof b !== &apos;object&apos;)) return a === b;</span><br><span class="line">        if (a === null || a === undefined || b === null || b === undefined) return false;</span><br><span class="line">        if (a.prototype !== b.prototype) return false;</span><br><span class="line">        let keys = Object.keys(a);</span><br><span class="line">        if (keys.length !== Object.keys(b).length) return false;</span><br><span class="line">        return keys.every(k =&gt; equals(a[k], b[k]));</span><br><span class="line">      &#125;;</span><br><span class="line">    </span><br><span class="line">    for(let i =0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        for(let j =i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">            if(!!equals(arr[i],arr[j]))&#123;</span><br><span class="line">                arr.splice(j,1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">isUnique([123, [1, 2, 3], [1, &quot;2&quot;, 3], [1, 2, 3], &quot;meili&quot;,&#123;a:1,b:1&#125;,&#123;b:1,a:1&#125;]);</span><br></pre></td></tr></table></figure>

<h2 id="数组转链表"><a href="#数组转链表" class="headerlink" title="数组转链表"></a>数组转链表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*链表节点</span><br><span class="line">*param &#123;*&#125; val</span><br><span class="line">*param &#123;ListNode&#125; next</span><br><span class="line">**/</span><br><span class="line">function ListNode(val,next=null)&#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*将数组转为链表</span><br><span class="line">*param &#123;array&#125; a</span><br><span class="line">*param &#123;ListNode&#125; </span><br><span class="line">**/</span><br><span class="line">const getListFromArray=a=&gt;&#123;</span><br><span class="line">    let dummy = new ListNode()</span><br><span class="line">    let pre =dummy;</span><br><span class="line">    a.forEach(x =&gt; &#123;</span><br><span class="line">        return pre=pre.next=new ListNode(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*将链表转为数组</span><br><span class="line">*param &#123;array&#125; </span><br><span class="line">*param &#123;ListNode&#125; node </span><br><span class="line">**/</span><br><span class="line">const getArrayFromList = index=&gt;&#123;</span><br><span class="line">    let a=[];</span><br><span class="line">    while(node)&#123;</span><br><span class="line">        a.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map,Set,WeakMap,WeakSet"></a>Map,Set,WeakMap,WeakSet</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值<br>new Map([iterable])<br>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined</p>
<p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>
<ul>
<li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li>
<li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li>
<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>
<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。<br>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>
<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">[0,0];</span><br><span class="line">]);</span><br><span class="line">map.size;//1</span><br><span class="line">for(let key of map.keys())&#123;</span><br><span class="line">    console.log(key)//0</span><br><span class="line">&#125;</span><br><span class="line">for(let [key,value] of map.keys())&#123;</span><br><span class="line">    console.log(key,value)//0 0</span><br><span class="line">&#125;</span><br><span class="line">for(let value of map.keys())&#123;</span><br><span class="line">    console.log(value)//0 0</span><br><span class="line">&#125;</span><br><span class="line">map.clear()//清楚map对象所有键值对</span><br><span class="line">map.delete(key)/*如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false */</span><br><span class="line">map.get(key)/*返回键对应的值，如果不存在，则返回undefined。*/</span><br><span class="line">map.set(key,value);/*设置Map对象中键的值。返回该Map对象。*/</span><br><span class="line">map.has(key)/*返回一个布尔值，表示Map实例是否包含键对应的值。*/</span><br></pre></td></tr></table></figure>

<ul>
<li>NaN 也可以作为Map对象的键。虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，但下面的例子表明，NaN作为Map的键来说是没有区别的:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, &quot;not a number&quot;);</span><br><span class="line"></span><br><span class="line">myMap.get(NaN); // &quot;not a number&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span><br><span class="line">var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];</span><br><span class="line">var myMap = new Map(kvArray);</span><br><span class="line"></span><br><span class="line">console.log(Array.from(myMap)); // 输出和kvArray相同的数组</span><br></pre></td></tr></table></figure>

<p>Map对象间可以进行合并，但是会保持键的唯一性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var first = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">var second = new Map([</span><br><span class="line">  [1, &apos;uno&apos;],</span><br><span class="line">  [2, &apos;dos&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span><br><span class="line">// 展开运算符本质上是将Map对象转换成数组。</span><br><span class="line">var merged = new Map([...first, ...second]);</span><br><span class="line"></span><br><span class="line">console.log(merged.get(1)); // uno</span><br><span class="line">console.log(merged.get(2)); // dos</span><br><span class="line">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>

<p>Map对象也能与数组合并：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var merged = new Map([...first, ...second, [1, &apos;eins&apos;]]);</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>new Set([iterable]);</p>
<ul>
<li>如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。</li>
<li>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>ES6的这个Set结构出来以后一直被当作一个去重的的一个省时省力的结构，前提是去重的元素不是引用类型的。<br><img src="/images/readingNote/set_example.png" alt="图片"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr =[1,2,4,5,6,1,2];</span><br><span class="line">let set2= new Set(arr);//1,2,3,4,5,6  生成的是Set结构，不是Array结构</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(value) </span><br><span class="line">//在Set对象尾部添加一个元素。返回该Set对象。</span><br><span class="line">clear()</span><br><span class="line">//移除Set对象内的所有元素。</span><br><span class="line">delete(value)</span><br><span class="line">//移除Set的中与这个值相等的元素</span><br><span class="line">entries()</span><br><span class="line">//返回一个新的迭代器对象,[value,value]数组，为了使这个方法和Map对象保持相似， 每个值的键和值相等。</span><br><span class="line">has()</span><br><span class="line">//返回一个布尔值，表示该值在Set中存在与否。</span><br><span class="line">values()</span><br><span class="line">//返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</span><br></pre></td></tr></table></figure>

<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。<br>new WeakMap([iterable])<br>Iterable 是一个数组（二元数组）或者其他可迭代的且其元素是键值对的对象。每个键值对会被加到新的 WeakMap 里。null 会被当做 undefined</p>
<p>WeakMap 的 key 只能是 Object 类型。 原始数据类型 是不能作为 key 的（比如 Symbol）。<br>WeakMap 的 key是不可枚举的，因为它的弱引用机制，不确保key是否会被GC;没有部署迭代器，不能用for循环遍及</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete(key)</span><br><span class="line">get(key)</span><br><span class="line">has(key)</span><br><span class="line">set(key,value)</span><br></pre></td></tr></table></figure>

<p>当WeakMap里面的key设置为null时，WeakMap里面将不再存储key=null的映射，取消内存引用避免造成内存泄漏，从而使得不再被使用的key能被正确GC.</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 对象允许你将弱保持对象存储在一个集合中。<br>new WeakSet([iterable]);<br>如果传入一个可迭代对象作为参数, 则该对象的所有迭代值都会被自动添加进生成的 WeakSet 对象中.<br>WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次.</p>
<p>它和 Set 对象的区别有两点:</p>
<ul>
<li>WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以.</li>
<li>WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素.</li>
</ul>
<p>方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear()</span><br><span class="line">delete(value)</span><br><span class="line">get(value)</span><br><span class="line">has(value)</span><br><span class="line">add(value)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws = new WeakSet();</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(window);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(window); // true</span><br><span class="line">ws.has(foo);    // false, 对象 foo 并没有被添加进 ws 中 </span><br><span class="line"></span><br><span class="line">ws.delete(window); // 从集合中删除 window 对象</span><br><span class="line">ws.has(window);    // false, window 对象已经被删除了</span><br><span class="line"></span><br><span class="line">ws.clear(); // 清空整个 WeakSet 对象</span><br></pre></td></tr></table></figure>

<h2 id="小数和整数的那些事"><a href="#小数和整数的那些事" class="headerlink" title="小数和整数的那些事"></a>小数和整数的那些事</h2><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const num = 2147483648.88;</span><br><span class="line">console.log(num&gt;&gt;&gt;0);// 2147483648 </span><br><span class="line">console.log(Math.trunc(num))//2147483648</span><br><span class="line">//Math.ceil,Math.round,Math.floor均可以取整，从左到右依次是向上取整，四舍五入取整，向下取整</span><br></pre></td></tr></table></figure>

<h3 id="取小数"><a href="#取小数" class="headerlink" title="取小数"></a>取小数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const num = 2147483648.88;</span><br><span class="line">console.log(num%1)//0.880000114440918</span><br><span class="line">console.log(3.1|0)//3;</span><br><span class="line">console.log(num|0)//-2147483648，&apos;|&apos;由于仅能处理32位整数，所以一旦数字超过这个范围，&apos;|&apos;就不能正确处理</span><br><span class="line">// 由于涉及到浮点数计算，无论加减乘除都会出现精度缺失问题</span><br></pre></td></tr></table></figure>

<h3 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//由于精度的问题，浮点数不能用&apos;===&apos;和&apos;!==&apos;来进行比较</span><br><span class="line">let a =0.1,b=0.2,c=0.3;</span><br><span class="line">let sum =a+b;</span><br><span class="line">console.log(sum==c);//false,由于精度问题，所以0.1+0.2是不等于0.3的，应该等于0.30000000000000004</span><br><span class="line">function fract(a,b)&#123;</span><br><span class="line">  return Math.abs(a-b)&lt;Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">console.log(fract(sum,c));//true,Number.EPSILON 属性表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。</span><br></pre></td></tr></table></figure>

<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><h3 id="lt-lt-左移"><a href="#lt-lt-左移" class="headerlink" title="&lt;&lt; 左移"></a>&lt;&lt; 左移</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。</span><br><span class="line">9&lt;&lt;2 =36;</span><br><span class="line">9(base 10) =00000000000000000000000000001001 (base 2)</span><br><span class="line">9&lt;&lt;2(base 10) =00000000000000000000000000100100 (base 2)</span><br><span class="line">//在数字 x 上左移 y 比特得到 x * 2y.因此9&lt;&lt;2 = 9*Math.pow(2,2)</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt-右移-有符号"><a href="#gt-gt-右移-有符号" class="headerlink" title="&gt;&gt; 右移(有符号)"></a>&gt;&gt; 右移(有符号)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。</span><br><span class="line">9 (base 10): 00000000000000000000000000001001 (base 2)            </span><br><span class="line">9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</span><br><span class="line">------</span><br><span class="line">-9 (base 10): 11111111111111111111111111110111 (base 2)</span><br><span class="line">-9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt-gt-右移-无符号"><a href="#gt-gt-gt-右移-无符号" class="headerlink" title="&gt;&gt;&gt;右移(无符号)"></a>&gt;&gt;&gt;右移(无符号)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</span><br><span class="line">*/</span><br><span class="line">9 (base 10): 00000000000000000000000000001001 (base 2)</span><br><span class="line">9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</span><br><span class="line">-------</span><br><span class="line">-9 (base 10): 11111111111111111111111111110111 (base 2)</span><br><span class="line">-9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)</span><br></pre></td></tr></table></figure>

<h3 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h3><ul>
<li>Number<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str = &apos;1&apos;;</span><br><span class="line">Number(str)//1</span><br><span class="line">Numebr(&apos;&apos;)//0</span><br><span class="line">Number(&apos;123n&apos;)//NaN</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Number 从字符串第一位开始判断，只要有一个不是数字，返回NaN，如果是空串，返回0；</p>
<ul>
<li>parseInt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(&apos;&apos;)//NaN</span><br><span class="line">parseInt(&apos;123&apos;)//123</span><br><span class="line">parseInt(&apos;123n&apos;)//123</span><br><span class="line">parseInt(&apos;n123n&apos;)//NaN</span><br></pre></td></tr></table></figure>

<p>parseInt 解析 过程中，当非数字字符排在数字后面时，返回解析到的数字，当非数字字符排在数字前面时，返回NaN</p>
<ul>
<li>‘&gt;&gt;底层二进制符’<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;123&apos; &gt;&gt; 0 //123</span><br><span class="line">&apos;123n&apos; &gt;&gt; 0 //0</span><br><span class="line">&apos;n123&apos; &gt;&gt;0 //0 </span><br><span class="line">&apos;&apos; &gt;&gt; 0 //0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>无效数字返回0，有效数字返回数字</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="blockquote-center">我会努力更新的</blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>简单请求和复杂请求</title>
    <url>/2020/09/16/request-of-complex-simply/</url>
    <content><![CDATA[<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>请求方法只能是以下三种：</p>
<ol>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ol>
<p>请求头只能用以下几种：</p>
<ol>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type （需要注意额外的限制）</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ol>
<p>Content——Type只能有以下几种</p>
<ol>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ol>
<p>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p>
<p>请求中没有使用 ReadableStream 对象。</p>
<h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p>非简单请求就是复杂亲求</p>
]]></content>
  </entry>
  <entry>
    <title>在JS文件使用svg加载svg文件</title>
    <url>/2020/10/13/svgInJS/</url>
    <content><![CDATA[<h3 id="怎么在js文件中用引用svg文件"><a href="#怎么在js文件中用引用svg文件" class="headerlink" title="怎么在js文件中用引用svg文件"></a>怎么在js文件中用引用svg文件</h3><p>使用webpack的require.context,它接收三个参数</p>
<ul>
<li>要搜索的文件夹目录</li>
<li>是否还应该搜索它的子目录，</li>
<li>以及一个匹配文件的正则表达式。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const req = require.context(<span class="string">'./svg'</span>, <span class="literal">false</span>, /\.svg$/)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>req返回的是一个方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> webpackContext(req) &#123;</span><br><span class="line">	var id = webpackContextResolve(req);</span><br><span class="line">	<span class="built_in">return</span> __webpack_require__(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含三个属性</p>
<ul>
<li>id</li>
<li>keys </li>
<li>resolve<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpackContext.keys = <span class="keyword">function</span> <span class="function"><span class="title">webpackContextKeys</span></span>() &#123;</span><br><span class="line">	<span class="built_in">return</span> Object.keys(map);</span><br><span class="line">&#125;;</span><br><span class="line">webpackContext.resolve = webpackContextResolve;</span><br><span class="line">webpackContext.id = <span class="string">"./src/icons/svg sync \\.svg$"</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>再使用<code>const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)</code>之后，会得到一个Module的数组,数组的每一项就是执行import后的Module<br><img src="/images/svg-in-js/map.png" alt="dom"><br><img src="/images/svg-in-js/image.png" alt="image"><br>Module数组<br><img src="/images/svg-in-js/module.png" alt="module"><br><strong>webpack_require</strong>方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> __webpack_require__(moduleId) &#123;</span><br><span class="line">/******/</span><br><span class="line">/******/ 		// Check <span class="keyword">if</span> module is <span class="keyword">in</span> cache</span><br><span class="line">/******/ 		<span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">/******/ 			<span class="built_in">return</span> installedModules[moduleId].exports;</span><br><span class="line">/******/ 		&#125;</span><br><span class="line">/******/ 		// Create a new module (and put it into the cache)</span><br><span class="line">/******/ 		var module = installedModules[moduleId] = &#123;</span><br><span class="line">/******/ 			i: moduleId,</span><br><span class="line">/******/ 			l: <span class="literal">false</span>,</span><br><span class="line">/******/ 			exports: &#123;&#125;,</span><br><span class="line">/******/ 			hot: hotCreateModule(moduleId),</span><br><span class="line">/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),</span><br><span class="line">/******/ 			children: []</span><br><span class="line">/******/ 		&#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ 		// Execute the module <span class="keyword">function</span></span><br><span class="line">/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));</span><br><span class="line">/******/</span><br><span class="line">/******/ 		// Flag the module as loaded</span><br><span class="line">/******/ 		module.l = <span class="literal">true</span>;</span><br><span class="line">/******/</span><br><span class="line">/******/ 		// Return the exports of the module</span><br><span class="line">/******/ 		<span class="built_in">return</span> module.exports;</span><br><span class="line">/******/ 	&#125;</span><br></pre></td></tr></table></figure>

<p>svg example</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/***/ <span class="string">"./src/icons/svg/bug.svg"</span>:</span><br><span class="line">/*!*******************************!*\</span><br><span class="line">  !*** ./src/icons/svg/bug.svg ***!</span><br><span class="line">  \*******************************/</span><br><span class="line">/*! exports provided: default */</span><br><span class="line">/***/ (<span class="keyword">function</span>(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var svg_baker_runtime_browser_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svg-baker-runtime/browser-symbol */ \"./node_modules/svg-baker-runtime/browser-symbol.js\");\n/* harmony import */ var svg_baker_runtime_browser_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(svg_baker_runtime_browser_symbol__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var svg_sprite_loader_runtime_browser_sprite_build__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svg-sprite-loader/runtime/browser-sprite.build */ \"./node_modules/svg-sprite-loader/runtime/browser-sprite.build.js\");\n/* harmony import */ var svg_sprite_loader_runtime_browser_sprite_build__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(svg_sprite_loader_runtime_browser_sprite_build__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar symbol = new svg_baker_runtime_browser_symbol__WEBPACK_IMPORTED_MODULE_0___default.a(&#123;\n  \"id\": \"icon-bug\",\n  \"use\": \"icon-bug-usage\",\n  \"viewBox\": \"0 0 128 128\",\n  \"content\": \"&lt;symbol xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 128 128\\\" id=\\\"icon-bug\\\"&gt;&lt;path d=\\\"M127.88 73.143c0 1.412-.506 2.635-1.518 3.669-1.011 1.033-2.209 1.55-3.592 1.55h-17.887c0 9.296-1.783 17.178-5.35 23.645l16.609 17.044c1.011 1.034 1.517 2.257 1.517 3.67 0 1.412-.506 2.635-1.517 3.668-.958 1.033-2.155 1.55-3.593 1.55-1.438 0-2.635-.517-3.593-1.55l-15.811-16.063a15.49 15.49 0 0 1-1.196 1.06c-.532.434-1.65 1.208-3.353 2.322a50.104 50.104 0 0 1-5.192 2.974c-1.758.87-3.94 1.658-6.546 2.364-2.607.706-5.189 1.06-7.748 1.06V47.044H58.89v73.062c-2.716 0-5.417-.367-8.106-1.102-2.688-.734-5.003-1.631-6.945-2.692a66.769 66.769 0 0 1-5.268-3.179c-1.571-1.057-2.73-1.94-3.476-2.65L33.9 109.34l-14.611 16.877c-1.066 1.14-2.344 1.711-3.833 1.711-1.277 0-2.422-.434-3.434-1.304-1.012-.978-1.557-2.187-1.635-3.627-.079-1.44.333-2.705 1.236-3.794l16.129-18.51c-3.087-6.197-4.63-13.644-4.63-22.342H5.235c-1.383 0-2.58-.517-3.592-1.55S.125 74.545.125 73.132c0-1.412.506-2.635 1.518-3.668 1.012-1.034 2.21-1.55 3.592-1.55h17.887V43.939L9.308 29.833c-1.012-1.033-1.517-2.256-1.517-3.669 0-1.412.505-2.635 1.517-3.668 1.012-1.034 2.21-1.55 3.593-1.55s2.58.516 3.593 1.55l13.813 14.106h67.396l13.814-14.106c1.012-1.034 2.21-1.55 3.592-1.55 1.384 0 2.581.516 3.593 1.55 1.012 1.033 1.518 2.256 1.518 3.668 0 1.413-.506 2.636-1.518 3.67l-13.814 14.105v23.975h17.887c1.383 0 2.58.516 3.593 1.55 1.011 1.033 1.517 2.256 1.517 3.668l-.005.01zM89.552 26.175H38.448c0-7.23 2.489-13.386 7.466-18.469C50.892 2.623 56.92.082 64 .082c7.08 0 13.108 2.541 18.086 7.624 4.977 5.083 7.466 11.24 7.466 18.469z\\\" /&gt;&lt;/symbol&gt;\"\n&#125;);\nvar result = svg_sprite_loader_runtime_browser_sprite_build__WEBPACK_IMPORTED_MODULE_1___default.a.add(symbol);\n/* harmony default export */ __webpack_exports__[\"default\"] = (symbol);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaWNvbnMvc3ZnL2J1Zy5zdmcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaWNvbnMvc3ZnL2J1Zy5zdmc/MjI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3ByaXRlU3ltYm9sIGZyb20gXCJzdmctYmFrZXItcnVudGltZS9icm93c2VyLXN5bWJvbFwiO1xuaW1wb3J0IHNwcml0ZSBmcm9tIFwic3ZnLXNwcml0ZS1sb2FkZXIvcnVudGltZS9icm93c2VyLXNwcml0ZS5idWlsZFwiO1xudmFyIHN5bWJvbCA9IG5ldyBTcHJpdGVTeW1ib2woe1xuICBcImlkXCI6IFwiaWNvbi1idWdcIixcbiAgXCJ1c2VcIjogXCJpY29uLWJ1Zy11c2FnZVwiLFxuICBcInZpZXdCb3hcIjogXCIwIDAgMTI4IDEyOFwiLFxuICBcImNvbnRlbnRcIjogXCI8c3ltYm9sIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDEyOCAxMjhcXFwiIGlkPVxcXCJpY29uLWJ1Z1xcXCI+PHBhdGggZD1cXFwiTTEyNy44OCA3My4xNDNjMCAxLjQxMi0uNTA2IDIuNjM1LTEuNTE4IDMuNjY5LTEuMDExIDEuMDMzLTIuMjA5IDEuNTUtMy41OTIgMS41NWgtMTcuODg3YzAgOS4yOTYtMS43ODMgMTcuMTc4LTUuMzUgMjMuNjQ1bDE2LjYwOSAxNy4wNDRjMS4wMTEgMS4wMzQgMS41MTcgMi4yNTcgMS41MTcgMy42NyAwIDEuNDEyLS41MDYgMi42MzUtMS41MTcgMy42NjgtLjk1OCAxLjAzMy0yLjE1NSAxLjU1LTMuNTkzIDEuNTUtMS40MzggMC0yLjYzNS0uNTE3LTMuNTkzLTEuNTVsLTE1LjgxMS0xNi4wNjNhMTUuNDkgMTUuNDkgMCAwIDEtMS4xOTYgMS4wNmMtLjUzMi40MzQtMS42NSAxLjIwOC0zLjM1MyAyLjMyMmE1MC4xMDQgNTAuMTA0IDAgMCAxLTUuMTkyIDIuOTc0Yy0xLjc1OC44Ny0zLjk0IDEuNjU4LTYuNTQ2IDIuMzY0LTIuNjA3LjcwNi01LjE4OSAxLjA2LTcuNzQ4IDEuMDZWNDcuMDQ0SDU4Ljg5djczLjA2MmMtMi43MTYgMC01LjQxNy0uMzY3LTguMTA2LTEuMTAyLTIuNjg4LS43MzQtNS4wMDMtMS42MzEtNi45NDUtMi42OTJhNjYuNzY5IDY2Ljc2OSAwIDAgMS01LjI2OC0zLjE3OWMtMS41NzEtMS4wNTctMi43My0xLjk0LTMuNDc2LTIuNjVMMzMuOSAxMDkuMzRsLTE0LjYxMSAxNi44NzdjLTEuMDY2IDEuMTQtMi4zNDQgMS43MTEtMy44MzMgMS43MTEtMS4yNzcgMC0yLjQyMi0uNDM0LTMuNDM0LTEuMzA0LTEuMDEyLS45NzgtMS41NTctMi4xODctMS42MzUtMy42MjctLjA3OS0xLjQ0LjMzMy0yLjcwNSAxLjIzNi0zLjc5NGwxNi4xMjktMTguNTFjLTMuMDg3LTYuMTk3LTQuNjMtMTMuNjQ0LTQuNjMtMjIuMzQySDUuMjM1Yy0xLjM4MyAwLTIuNTgtLjUxNy0zLjU5Mi0xLjU1Uy4xMjUgNzQuNTQ1LjEyNSA3My4xMzJjMC0xLjQxMi41MDYtMi42MzUgMS41MTgtMy42NjggMS4wMTItMS4wMzQgMi4yMS0xLjU1IDMuNTkyLTEuNTVoMTcuODg3VjQzLjkzOUw5LjMwOCAyOS44MzNjLTEuMDEyLTEuMDMzLTEuNTE3LTIuMjU2LTEuNTE3LTMuNjY5IDAtMS40MTIuNTA1LTIuNjM1IDEuNTE3LTMuNjY4IDEuMDEyLTEuMDM0IDIuMjEtMS41NSAzLjU5My0xLjU1czIuNTguNTE2IDMuNTkzIDEuNTVsMTMuODEzIDE0LjEwNmg2Ny4zOTZsMTMuODE0LTE0LjEwNmMxLjAxMi0xLjAzNCAyLjIxLTEuNTUgMy41OTItMS41NSAxLjM4NCAwIDIuNTgxLjUxNiAzLjU5MyAxLjU1IDEuMDEyIDEuMDMzIDEuNTE4IDIuMjU2IDEuNTE4IDMuNjY4IDAgMS40MTMtLjUwNiAyLjYzNi0xLjUxOCAzLjY3bC0xMy44MTQgMTQuMTA1djIzLjk3NWgxNy44ODdjMS4zODMgMCAyLjU4LjUxNiAzLjU5MyAxLjU1IDEuMDExIDEuMDMzIDEuNTE3IDIuMjU2IDEuNTE3IDMuNjY4bC0uMDA1LjAxek04OS41NTIgMjYuMTc1SDM4LjQ0OGMwLTcuMjMgMi40ODktMTMuMzg2IDcuNDY2LTE4LjQ2OUM1MC44OTIgMi42MjMgNTYuOTIuMDgyIDY0IC4wODJjNy4wOCAwIDEzLjEwOCAyLjU0MSAxOC4wODYgNy42MjQgNC45NzcgNS4wODMgNy40NjYgMTEuMjQgNy40NjYgMTguNDY5elxcXCIgLz48L3N5bWJvbD5cIlxufSk7XG52YXIgcmVzdWx0ID0gc3ByaXRlLmFkZChzeW1ib2wpO1xuZXhwb3J0IGRlZmF1bHQgc3ltYm9sIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/icons/svg/bug.svg\n"</span>);</span><br><span class="line"></span><br><span class="line">/***/ &#125;)</span><br></pre></td></tr></table></figure>

<p>所以在JS中使用svg标签来加载对应的svg文件的时候只需要在svg标签加入use 然后给id属性赋值为对应symbol的id，比如<code>id=&quot;#icon-404&quot;</code></p>
]]></content>
  </entry>
  <entry>
    <title>工具函数</title>
    <url>/2019/09/16/toolFunc/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    let timeout = null;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = null;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    let previous = 0;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let now = Date.now();</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line">        if (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否是数组"><a href="#判断是否是数组" class="headerlink" title="判断是否是数组"></a>判断是否是数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr=[];</span><br><span class="line">Array.isArray(arr);</span><br><span class="line">//or</span><br><span class="line">Object.prototype.toString.call(arr) === &apos;[Object Array]&apos;;</span><br></pre></td></tr></table></figure>

<h3 id="时间戳转字符串"><a href="#时间戳转字符串" class="headerlink" title="时间戳转字符串"></a>时间戳转字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getTime(_time,joiner,joiner2)&#123;</span><br><span class="line">  if(!time)&#123;</span><br><span class="line">    return &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  let time = new Date(_time);</span><br><span class="line">  const year = time.getFullYear();//获取年份</span><br><span class="line">  const month = time.getMonth()+1;//get the month of the time</span><br><span class="line">  const date = time.getDate()&lt;10 ? &apos;0&apos;+time.getDate():time.getDate();//get the day of the time;</span><br><span class="line">  const hour = time.getHours();</span><br><span class="line">  const minute = time.getMinutes();</span><br><span class="line">  const seconds = time.getSeconds();</span><br><span class="line">  const result = `$&#123;year&#125;$&#123;joiner&#125;$&#123;month&#125;$&#123;joiner&#125;$&#123;date&#125;  $&#123;hour&#125;$&#123;joiner2&#125;$&#123;minute&#125;$&#123;joiner2&#125;$&#123;seconds&#125;`;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深合并"><a href="#深合并" class="headerlink" title="深合并"></a>深合并</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> * @see merge</span><br><span class="line"> * @param &#123;Object&#125; obj1 Object to merge</span><br><span class="line"> * @returns &#123;Object&#125; Result of all merge properties</span><br><span class="line"> */</span><br><span class="line">function deepMerge(/* obj1, obj2, obj3, ... */) &#123;</span><br><span class="line">  var result = &#123;&#125;;</span><br><span class="line">  function assignValue(val, key) &#123;</span><br><span class="line">    if (typeof result[key] === &apos;object&apos; &amp;&amp; typeof val === &apos;object&apos;) &#123;</span><br><span class="line">      result[key] = deepMerge(result[key], val);</span><br><span class="line">    &#125; else if (typeof val === &apos;object&apos;) &#123;</span><br><span class="line">      result[key] = deepMerge(&#123;&#125;, val);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">    forEach(arguments[i], assignValue);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const matchTime = /(?&lt;=\s+\-\s+)(.)+|(.)+(?=\s+\-\s+)/g;//将xx年xx月xx日-xx年xx月xx日的时间格式切割</span><br><span class="line">const regx_positiveInt = /^[0-9]*[1-9][0-9]*$/; //正整数</span><br><span class="line">const regx_positiveAndZeroInt = /^\d+$/; //非负整数（正整数和0）</span><br><span class="line">const regx_number = /^[0-9]*$/;//数字</span><br><span class="line">const regx_ip=/^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d\d?)$/;//IP地址</span><br></pre></td></tr></table></figure>

<h3 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h3><p>由于JavaScript中不管整数还是小数都是Number类型，它的实现是遵循 IEEE 754标准，储存方式是以双精度浮点数储存的，可以表示十进制的15或者16位有效数字，所以当进行运算的数字超过这个范围的时候，就会用有精度缺失的问题，导致计算不准确，所以在大数加减的时候需要转成字符串来做，或者es6+有个BigInt类型也支持做大数加减，或者可以选择npm上的大数加减插件，比如number-precision</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var addStrings = function(num1, num2) &#123;</span><br><span class="line">  const maxLen = Math.max.apply(null, [num1.length, num2.length]);</span><br><span class="line">  let result = &quot;&quot;;</span><br><span class="line">  let ans = 0;</span><br><span class="line">  if(num1.length&lt;maxLen)&#123;</span><br><span class="line">      num1 = num1.padStart(maxLen, &quot;0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(num2.length&lt;maxLen)&#123;</span><br><span class="line">      num2 = num2.padStart(maxLen, &quot;0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i = maxLen - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">    const temp =ans+Number(num1[i]) + Number(num2[i]);</span><br><span class="line">    result=(temp % 10)+result;</span><br><span class="line">    ans = Math.floor(temp / 10);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(result);</span><br><span class="line">  return ans===1?ans+ result:result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isObject = (item)=&gt;&#123;</span><br><span class="line">  return Object.prototype.toString.call(item) === &apos;[object Object]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">const isArray = (item)=&gt;&#123;</span><br><span class="line">  return Object.prototype.toString.call(item) === &apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">const isDate = item =&gt;&#123;</span><br><span class="line">  return Object.prototype.toString.call(item) === &apos;[object Date]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">const isFunction = item =&gt;&#123;</span><br><span class="line">  return Object.prototype.toString.call(item) === &apos;[object Function]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">const deepClone=function(obj)&#123;</span><br><span class="line">    const cloneObj=isArray(obj)?[]:isObject(obj)?&#123;&#125;:&apos;&apos;;</span><br><span class="line">    for(let key in obj)&#123;</span><br><span class="line">      if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        if(isObject(obj[key])||isArray(obj[key]))&#123;</span><br><span class="line">          Object.assign(cloneObj,&#123;</span><br><span class="line">           [key]: deepClone(Reflect.get(obj,key))</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">          cloneObj[key] = obj[key];</span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cloneObj;</span><br><span class="line">&#125;</span><br><span class="line">function deepCopy(original) &#123;</span><br><span class="line">  if (Array.isArray(original)) &#123;</span><br><span class="line">    return original.map(elem =&gt; deepCopy(elem));</span><br><span class="line">  &#125; else if (typeof original === &apos;object&apos; &amp;&amp; original !== null) &#123;</span><br><span class="line">    return Object.fromEntries(</span><br><span class="line">      Object.entries(original)</span><br><span class="line">        .map(([k, v]) =&gt; [k, deepCopy(v)]));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Primitive value: atomic, no need to copy</span><br><span class="line">    return original;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深层更新"><a href="#深层更新" class="headerlink" title="深层更新"></a>深层更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepUpdate(original, keys, value) &#123;</span><br><span class="line">  if (keys.length === 0) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">  const currentKey = keys[0];</span><br><span class="line">  if (Array.isArray(original)) &#123;</span><br><span class="line">    return original.map(</span><br><span class="line">      (v, index) =&gt; index === currentKey</span><br><span class="line">        ? deepUpdate(v, keys.slice(1), value) // (A)</span><br><span class="line">        : v); // (B)</span><br><span class="line">  &#125; else if (typeof original === &apos;object&apos; &amp;&amp; original !== null) &#123;</span><br><span class="line">    return Object.fromEntries(</span><br><span class="line">      Object.entries(original).map(</span><br><span class="line">        (keyValuePair) =&gt; &#123;</span><br><span class="line">          const [k,v] = keyValuePair;</span><br><span class="line">          if (k === currentKey) &#123;</span><br><span class="line">            return [k, deepUpdate(v, keys.slice(1), value)]; // (C)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return keyValuePair; // (D)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Primitive value</span><br><span class="line">    return original;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深层冻结"><a href="#深层冻结" class="headerlink" title="深层冻结"></a>深层冻结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepFreeze(value) &#123;</span><br><span class="line">  if (Array.isArray(value)) &#123;</span><br><span class="line">    for (const element of value) &#123;</span><br><span class="line">      deepFreeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">    Object.freeze(value);</span><br><span class="line">  &#125; else if (typeof value === &apos;object&apos; &amp;&amp; value !== null) &#123;</span><br><span class="line">    for (const v of Object.values(value)) &#123;</span><br><span class="line">      deepFreeze(v);</span><br><span class="line">    &#125;</span><br><span class="line">    Object.freeze(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Nothing to do: primitive values are already immutable</span><br><span class="line">  &#125; </span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于现有对象的自定义方法"><a href="#基于现有对象的自定义方法" class="headerlink" title="基于现有对象的自定义方法"></a>基于现有对象的自定义方法</h3><p>PS:(不建议直接污染原型链，类型Date.prototype.xxx=function(){}这样的写法)</p>
<p>个人比较喜欢寄生组合继承或者es6的calss继承，比如要写一个基于Date的format方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DateSelf extends Date&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  getAll(begin,end)&#123;</span><br><span class="line">    let arr=[];</span><br><span class="line">    var ab = begin.split(&quot;-&quot;);</span><br><span class="line">    var ae = end.split(&quot;-&quot;);</span><br><span class="line">    var db = new Date();</span><br><span class="line">    db.setUTCFullYear(ab[0], ab[1] - 1, ab[2]);</span><br><span class="line">    var de = new Date();</span><br><span class="line">    de.setUTCFullYear(ae[0], ae[1] - 1, ae[2]);</span><br><span class="line">    var unixDb = db.getTime();</span><br><span class="line">    var unixDe = de.getTime();</span><br><span class="line">    for (var k = unixDb; k &lt;= unixDe;) &#123;</span><br><span class="line">        // arr.push((new Date(parseInt(k))).format());</span><br><span class="line">        arr.push((DateSelf.formatter(parseInt(k))))</span><br><span class="line">        k = k + 24 * 60 * 60 * 1000;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">DateSelf.formatter=function(time)&#123;</span><br><span class="line">  var s = &apos;&apos;;</span><br><span class="line">  const k =  new Date(time)</span><br><span class="line">  var mouth = (k.getMonth() + 1)&gt;=10?(k.getMonth() + 1):(&apos;0&apos;+(k.getMonth() + 1));</span><br><span class="line">  var day = k.getDate()&gt;=10?k.getDate():(&apos;0&apos;+k.getDate());</span><br><span class="line">  s += k.getFullYear() + &apos;-&apos;; // 获取年份。</span><br><span class="line">  s += mouth + &quot;-&quot;; // 获取月份。</span><br><span class="line">  s += day; // 获取日。</span><br><span class="line">  return (s); // 返回日期。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断对象类型"><a href="#判断对象类型" class="headerlink" title="判断对象类型"></a>判断对象类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.toType = (function toType(global) &#123;</span><br><span class="line">  return function(obj) &#123;</span><br><span class="line">    if (obj === global) &#123;</span><br><span class="line">      return &quot;global&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (&#123;&#125;).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(this)</span><br></pre></td></tr></table></figure>

<h3 id="用promsie异步加载图像"><a href="#用promsie异步加载图像" class="headerlink" title="用promsie异步加载图像"></a>用promsie异步加载图像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">functin load(image,attributes)&#123;</span><br><span class="line">  	if (!image) &#123;</span><br><span class="line">		return Promise.reject();</span><br><span class="line">	&#125; else if (typeof image === &apos;string&apos;) &#123;</span><br><span class="line">		/* Create a &lt;img&gt; from a string */</span><br><span class="line">		const src = image;</span><br><span class="line">		image = new Image();</span><br><span class="line">		Object.keys(attributes || &#123;&#125;).forEach(</span><br><span class="line">			name =&gt; image.setAttribute(name, attributes[name])</span><br><span class="line">		);</span><br><span class="line">		image.src = src;</span><br><span class="line">	&#125; else if (image.length !== undefined) &#123;</span><br><span class="line">		/* Treat as multiple images */</span><br><span class="line"></span><br><span class="line">		// Momentarily ignore errors</span><br><span class="line">		const reflected = [].map.call(image, img =&gt; load(img, attributes).catch(err =&gt; err));</span><br><span class="line"></span><br><span class="line">		return Promise.all(reflected).then(results =&gt; &#123;</span><br><span class="line">			const loaded = results.filter(x =&gt; x.naturalWidth);</span><br><span class="line">			if (loaded.length === results.length) &#123;</span><br><span class="line">				return loaded;</span><br><span class="line">			&#125;</span><br><span class="line">			return Promise.reject(&#123;</span><br><span class="line">				loaded,</span><br><span class="line">				errored: results.filter(x =&gt; !x.naturalWidth)</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else if (image.tagName.toUpperCase() !== &apos;IMG&apos;) &#123;</span><br><span class="line">		return Promise.reject();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		if (image.naturalWidth) &#123;</span><br><span class="line">			// If the browser can determine the naturalWidth the</span><br><span class="line">			// image is already loaded successfully</span><br><span class="line">			resolve(image);</span><br><span class="line">		&#125; else if (image.complete) &#123;</span><br><span class="line">			// If the image is complete but the naturalWidth is 0px</span><br><span class="line">			// it is probably broken</span><br><span class="line">			reject(image);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			image.addEventListener(&apos;load&apos;, fulfill);</span><br><span class="line">			image.addEventListener(&apos;error&apos;, fulfill);</span><br><span class="line">		&#125;</span><br><span class="line">		function fulfill() &#123;</span><br><span class="line">			if (image.naturalWidth) &#123;</span><br><span class="line">				resolve(image);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				reject(image);</span><br><span class="line">			&#125;</span><br><span class="line">			image.removeEventListener(&apos;load&apos;, fulfill);</span><br><span class="line">			image.removeEventListener(&apos;error&apos;, fulfill);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	promise.image = image;</span><br><span class="line">	return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类型"><a href="#获取类型" class="headerlink" title="获取类型"></a>获取类型</h3><p>({}).toString.call(obj) 的用法与 Object.prototype.toString.call(obj)一样。这两个返回的格式是[object [class]].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const toType = (obj) =&gt;&#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">toType(&#123;a: 4&#125;); //&quot;object&quot;</span><br><span class="line">toType([1, 2, 3]); //&quot;array&quot;</span><br><span class="line">(function() &#123;console.log(toType(arguments))&#125;)(); //arguments</span><br><span class="line">toType(new ReferenceError); //&quot;error&quot;</span><br><span class="line">toType(new Date); //&quot;date&quot;</span><br><span class="line">toType(/a-z/); //&quot;regexp&quot;</span><br><span class="line">toType(Math); //&quot;math&quot;</span><br><span class="line">toType(JSON); //&quot;json&quot;</span><br><span class="line">toType(new Number(4)); //&quot;number&quot;</span><br><span class="line">toType(new String(&quot;abc&quot;)); //&quot;string&quot;</span><br><span class="line">toType(new Boolean(true)); //&quot;boolean&quot;</span><br><span class="line"></span><br><span class="line">//typeof 也可以判断类型,但是只能获取基本类型，引用类型统一返回object，所以尽量用toType的方法;instanceof也可以,然鹅instanceof是基于原型链判断的，如果继承的话</span><br><span class="line">  class MyArray extends Array&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">      super()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const myArray = new MyArray();</span><br><span class="line">  console.log(`Array: $&#123;myArray instanceof Array&#125;`);</span><br><span class="line">  console.log(`MyArray :$&#123;myArray instanceof MyArray&#125;`);</span><br><span class="line">  //这样两个返回的都是true</span><br></pre></td></tr></table></figure>

<p>几个内置对象没有构造函数，因此不能用instanceof来判断类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math instanceof Math //TypeError</span><br></pre></td></tr></table></figure>

<p>一个window可以包含多个iframe框架，意味着包含多个全局上下文，因此意味着每个类型有多个构造器，在这样的环境下，给定的对象类型不能保证是给定的构造函数的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ifFrame = document.createElement(&apos;iframe&apos;);</span><br><span class="line">document.body.appendChild(ifFrame);</span><br><span class="line">const IFrameArray = window.frames[1].Array; </span><br><span class="line">const array = new IFrameArray();</span><br><span class="line"></span><br><span class="line">array instanceof IFrameArray //true</span><br><span class="line">array instanceof Array // false</span><br></pre></td></tr></table></figure>

<p>由于array的constructor是iframe中的Array,因此即使array 与 此时的window上下文中的Array都是数组范畴，但是instanceof是基于原型链来判断的，array的原型链是并没有指向当前window下的Array,因此array instanceof Array 为 false</p>
<p>之前的toType有个问题,当toType的传参是window,window内置方法以及DOM时，有很长一串的结果返回时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toType(window);</span><br><span class="line">//&quot;global&quot; (Chrome) &quot;domwindow&quot; (Safari) &quot;window&quot; (FF/IE9) &quot;object&quot; (IE7/IE8)</span><br><span class="line"> </span><br><span class="line">toType(document);</span><br><span class="line">//&quot;htmldocument&quot; (Chrome/FF/Safari) &quot;document&quot; (IE9) &quot;object&quot; (IE7/IE8)</span><br><span class="line"> </span><br><span class="line">toType(document.createElement(&apos;a&apos;));</span><br><span class="line">//&quot;htmlanchorelement&quot; (Chrome/FF/Safari/IE) &quot;object&quot; (IE7/IE8)</span><br><span class="line"> </span><br><span class="line">toType(alert);</span><br><span class="line">//&quot;function&quot; (Chrome/FF/Safari/IE9) &quot;object&quot; (IE7/IE8)</span><br></pre></td></tr></table></figure>

<p>改进一下toType方法,将这个方法挂载到Object上,但是不要挂载到prototype上，将这个方法写成IIFE+闭包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.toType = (function toType(global) &#123;</span><br><span class="line">  return function(obj) &#123;</span><br><span class="line">    if (obj === global) &#123;</span><br><span class="line">      return &quot;global&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (&#123;&#125;).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(this)</span><br><span class="line">Object.toType(window); //&quot;global&quot; (all browsers)</span><br><span class="line">Object.toType([1,2,3]); //&quot;array&quot; (all browsers)</span><br><span class="line">Object.toType(/a-z/); //&quot;regexp&quot; (all browsers)</span><br><span class="line">Object.toType(JSON); //&quot;json&quot; (all browsers)</span><br></pre></td></tr></table></figure>

<p>这个方法也不是万能的,如果扔进来一个未知类型,则会抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.toType(fff)//ReferenceError</span><br></pre></td></tr></table></figure>

<p>玩个好玩的，应该可以用具名组匹配来获取类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.toType = (function(global)&#123;</span><br><span class="line">    const reg = /(?&lt;type&gt;(?&lt;=\s+?)[A-Za-z]+)/;</span><br><span class="line">    return function(obj)&#123;</span><br><span class="line">      if(obj === global)&#123;</span><br><span class="line">          return &apos;global&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">      const matchObj = reg.exec(Object.prototype.toString.call(obj));</span><br><span class="line">      const type =  matchObj.groups.type;</span><br><span class="line">      return type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this)</span><br></pre></td></tr></table></figure>

<h3 id="takeRightWhile"><a href="#takeRightWhile" class="headerlink" title="takeRightWhile"></a>takeRightWhile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const takeRightWhile = (arr, func) =&gt;</span><br><span class="line">  arr.reduceRight((acc, el) =&gt; (func(el) ? acc : [el, ...acc]), []);</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">takeRightWhile([1, 2, 3, 4], n =&gt; n &lt; 3); // [3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const zip = (...arrays) =&gt; &#123;</span><br><span class="line">  const maxLength = Math.max(...arrays.map(x =&gt; x.length));</span><br><span class="line">  return Array.from(&#123; length: maxLength &#125;).map((_, i) =&gt; &#123;</span><br><span class="line">    return Array.from(&#123; length: arrays.length &#125;, (_, k) =&gt; arrays[k][i]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip([&apos;a&apos;, &apos;b&apos;], [1, 2], [true, false]); // [[&apos;a&apos;, 1, true], [&apos;b&apos;, 2, false]]</span><br><span class="line">zip([&apos;a&apos;], [1, 2], [true, false]); // [[&apos;a&apos;, 1, true], [undefined, 2, false]]</span><br></pre></td></tr></table></figure>

<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//单个参数</span><br><span class="line">const pipe = (...fns) =&gt; x =&gt; &#123;</span><br><span class="line">    return fns.reduceRight((v,fn)=&gt;&#123;</span><br><span class="line">       return fn(v);</span><br><span class="line">    &#125;,x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const square = v =&gt; v+1;</span><br><span class="line">const double = v =&gt; v+2;</span><br><span class="line">const addOne = v =&gt; v+3;</span><br><span class="line"></span><br><span class="line">const res = pipe(square,double,addOne);</span><br><span class="line">res(3)//9</span><br></pre></td></tr></table></figure>

<h3 id="elementIsVisibleInViewport"><a href="#elementIsVisibleInViewport" class="headerlink" title="elementIsVisibleInViewport"></a>elementIsVisibleInViewport</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; &#123;</span><br><span class="line">  const &#123; top, left, bottom, right &#125; = el.getBoundingClientRect();</span><br><span class="line">  const &#123; innerHeight, innerWidth &#125; = window;</span><br><span class="line">  return partiallyVisible</span><br><span class="line">    ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;</span><br><span class="line">        ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))</span><br><span class="line">    : top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elementIsVisibleInViewport(el); // false - (not fully visible)</span><br><span class="line">elementIsVisibleInViewport(el, true); // true - (partially visible)</span><br></pre></td></tr></table></figure>

<h3 id="聚合函数-2"><a href="#聚合函数-2" class="headerlink" title="聚合函数(2)"></a>聚合函数(2)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一个函数允许多个参数，剩余函数仅允许一个参数</span><br><span class="line">const composeRight = (...fns) =&gt; fns.reduce((f,g)=&gt;(...args)=&gt;g(f(...args)));</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const add =(x,y) =&gt; x+y;</span><br><span class="line">const square = x =&gt; x**2;</span><br><span class="line">const addAndSquare = composeRight(add,square);</span><br></pre></td></tr></table></figure>

<h3 id="uniqueSymmetricDifference"><a href="#uniqueSymmetricDifference" class="headerlink" title="uniqueSymmetricDifference"></a>uniqueSymmetricDifference</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const uniqueSymmetricDifference = (a, b) =&gt; [</span><br><span class="line">  ...new Set([...a.filter(v =&gt; !b.includes(v)), ...b.filter(v =&gt; !a.includes(v))])</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniqueSymmetricDifference([1, 2, 3], [1, 2, 4]); // [3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const size = val =&gt;</span><br><span class="line">    Array.isArray(val)</span><br><span class="line">        ? val.length</span><br><span class="line">        : val &amp;&amp; typeof val === &apos;object&apos;</span><br><span class="line">        ? val.size || val.length || Object.keys(val).length</span><br><span class="line">        : typeof val === &apos;string&apos;</span><br><span class="line">            ? new Blob([val]).size</span><br><span class="line">            : 0;</span><br></pre></td></tr></table></figure>

<h3 id="initialArrayWithRangeRight"><a href="#initialArrayWithRangeRight" class="headerlink" title="initialArrayWithRangeRight"></a>initialArrayWithRangeRight</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialArrayWithRangeRight = (end,start = 0, step = 1) =&gt; &#123;</span><br><span class="line">    return Array.from(&#123;length:Math.ceil(end-start+1)/step&#125;).map((v,i,arr)=&gt;&#123;</span><br><span class="line">        return (arr.length-i-1)*step+start;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initialArrayWithRangeRight(5)// [5,4,3,2,1,0]</span><br></pre></td></tr></table></figure>

<h3 id="创建加密hash"><a href="#创建加密hash" class="headerlink" title="创建加密hash"></a>创建加密hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hashBrowser = val =&gt;</span><br><span class="line">  crypto.subtle.digest(&apos;SHA-256&apos;, new TextEncoder(&apos;utf-8&apos;).encode(val)).then(h =&gt; &#123;</span><br><span class="line">    let hexes = [],</span><br><span class="line">      view = new DataView(h);</span><br><span class="line">    for (let i = 0; i &lt; view.byteLength; i += 4)</span><br><span class="line">      hexes.push((&apos;00000000&apos; + view.getUint32(i).toString(16)).slice(-8));</span><br><span class="line">    return hexes.join(&apos;&apos;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashBrowser(JSON.stringify(&#123; a: &apos;a&apos;, b: [1, 2, 3, 4], foo: &#123; c: &apos;bar&apos; &#125; &#125;)).then(console.log); // &apos;04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393&apos;</span><br></pre></td></tr></table></figure>

<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const triggerEvnet = (el,eventType,detail) =&gt; el.dispatchEvent(new CustomEvent(eventType,detail));</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">triggerEvnet(document.getElementById(&apos;id&apos;),&apos;click&apos;);//触发前需要先注册方法，addEventListener或者attachEvent</span><br></pre></td></tr></table></figure>

<h3 id="isWritableStream"><a href="#isWritableStream" class="headerlink" title="isWritableStream"></a>isWritableStream</h3><p>检查给定参数是否是可写的流体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isWriteable = val =&gt; val !== null &amp;&amp;</span><br><span class="line">  typeof val === &apos;object&apos; &amp;&amp;</span><br><span class="line">  typeof val.pipe === &apos;function&apos; &amp;&amp;</span><br><span class="line">  typeof val._write === &apos;function&apos; &amp;&amp;</span><br><span class="line">  typeof val._writableState === &apos;object&apos;;</span><br></pre></td></tr></table></figure>

<p>Node环境中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">isWritableStream(fs.createWriteStream(&apos;test.txt&apos;)); // true</span><br></pre></td></tr></table></figure>

<h3 id="打乱数组顺序"><a href="#打乱数组顺序" class="headerlink" title="打乱数组顺序"></a>打乱数组顺序</h3><p>洗牌算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const shuffle = (arr) =&gt; &#123;</span><br><span class="line">  let m = arr.length;</span><br><span class="line">  while(m)&#123;</span><br><span class="line">    const i = Math.floor(Math.random()*m--);</span><br><span class="line">    [arr[i],arr[m]] =[arr[m],arr[i]]; </span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅的书写方式</title>
    <url>/2019/10/27/usage-for-better/</url>
    <content><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//变量声明用let or const</span><br><span class="line">let a = 1;</span><br><span class="line">const b = 2;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="对象属性赋值"><a href="#对象属性赋值" class="headerlink" title="对象属性赋值"></a>对象属性赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getKey(key)&#123;</span><br><span class="line">  return `a key named $&#123;key&#125;`</span><br><span class="line">&#125;</span><br><span class="line">//使用动态属性作为键名，用计算后的属性</span><br><span class="line">const obj=&#123;</span><br><span class="line">  id:1,</span><br><span class="line">  name:&apos;John&apos;,</span><br><span class="line">  [getKey(&apos;enable&apos;)]:&apos;Tom&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="键名与键值的变量名相同，不需要写两遍"><a href="#键名与键值的变量名相同，不需要写两遍" class="headerlink" title="键名与键值的变量名相同，不需要写两遍"></a>键名与键值的变量名相同，不需要写两遍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const name = &apos;John&apos;;</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象数据分组排序"><a href="#对象数据分组排序" class="headerlink" title="对象数据分组排序"></a>对象数据分组排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//解构赋值的排前面</span><br><span class="line">const name = &apos;John&apos;,age=2, grade = 80;</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  level:grade</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//键名声明不需要写引号,仅有无效标识符需要加引号</span><br><span class="line">const obj = &#123;</span><br><span class="line">  a:1,</span><br><span class="line">  &apos;data-self:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要直接调用Object-prototype的方法，比如hasOwnProperty"><a href="#不要直接调用Object-prototype的方法，比如hasOwnProperty" class="headerlink" title="不要直接调用Object.prototype的方法，比如hasOwnProperty"></a>不要直接调用Object.prototype的方法，比如hasOwnProperty</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  a:1</span><br><span class="line">&#125;</span><br><span class="line">//不要直接用ojb.hasOwnProperty(Do not use obj.hasOwnProperty directly)</span><br><span class="line"></span><br><span class="line">Object.prototype.hasOwnProperty.call(obj,key)//use Object.prototype.call instead</span><br><span class="line">//or</span><br><span class="line">const has = Object.prototype.hasOwnProperty;</span><br><span class="line">has.call(obj,key)//</span><br></pre></td></tr></table></figure>

<h3 id="use-the-object-spread-operator-instead-of-Object-assign-to-shallow-copy-objects"><a href="#use-the-object-spread-operator-instead-of-Object-assign-to-shallow-copy-objects" class="headerlink" title="use the object spread operator instead of Object.assign to shallow-copy objects"></a>use the object spread operator instead of Object.assign to shallow-copy objects</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name:&apos;Tom&apos;</span><br><span class="line">&#125;</span><br><span class="line">const cloneObj =&#123;...obj,age:1&#125;//cloneObj -&gt; &#123;name:&apos;Tom&apos;,age:1&#125;</span><br></pre></td></tr></table></figure>

<h3 id="use-spread-operator-to-copy-Array"><a href="#use-spread-operator-to-copy-Array" class="headerlink" title="use spread operator to copy Array"></a>use spread operator to copy Array</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [1,2,3,4];</span><br><span class="line">const cloneArr = [...arr];//cloneArr - .[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h3 id="use-Array-from-or-spread-operator-to-convert-an-iterable-Object"><a href="#use-Array-from-or-spread-operator-to-convert-an-iterable-Object" class="headerlink" title="use Array.from() or spread operator to convert an iterable Object"></a>use Array.from() or spread operator to convert an iterable Object</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo = document.querySelectorAll(&apos;.foo&apos;);//it is a nodelist</span><br><span class="line"></span><br><span class="line">const arrNode = Array.from(foo);</span><br><span class="line"></span><br><span class="line">//or</span><br><span class="line"></span><br><span class="line">const arrNode1 = [...foo];</span><br></pre></td></tr></table></figure>

<h3 id="use-Array-from-instead-of-spread-operator-for-mapping-over-iterables-because-it-won’t-creat-an-intermediate-array"><a href="#use-Array-from-instead-of-spread-operator-for-mapping-over-iterables-because-it-won’t-creat-an-intermediate-array" class="headerlink" title="use Array.from() instead of spread operator  for mapping over iterables ,because it won’t creat an intermediate array"></a>use Array.from() instead of spread operator  for mapping over iterables ,because it won’t creat an intermediate array</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo =[1,2,3];</span><br><span class="line">const bar = Array.from(foo,function(item)&#123;</span><br><span class="line">  return Math.pow(item,2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="use-object-destructuring-when-accessing-and-using-multiple-properties-of-an-object"><a href="#use-object-destructuring-when-accessing-and-using-multiple-properties-of-an-object" class="headerlink" title="use object destructuring when accessing and using multiple properties of an object."></a>use object destructuring when accessing and using multiple properties of an object.</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//No</span><br><span class="line">const render = param =&gt; &#123;</span><br><span class="line">  const firstName = param.firstName;</span><br><span class="line">  const secondName = param.secondName;</span><br><span class="line">&#125;</span><br><span class="line">//Yes,and maybe we should give them default value,or if firstName or secondName dont exist in param , they will be undefined</span><br><span class="line">const render = param =&gt;&#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    firstName=&apos;&apos; ,secondName=&apos;&apos;</span><br><span class="line">  &#125; = param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="use-array-destructuring-instead-of-arr-0"><a href="#use-array-destructuring-instead-of-arr-0" class="headerlink" title="use array destructuring instead of arr[0]."></a>use array destructuring instead of arr[0].</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const render = param =&gt;&#123;</span><br><span class="line">  const [firstName,secondName] = param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="use-object-destructuring-if-u-dont-need-certaine-property"><a href="#use-object-destructuring-if-u-dont-need-certaine-property" class="headerlink" title="use object destructuring if u dont need certaine property"></a>use object destructuring if u dont need certaine property</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// if u dont need secondName,u can use object destructuring,and what u need exists in rest</span><br><span class="line">const render = param =&gt;&#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    secondName,...rest</span><br><span class="line">  &#125; =param//rest-&gt; &#123;firstName,age&#125;</span><br><span class="line">&#125;</span><br><span class="line">render(&#123;</span><br><span class="line">  firstName,</span><br><span class="line">  secondName,</span><br><span class="line">  age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="use-instead-of-‘’-or-“”"><a href="#use-instead-of-‘’-or-“”" class="headerlink" title="use `` instead of ‘’ or “”"></a>use `` instead of ‘’ or “”</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const name = &apos;John&apos;;</span><br><span class="line">//No</span><br><span class="line">const wholeName = &apos;My name is&apos;+ name;</span><br><span class="line">//Yes</span><br><span class="line">const wholeName = `my name is $&#123;name&#125;`</span><br></pre></td></tr></table></figure>

<h3 id="dont-declare-function-in-a-block-like-if-while-etc"><a href="#dont-declare-function-in-a-block-like-if-while-etc" class="headerlink" title="dont declare function in a block like if,while ,etc"></a>dont declare function in a block like if,while ,etc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//No</span><br><span class="line">if(true)&#123;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    console.log(&apos;bad&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Yes</span><br><span class="line">let test ;</span><br><span class="line">if(true)&#123;</span><br><span class="line">  test = () =&gt;&#123;</span><br><span class="line">    console.log(&apos;good&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="use-spread-operator-…-instead-of-arguments-because-arguments-is-a-Array-like-Array-and-not-a-real-Array"><a href="#use-spread-operator-…-instead-of-arguments-because-arguments-is-a-Array-like-Array-and-not-a-real-Array" class="headerlink" title="use spread operator(…) instead of arguments,because arguments is a Array-like Array and not a real Array"></a>use spread operator(…) instead of arguments,because arguments is a Array-like Array and not a real Array</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//No</span><br><span class="line">const render = arguments =&gt; &#123;</span><br><span class="line">  const arr = Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br><span class="line">//Yes</span><br><span class="line">const render =(...args) =&gt; &#123;</span><br><span class="line">  const arr = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="use-void-0-instead-of-undefined"><a href="#use-void-0-instead-of-undefined" class="headerlink" title="use void 0 instead of undefined"></a>use void 0 instead of undefined</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let undefined = 1;</span><br><span class="line">var a;</span><br><span class="line">console.log(a === undefined)// false</span><br><span class="line">console.log(a === void 0)//false</span><br></pre></td></tr></table></figure>

<h3 id="in-a-module-with-single-export-use-default-export-instead-of-name-export"><a href="#in-a-module-with-single-export-use-default-export-instead-of-name-export" class="headerlink" title="in a module with single export use default export instead of name export"></a>in a module with single export use default export instead of name export</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function es6()&#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>今日随笔</title>
    <url>/2020/08/15/vue-react-new-release/</url>
    <content><![CDATA[<p>react 更新了<br><img src="/images/update-of-frame/react.png" alt="react"></p>
<p>vue脚手架更新</p>
<p><img src="/images/update-of-frame/vue.jpeg" alt="vue"></p>
<p>来玩~</p>
]]></content>
      <categories>
        <category>vue</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>vuex</title>
    <url>/2020/04/28/vuex/</url>
    <content><![CDATA[<h2 id="vuex-简述"><a href="#vuex-简述" class="headerlink" title="vuex 简述"></a>vuex 简述</h2><p>vuex 本质上就是 vue 中的 mixin，store 在每个 vue 组建实例创建的时候通过 mixin 的方式注入的，mixin 就类似这样的格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const mixComponent = &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            message:<span class="string">'hello'</span>,</span><br><span class="line">            foo:<span class="string">'abc'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    mixins:[mixComponent],</span><br><span class="line">    <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            message:<span class="string">'goodbye'</span>,</span><br><span class="line">            bar:<span class="string">'def'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span></span>()&#123;</span><br><span class="line">        console.log(this.<span class="variable">$data</span>)</span><br><span class="line">        <span class="comment"># =&gt; &#123;message:'goodbye',foo:'abc',bar:'def'&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当组建和混入的 mixins 含有同名选项时，这些选项将会以适当的方式进行合并，比如 mixins 中的 data 和组建的 data 有同名属性时，那么将会以组建中的数据为准。当具有同名的钩子函数时，那么同名的钩子函数将会组成一个数组，它们都将被调用。另外，mixins 中的钩子函数将会在组件自身钩子之前调用。<br>值为对象的选项时，它们将会被合并为一个对象，k-v 冲突时，取组件中的 kv。<br>而 vuex 正是全局的 mixins，将会在每个组件 create 的时候注入</p>
<a id="more"></a>
<h3 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a><a href="https://cn.vuejs.org/v2/api/#Vue-use" target="_blank" rel="noopener">Vue.use</a></h3><p>可以看看官网对这个方法对介绍</p>
<ul>
<li><p>参数：</p>
<p>{Object | Function} plugin</p>
</li>
<li><p>用法：</p>
<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p>
<p>该方法需要在调用 new Vue() 之前被调用。</p>
<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>
</li>
<li><p>参考：<a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">插件</a></p>
</li>
</ul>
<p>然后看看源代码怎么实现的,在 vue 中，要想使用 vuex，那么肯定就要安装官方的 vuex 插件，然后在入口文件中调用 Vue.use(vuex)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> initUse (Vue) &#123;</span><br><span class="line">  Vue.use = <span class="keyword">function</span> (plugin) &#123;</span><br><span class="line">    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));</span><br><span class="line">    <span class="comment"># 如果已经存在，则直接返回this也就是Vue</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      <span class="built_in">return</span> this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># additional parameters</span></span><br><span class="line">    var args = toArray(arguments, 1);</span><br><span class="line">    <span class="comment"># 把 this（也就是Vue）作为数组的第一项</span></span><br><span class="line">    args.unshift(this);</span><br><span class="line">    <span class="comment"># 如果插件的install属性是函数,调用它</span></span><br><span class="line">    <span class="keyword">if</span> (typeof plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeof plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment"># 如果插件是函数,则调用它</span></span><br><span class="line">      <span class="comment"># apply(null) 严格模式下 plugin 插件函数的 this 就是 null</span></span><br><span class="line">      plugin.apply(null, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 添加到已安装的插件</span></span><br><span class="line">    installedPlugins.push(plugin);</span><br><span class="line">    <span class="built_in">return</span> this</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后康康 install 函数做了什么</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> install(_Vue)&#123;</span><br><span class="line">    <span class="comment"># Vue存在并且相等，说明已经执行过install了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(Vue &amp;&amp; _Vue === Vue)&#123;</span><br><span class="line">        //省略非生产环境报错代码</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _Vue</span><br><span class="line">    applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，继续看 applyMixin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> (Vue) &#123;</span><br><span class="line">  const version = Number(Vue.version.split(<span class="string">'.'</span>)[0])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= 2) &#123;</span><br><span class="line">    <span class="comment"># 合并选项后 beforeCreate 是数组里函数的形式  [func,  func]</span></span><br><span class="line">    <span class="comment"># 最后调用循环遍历这个数组，调用这些函数，这是一种函数与函数合并的解决方案。</span></span><br><span class="line">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      //兼容vue 1.x的代码，不管它</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Vuex init hook, injected into each instances init hooks list.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">vuexInit</span></span> () &#123;</span><br><span class="line">    <span class="comment"># console.log('vuexInit')</span></span><br><span class="line">    const options = this.<span class="variable">$options</span></span><br><span class="line">    <span class="comment"># 在调用vue.use装载vuex的时候，把这个方法注入到mixins中的beforeCreated中，因为同名钩子函数不会覆盖，会组成数组然后遍历执行</span></span><br><span class="line">    <span class="comment"># 这里的$options就是在初始化new Vuex.Store(options=&#123;&#125;)这个时候传进来的参数，这样混入之后每个组件都可以在this访问store对象</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">      console.log(<span class="string">'options.store'</span>)</span><br><span class="line">      this.<span class="variable">$store</span> = typeof options.store === <span class="string">'function'</span></span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.<span class="variable">$store</span>) &#123;</span><br><span class="line">      console.log(<span class="string">'options.parent.$store'</span>)</span><br><span class="line">      this.<span class="variable">$store</span> = options.parent.<span class="variable">$store</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来看生成 Store 的构造函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import applyMixin from <span class="string">'./mixin'</span></span><br><span class="line">import devtoolPlugin from <span class="string">'./plugins/devtool'</span></span><br><span class="line">import ModuleCollection from <span class="string">'./module/module-collection'</span></span><br><span class="line">import &#123; forEachValue, isObject, isPromise, assert, partial &#125; from <span class="string">'./util'</span></span><br><span class="line"><span class="built_in">let</span> Vue</span><br></pre></td></tr></table></figure>

<p>首先是引入文件，applyMixin 之前有说，然后是 devtoolPlugin，看名字猜应该是 vue-devtool 有关，pass，然后是一些封装的工具函数，看一下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 条件断言，不满足条件抛出错误</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> assert (condition, msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) throw new Error(`[vuex] <span class="variable">$&#123;msg&#125;</span>`)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 返回一个新的函数</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> partial(fn,arg)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> fn(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 判断promise，但是这个判断方法是不严谨的，假设我现在有一个object =&gt; const obj =&#123;then()&#123;&#125;&#125;,obj它是一个对象，它也拥有then方法，但是它其实不是一个promise</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isPromise(val)&#123;</span><br><span class="line">    <span class="built_in">return</span> val &amp;&amp; typeof val.then === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 这个方法不仅仅用来判断是否是object，同时还有date，regexp，array</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isObject(val)&#123;</span><br><span class="line">    <span class="built_in">return</span> obj!==null &amp;&amp; typeof val === <span class="string">'object'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 统一成对象风格</span></span><br><span class="line"><span class="keyword">function</span> unifyObjectStyle (<span class="built_in">type</span>, payload, options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isObject(<span class="built_in">type</span>) &amp;&amp; type.type) &#123;</span><br><span class="line">    options = payload</span><br><span class="line">    payload = <span class="built_in">type</span></span><br><span class="line">    <span class="built_in">type</span> = type.type</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># type不是字符串类型，非生产环境报错</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assert(typeof <span class="built_in">type</span> === <span class="string">'string'</span>, `expects string as the <span class="built_in">type</span>, but found <span class="variable">$&#123;typeof type&#125;</span>.`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> &#123; <span class="built_in">type</span>, payload, options &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个应该是以闭包的形式返回一个新函数<br>然后全局声明一个 Vue 变量，打一下断点我们可以发现 Vue 储存的其实是一个 function<br>然后看正文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> class Store &#123;</span><br><span class="line">  constructor (options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment"># Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">    <span class="comment"># To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">    <span class="comment"># this code should be placed here. See #731</span></span><br><span class="line">    <span class="comment"># 如果是 cdn script 引入vuex插件，则自动安装vuex插件，不需要用Vue.use(Vuex)来安装</span></span><br><span class="line">    <span class="keyword">if</span> (!Vue &amp;&amp; typeof window !== <span class="string">'undefined'</span> &amp;&amp; window.Vue) &#123;</span><br><span class="line">      install(window.Vue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment"># 必须使用Vue.use(Vuex) 创建 store 实例</span></span><br><span class="line">      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)</span><br><span class="line">      <span class="comment"># 当前环境不支持Promise，报错：vuex需要Promise polyfill</span></span><br><span class="line">      assert(typeof Promise !== <span class="string">'undefined'</span>, `vuex requires a Promise polyfill <span class="keyword">in</span> this browser.`)</span><br><span class="line">      <span class="comment"># Store 函数必须使用new操作符调用</span></span><br><span class="line">      assert(this instanceof Store, `store must be called with the new operator.`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123;</span><br><span class="line">      <span class="comment"># 插件默认是空数组</span></span><br><span class="line">      plugins = [],</span><br><span class="line">      <span class="comment"># 严格模式默认是false</span></span><br><span class="line">      strict = <span class="literal">false</span></span><br><span class="line">    &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="comment"># store internal state</span></span><br><span class="line">    <span class="comment"># store 实例对象 内部的 state</span></span><br><span class="line">    this._committing = <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 用来存放处理后的用户自定义的actoins</span></span><br><span class="line">    <span class="comment"># Object.create生成的实例是不会有原型链这种东西的</span></span><br><span class="line">    this._actions = Object.create(null)</span><br><span class="line">    <span class="comment"># 用来存放 actions 订阅</span></span><br><span class="line">    this._actionSubscribers = []</span><br><span class="line">    <span class="comment"># 用来存放处理后的用户自定义的mutations</span></span><br><span class="line">    this._mutations = Object.create(null)</span><br><span class="line">    <span class="comment"># 用来存放处理后的用户自定义的 getters</span></span><br><span class="line">    this._wrappedGetters = Object.create(null)</span><br><span class="line">    <span class="comment"># 模块收集器，构造模块树形结构</span></span><br><span class="line">    this._modules = new ModuleCollection(options)</span><br><span class="line">    /<span class="comment">#用于存储模块命名空间的关系</span></span><br><span class="line">    this._modulesNamespaceMap = Object.create(null)</span><br><span class="line">    <span class="comment"># 订阅</span></span><br><span class="line">    this._subscribers = []</span><br><span class="line">     <span class="comment"># 用于使用 $watch 观测 getters</span></span><br><span class="line">    this._watcherVM = new Vue()</span><br><span class="line">     <span class="comment"># 用来存放生成的本地 getters 的缓存</span></span><br><span class="line">    this._makeLocalGettersCache = Object.create(null)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#bind commit and dispatch to self</span></span><br><span class="line">     <span class="comment"># 给自己 绑定 commit 和 dispatch</span></span><br><span class="line">    const store = this</span><br><span class="line">    const &#123; dispatch, commit &#125; = this</span><br><span class="line">    <span class="comment"># 为何要这样绑定 ?</span></span><br><span class="line">    <span class="comment"># 说明调用commit和dispach 的 this 不一定是 store 实例</span></span><br><span class="line">    <span class="comment"># 这是确保这两个函数里的this是store实例</span></span><br><span class="line">    this.dispatch = <span class="keyword">function</span> boundDispatch (<span class="built_in">type</span>, payload) &#123;</span><br><span class="line">      <span class="built_in">return</span> dispatch.call(store, <span class="built_in">type</span>, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    this.commit = <span class="keyword">function</span> boundCommit (<span class="built_in">type</span>, payload, options) &#123;</span><br><span class="line">      <span class="built_in">return</span> commit.call(store, <span class="built_in">type</span>, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># strict mode</span></span><br><span class="line">    this.strict = strict</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根模块的state</span></span><br><span class="line">    const state = this._modules.root.state</span><br><span class="line"></span><br><span class="line">    <span class="comment"># init root module.</span></span><br><span class="line">    <span class="comment"># this also recursively registers all sub-modules</span></span><br><span class="line">    <span class="comment"># and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">    <span class="comment"># 初始化 根模块</span></span><br><span class="line">    <span class="comment"># 并且也递归的注册所有子模块</span></span><br><span class="line">    <span class="comment"># 并且收集所有模块的 getters 放在 this._wrappedGetters 里面</span></span><br><span class="line">    installModule(this, state, [], this._modules.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line">    <span class="comment"># (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">    <span class="comment"># 初始化 store._vm 响应式的</span></span><br><span class="line">    <span class="comment"># 并且注册 _wrappedGetters 作为 computed 的属性</span></span><br><span class="line">    resetStoreVM(this, state)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># apply plugins</span></span><br><span class="line">    <span class="comment"># 把实例store传给插件函数，执行所有插件</span></span><br><span class="line">    plugins.forEach(plugin =&gt; plugin(this))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化 vue-devtool 开发工具</span></span><br><span class="line">    <span class="comment"># 参数 devtools 传递了取 devtools 否则取Vue.config.devtools 配置</span></span><br><span class="line">    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools</span><br><span class="line">    <span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">      devtoolPlugin(this)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 省略方法</span></span><br><span class="line">    <span class="comment"># Vue.Store本地commit dispatch</span></span><br><span class="line">    commit(_type,_payload,_options)&#123;</span><br><span class="line">        <span class="comment">#代码跟之前注册的时候类似</span></span><br><span class="line">        const &#123;</span><br><span class="line">            <span class="built_in">type</span>,</span><br><span class="line">            payload,</span><br><span class="line">            options</span><br><span class="line">        &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">        const mutation = &#123; <span class="built_in">type</span>, payload &#125;</span><br><span class="line">        <span class="comment"># 取出处理后的用户定义 mutation</span></span><br><span class="line">        const entry = this._mutations[<span class="built_in">type</span>]</span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">                console.error(`[vuex] unknown mutation <span class="built_in">type</span>: <span class="variable">$&#123;type&#125;</span>`)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        this._withCommit(() =&gt; &#123;</span><br><span class="line">            entry.forEach(<span class="keyword">function</span> commitIterator (handler) &#123;</span><br><span class="line">                <span class="comment"># 这里会跳到之前注册时的函数所绑定的新函数格式</span></span><br><span class="line">                handler(payload)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this._subscribers.forEach(sub =&gt; sub(mutation, this.state))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">            options &amp;&amp; options.silent</span><br><span class="line">        ) &#123;</span><br><span class="line">            console.warn(</span><br><span class="line">                `[vuex] mutation <span class="built_in">type</span>: <span class="variable">$&#123;type&#125;</span>. Silent option has been removed. ` +</span><br><span class="line">                <span class="string">'Use the filter functionality in the vue-devtools'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    dispatch (_type, _payload) &#123;</span><br><span class="line">        <span class="comment"># check object-style dispatch</span></span><br><span class="line">        <span class="comment"># 获取到type和payload参数</span></span><br><span class="line">        const &#123;</span><br><span class="line">            <span class="built_in">type</span>,</span><br><span class="line">            payload</span><br><span class="line">        &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 声明 action 变量 等于 type和payload参数</span></span><br><span class="line">        const action = &#123; <span class="built_in">type</span>, payload &#125;</span><br><span class="line">        <span class="comment"># 入口，也就是 _actions 集合</span></span><br><span class="line">        const entry = this._actions[<span class="built_in">type</span>]</span><br><span class="line">        <span class="comment"># 如果不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="comment"># 非生产环境报错，匹配不到 action 类型</span></span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">                console.error(`[vuex] unknown action <span class="built_in">type</span>: <span class="variable">$&#123;type&#125;</span>`)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment"># 不往下执行</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this._actionSubscribers</span><br><span class="line">                .filter(sub =&gt; sub.before)</span><br><span class="line">                .forEach(sub =&gt; sub.before(action, this.state))</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">                console.warn(`[vuex] error <span class="keyword">in</span> before action subscribers: `)</span><br><span class="line">                console.error(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const result = entry.length &gt; 1</span><br><span class="line">        ? Promise.all(entry.map(handler =&gt; handler(payload)))</span><br><span class="line">        : entry[0](payload)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> result.then(res =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                this._actionSubscribers</span><br><span class="line">                .filter(sub =&gt; sub.after)</span><br><span class="line">                .forEach(sub =&gt; sub.after(action, this.state))</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">                console.warn(`[vuex] error <span class="keyword">in</span> after action subscribers: `)</span><br><span class="line">                console.error(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> res</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK,康康 installModule 怎么执行的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注册在命名空间的map对象中。</span></span><br><span class="line"><span class="comment"># 模块命名控件为 true 执行以下代码</span></span><br><span class="line"><span class="comment"># 主要用于在 helpers 辅助函数，根据命名空间获取模块</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">function</span> getModuleByNamespace (store, helper, namespace) &#123;</span><br><span class="line">      <span class="comment"># _modulesNamespaceMap 这个变量在 class Store 中</span></span><br><span class="line">      const module = store._modulesNamespaceMap[namespace]</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !module) &#123;</span><br><span class="line">        console.error(`[vuex] module namespace not found <span class="keyword">in</span> <span class="variable">$&#123;helper&#125;</span>(): <span class="variable">$&#123;namespace&#125;</span>`)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> module</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取命名空间</span></span><br><span class="line"><span class="keyword">function</span> getNamespace (path) &#123;</span><br><span class="line">      <span class="built_in">let</span> module = this.root；</span><br><span class="line">      <span class="built_in">return</span> path.reduce((namespace, key) =&gt; &#123;</span><br><span class="line">        module = module.getChild(key)</span><br><span class="line">        <span class="built_in">return</span> namespace + (module.namespaced ? key + <span class="string">'/'</span> : <span class="string">''</span>)</span><br><span class="line">      &#125;, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 根据路径来获取嵌套的state</span></span><br><span class="line"><span class="keyword">function</span> getNestedState(state,path)&#123;</span><br><span class="line">    <span class="built_in">return</span> path.length ? path.reduce((state,key)=&gt;state[key],state):state</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> installModule (store, rootState, path, module, hot) &#123;</span><br><span class="line">  <span class="comment"># 是根模块</span></span><br><span class="line">  const isRoot = !path.length</span><br><span class="line">  <span class="comment"># 获取命名空间</span></span><br><span class="line">  const namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (module.namespaced) &#123;</span><br><span class="line">    <span class="comment"># 模块命名空间map对象中已经有了，开发环境报错提示重复</span></span><br><span class="line">    <span class="keyword">if</span> (store._modulesNamespaceMap[namespace] &amp;&amp; process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      console.error(`[vuex] duplicate namespace <span class="variable">$&#123;namespace&#125;</span> <span class="keyword">for</span> the namespaced module <span class="variable">$&#123;path.join('/')&#125;</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># module 赋值给 _modulesNamespaceMap[namespace]</span></span><br><span class="line">    store._modulesNamespaceMap[namespace] = module</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># set state</span></span><br><span class="line">  <span class="comment"># 不是根模块且不是热重载</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="comment"># 获取父级的state</span></span><br><span class="line">    const parentState = getNestedState(rootState, path.slice(0, -1))</span><br><span class="line">    <span class="comment"># 模块名称</span></span><br><span class="line">    <span class="comment"># 比如 cart</span></span><br><span class="line">    const moduleName = path[path.length - 1]</span><br><span class="line">    <span class="comment"># state 注册</span></span><br><span class="line">    store._withCommit(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">          console.warn(</span><br><span class="line">            `[vuex] state field <span class="string">"<span class="variable">$&#123;moduleName&#125;</span>"</span> was overridden by a module with the same name at <span class="string">"<span class="variable">$&#123;path.join('.')&#125;</span>"</span>`</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 最后得到的是类似这样的结构且是响应式的数据 比如</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Store实例：&#123;</span></span><br><span class="line">        <span class="comment"># 省略若干属性和方法</span></span><br><span class="line">        <span class="comment"># 这里的state是只读属性 可搜索 get state 查看</span></span><br><span class="line">        <span class="comment"># state: &#123;</span></span><br><span class="line">        <span class="comment">#   cart: &#123;</span></span><br><span class="line">        <span class="comment">#     checkoutStatus: null,</span></span><br><span class="line">        <span class="comment">#     items: []</span></span><br><span class="line">        <span class="comment">#    &#125;</span></span><br><span class="line">        <span class="comment">#   &#125;</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">      Vue.set(parentState, moduleName, module.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># module.context  这个赋值主要是给 helpers 中 mapState、mapGetters、mapMutations、mapActions四个辅助函数使用的。</span></span><br><span class="line">  <span class="comment"># 生成本地的dispatch、commit、getters和state</span></span><br><span class="line">  <span class="comment">#  主要作用就是抹平差异化，不需要用户再传模块参数</span></span><br><span class="line">  const <span class="built_in">local</span> = module.context = makeLocalContext(store, namespace, path)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 循环遍历注册mutation</span></span><br><span class="line">  module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">    const namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, <span class="built_in">local</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 循环遍历注册 action</span></span><br><span class="line">  module.forEachAction((action, key) =&gt; &#123;</span><br><span class="line">    const <span class="built_in">type</span> = action.root ? key : namespace + key</span><br><span class="line">    const handler = action.handler || action</span><br><span class="line">    registerAction(store, <span class="built_in">type</span>, handler, <span class="built_in">local</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 循环遍历注册 getter</span></span><br><span class="line">  module.forEachGetter((getter, key) =&gt; &#123;</span><br><span class="line">    const namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, <span class="built_in">local</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 注册子模块</span><br><span class="line">   * forEachChild (fn) &#123;</span><br><span class="line">        forEachValue(this._children, fn)</span><br><span class="line">      &#125;</span><br><span class="line">   */</span><br><span class="line">  module.forEachChild((child, key) =&gt; &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> makeLocalContext(store,namespace,path)&#123;</span><br><span class="line">    <span class="comment"># 判断是否有命名空间生成</span></span><br><span class="line">    const noNamespace = namespace === <span class="string">''</span></span><br><span class="line">    <span class="comment"># 如果没有命名空间。那么就直接用store的dispatch</span></span><br><span class="line">    const <span class="built_in">local</span> = &#123;</span><br><span class="line">        dispatch: noNamespace ?store.dispatch :(_type,_payload,_options)=&gt;&#123;</span><br><span class="line">            <span class="comment"># 这步是为了抹平差异化，因为调用方式可以是 dispatch(type,payload)，也可以是dispatch(&#123;type,payload,options&#125;),所以这里需要做一个函数来形成统一的风格</span></span><br><span class="line">            const args = unifyObjectstyle(_type,_payload,_options)</span><br><span class="line"></span><br><span class="line">            const &#123;payload,options&#125; = args</span><br><span class="line"></span><br><span class="line">            <span class="built_in">let</span> &#123;<span class="built_in">type</span>&#125; = args</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!options|| options.root)&#123;</span><br><span class="line">                <span class="built_in">type</span> = namespace + <span class="built_in">type</span></span><br><span class="line">                <span class="keyword">if</span>(’生产环境‘)&#123;</span><br><span class="line">                    <span class="comment"># 省略非生产环境报错代码</span></span><br><span class="line">                    <span class="built_in">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> store.dispatch(<span class="built_in">type</span>,payload)</span><br><span class="line">        &#125;,</span><br><span class="line">        commit:noNamespace?store.commit:(_type,_payload,_options)=&gt;&#123;</span><br><span class="line">            const args = unifyObjectstyle(_type,_payload,_options)</span><br><span class="line"></span><br><span class="line">            const &#123;payload,options&#125; = args</span><br><span class="line"></span><br><span class="line">            <span class="built_in">let</span> &#123;<span class="built_in">type</span>&#125; = args</span><br><span class="line">            <span class="keyword">if</span>(!options|| options.root)&#123;</span><br><span class="line">                <span class="built_in">type</span> = namespace + <span class="built_in">type</span></span><br><span class="line">                <span class="keyword">if</span>(’生产环境‘)&#123;</span><br><span class="line">                    <span class="comment"># 省略非生产环境报错代码</span></span><br><span class="line">                    <span class="built_in">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> store.commit(<span class="built_in">type</span>,payload,options)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># getters  和 states 必须是懒加载 ，因为 它们会被实例的update修改</span></span><br><span class="line">    Object.defineProperties(<span class="built_in">local</span>, &#123;</span><br><span class="line">        getters: &#123;</span><br><span class="line">        <span class="comment"># 没有命名空间，直接取值 store.getters</span></span><br><span class="line">        get: noNamespace</span><br><span class="line">            ? () =&gt; store.getters</span><br><span class="line">            <span class="comment"># 否则</span></span><br><span class="line">            : () =&gt; makeLocalGetters(store, namespace)</span><br><span class="line">        &#125;,</span><br><span class="line">        state: &#123;</span><br><span class="line">            get: () =&gt; getNestedState(store.state, path)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">local</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makeLocalGetters</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> makeLocalGetters (store, namespace) &#123;</span><br><span class="line">  <span class="comment"># _makeLocalGettersCache 缓存是vuex v3.1.2中 加的</span></span><br><span class="line">  <span class="comment"># 如果不存在getters本地缓存中不存在，才执行下面的代码</span></span><br><span class="line">  <span class="comment"># 如果存在直接返回</span></span><br><span class="line">  <span class="comment"># return store._makeLocalGettersCache[namespace]</span></span><br><span class="line">  <span class="keyword">if</span> (!store._makeLocalGettersCache[namespace]) &#123;</span><br><span class="line">    <span class="comment"># 声明 gettersProxy对象</span></span><br><span class="line">    const gettersProxy = &#123;&#125;</span><br><span class="line">    <span class="comment"># 命名空间 长度</span></span><br><span class="line">    const splitPos = namespace.length</span><br><span class="line">    Object.keys(store.getters).forEach(<span class="built_in">type</span> =&gt; &#123;</span><br><span class="line">      <span class="comment"># skip if the target getter is not match this namespace</span></span><br><span class="line">      <span class="comment"># 如果目标getters没有匹配到命名空间直接跳过</span></span><br><span class="line">      <span class="keyword">if</span> (type.slice(0, splitPos) !== namespace) <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># extract local getter type</span></span><br><span class="line">      <span class="comment"># 提取本地type</span></span><br><span class="line">      const localType = type.slice(splitPos)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Add a port to the getters proxy.</span></span><br><span class="line">      <span class="comment"># Define as getter property because</span></span><br><span class="line">      <span class="comment"># we do not want to evaluate the getters in this time.</span></span><br><span class="line">      <span class="comment"># 添加一个代理</span></span><br><span class="line">      <span class="comment"># 定义getters 属性</span></span><br><span class="line">      <span class="comment"># 因为我们现在不想计算getters</span></span><br><span class="line">      Object.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">        get: () =&gt; store.getters[<span class="built_in">type</span>],</span><br><span class="line">        <span class="comment"># 可以枚举</span></span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 赋值</span></span><br><span class="line">    store._makeLocalGettersCache[namespace] = gettersProxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果存在直接返回</span></span><br><span class="line">  <span class="built_in">return</span> store._makeLocalGettersCache[namespace]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 mutations</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> registerMutation (store, <span class="built_in">type</span>, handler, <span class="built_in">local</span>) &#123;</span><br><span class="line">  <span class="comment"># 收集的所有的mutations找对应的mutation函数，没有就赋值空数组</span></span><br><span class="line">  const entry = store._mutations[<span class="built_in">type</span>] || (store._mutations[<span class="built_in">type</span>] = [])</span><br><span class="line">  <span class="comment"># 最后 mutation</span></span><br><span class="line">  entry.push(<span class="keyword">function</span> wrappedMutationHandler (payload) &#123;</span><br><span class="line">    <span class="comment"># 所以这就是为什么当我们调用mutation函数的时候仅需要传递一个参数，而函数体的参数列表的第一个参数却不是我们所传递的参数，而是state的原因</span></span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 action</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> registerAction (store, <span class="built_in">type</span>, handler, <span class="built_in">local</span>) &#123;</span><br><span class="line">  const entry = store._actions[<span class="built_in">type</span>] || (store._actions[<span class="built_in">type</span>] = [])</span><br><span class="line">  /<span class="comment"># payload 是actions函数的第二个参数</span></span><br><span class="line">  entry.push(<span class="keyword">function</span> wrappedActionHandler (payload) &#123;</span><br><span class="line">      <span class="comment"># 所以这就是为什么调用action的时候第一个参数不是state，而不是store对象</span></span><br><span class="line">    <span class="built_in">let</span> res = handler.call(store, &#123;</span><br><span class="line">      dispatch: local.dispatch,</span><br><span class="line">      commit: local.commit,</span><br><span class="line">      getters: local.getters,</span><br><span class="line">      state: local.state,</span><br><span class="line">      rootGetters: store.getters,</span><br><span class="line">      rootState: store.state</span><br><span class="line">    &#125;, payload)</span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = Promise.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># devtool 工具触发 vuex:error</span></span><br><span class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</span><br><span class="line">      <span class="comment"># catch 捕获错误</span></span><br><span class="line">      <span class="built_in">return</span> res.catch(err =&gt; &#123;</span><br><span class="line">        store._devtoolHook.emit(<span class="string">'vuex:error'</span>, err)</span><br><span class="line">        <span class="comment"># 抛出错误</span></span><br><span class="line">        throw err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># 然后函数执行结果</span></span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 getters</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注解略，都差不多逻辑</span></span><br><span class="line"><span class="keyword">function</span> registerGetter (store, <span class="built_in">type</span>, rawGetter, <span class="built_in">local</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[<span class="built_in">type</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      console.error(`[vuex] duplicate getter key: <span class="variable">$&#123;type&#125;</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  store._wrappedGetters[<span class="built_in">type</span>] = <span class="keyword">function</span> wrappedGetter (store) &#123;</span><br><span class="line">    <span class="built_in">return</span> rawGetter(</span><br><span class="line">      local.state, <span class="comment"># local state</span></span><br><span class="line">      local.getters, <span class="comment"># local getters</span></span><br><span class="line">      store.state, <span class="comment"># root state</span></span><br><span class="line">      store.getters <span class="comment"># root getters</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resetStoreVM</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个方法让store变成一个响应式的vue实例</span></span><br><span class="line"><span class="keyword">function</span> resetStoreVM (store, state, hot) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 存储一份老的Vue实例对象 _vm</span></span><br><span class="line">  const oldVm = store._vm</span><br><span class="line"></span><br><span class="line">  <span class="comment"># bind store public getters</span></span><br><span class="line">  <span class="comment"># 绑定 store.getter</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="comment"># reset local getters cache</span></span><br><span class="line">  <span class="comment"># 重置 本地getters的缓存</span></span><br><span class="line">  store._makeLocalGettersCache = Object.create(null)</span><br><span class="line">  <span class="comment"># 注册时收集的处理后的用户自定义的 wrappedGetters</span></span><br><span class="line">  const wrappedGetters = store._wrappedGetters</span><br><span class="line">  <span class="comment"># 声明 计算属性 computed 对象</span></span><br><span class="line">  const computed = &#123;&#125;</span><br><span class="line">  <span class="comment"># 遍历 wrappedGetters 赋值到 computed 上</span></span><br><span class="line">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    <span class="comment"># use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    <span class="comment"># direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">    <span class="comment"># using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">    computed[key] = partial(fn, store)</span><br><span class="line">    <span class="comment"># getter 赋值 keys</span></span><br><span class="line">    Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">      get: () =&gt; store._vm[key],</span><br><span class="line">      enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># use a Vue instance to store the state tree</span></span><br><span class="line">  <span class="comment"># suppress warnings just in case the user has added</span></span><br><span class="line">  <span class="comment"># some funky global mixins</span></span><br><span class="line">  <span class="comment"># 使用一个 Vue 实例对象存储 state 树</span></span><br><span class="line">  <span class="comment"># 阻止警告 用户添加的一些全局mixins</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 声明变量 silent 存储用户设置的静默模式配置</span></span><br><span class="line">  const silent = Vue.config.silent</span><br><span class="line">  <span class="comment"># 静默模式开启</span></span><br><span class="line">  Vue.config.silent = <span class="literal">true</span></span><br><span class="line">  store._vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $<span class="variable">$state</span>: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment"># 把存储的静默模式配置赋值回来</span></span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  <span class="comment"># enable strict mode for new vm</span></span><br><span class="line">  <span class="comment"># 开启严格模式 执行这句</span></span><br><span class="line">  <span class="comment"># 用$watch 观测 state，只能使用 mutation 修改 也就是 _withCommit 函数</span></span><br><span class="line">  <span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果存在老的 _vm 实例</span></span><br><span class="line">  <span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">    <span class="comment"># 热加载为 true</span></span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">#dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">#to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      <span class="comment">#设置  oldVm._data.$$state = null</span></span><br><span class="line">      store._withCommit(() =&gt; &#123;</span><br><span class="line">        oldVm._data.$<span class="variable">$state</span> = null</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 实例销毁</span></span><br><span class="line">    Vue.nextTick(() =&gt; oldVm.<span class="variable">$destroy</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> const mapState = normalizeNamespace((namespace, states) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  <span class="comment"># 非生产环境 判断参数 states  必须是数组或者是对象</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !isValidMap(states)) &#123;</span><br><span class="line">    console.error(<span class="string">'[vuex] mapState: mapper parameter must be either an Array or an Object'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment"># normalizeMap 最终都是返回数组 [ &#123; key, val &#125; ] 形式</span></span><br><span class="line">   <span class="comment"># normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ]</span></span><br><span class="line">   <span class="comment"># normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ]</span></span><br><span class="line"></span><br><span class="line">  normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">    res[key] = <span class="keyword">function</span> <span class="function"><span class="title">mappedState</span></span> () &#123;</span><br><span class="line">      <span class="built_in">let</span> state = this.<span class="variable">$store</span>.state</span><br><span class="line">      <span class="built_in">let</span> getters = this.<span class="variable">$store</span>.getters</span><br><span class="line">      <span class="comment"># 传了参数 namespace</span></span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="comment"># 用 namespace 从 store 中找一个模块。</span></span><br><span class="line">        const module = getModuleByNamespace(this.<span class="variable">$store</span>, <span class="string">'mapState'</span>, namespace)</span><br><span class="line">        <span class="keyword">if</span> (!module) &#123;</span><br><span class="line">          <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        state = module.context.state</span><br><span class="line">        getters = module.context.getters</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> typeof val === <span class="string">'function'</span></span><br><span class="line">        ? val.call(this, state, getters)</span><br><span class="line">        : state[val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 标记为 vuex 方便在 devtools 显示</span></span><br><span class="line">    <span class="comment"># mark vuex getter for devtools</span></span><br><span class="line">    res[key].vuex = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>看了下剩下的几个map，逻辑都一样，就是return都时候做下修改就好，那就这样啦<br>Done！</p>
<p>——- 更新 2020.6.26<br>害 ，发现vuex更新到vuex4了，然后我看了一下，有个东西改了，人家不用mixin来注入store这东西了哈，人家用provide和inject来注入store了<br><a href="https://github.com/vuejs/vuex/blob/4.0/src/store.js">代码</a></p>
<h4 id="看下简单的示例代码"><a href="#看下简单的示例代码" class="headerlink" title="看下简单的示例代码"></a>看下简单的示例代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from <span class="string">'vue'</span></span><br><span class="line">import Counter from <span class="string">'./Counter.vue'</span></span><br><span class="line">import store from <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">const app = createApp(Counter)</span><br><span class="line">console.log(<span class="string">'app is created'</span>)</span><br><span class="line">app.use(store)</span><br><span class="line">console.log(<span class="string">'store is used'</span>)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>在调用app.use方法的时候用调用注入plugin的install方法<br>（如果install方法存在的话），看下use方法怎么写的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use(plugin, ...options) &#123;</span><br><span class="line">         <span class="keyword">if</span> (installedPlugins.has(plugin)) &#123;</span><br><span class="line">             (process.env.NODE_ENV !== <span class="string">'production'</span>) &amp;&amp; warn(`Plugin has already been applied to target app.`);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (plugin &amp;&amp; isFunction(plugin.install)) &#123;</span><br><span class="line">             installedPlugins.add(plugin);</span><br><span class="line">             plugin.install(app, ...options);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(plugin)) &#123;</span><br><span class="line">             installedPlugins.add(plugin);</span><br><span class="line">             plugin(app, ...options);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">'production'</span>)) &#123;</span><br><span class="line">             warn(`A plugin must either be a <span class="keyword">function</span> or an object with an <span class="string">"install"</span> ` +</span><br><span class="line">                 `<span class="keyword">function</span>.`);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">return</span> app;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure>

<p>然后看下vuex中的install方法怎么写的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">install (app, injectKey) &#123;</span><br><span class="line">    app.provide(injectKey || storeKey, this)</span><br><span class="line">    app.config.globalProperties.<span class="variable">$store</span> = this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显得看出是把store放到provide中实行了，并且因为在调用的时候是用的<code>plugin.install(app)</code>的方法来写的，所以这个时候的this指向的是store实例，这样就可以把store实例注入到app实例中了 ，这样写的好处我觉得就是数据来源更清晰了吧。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
