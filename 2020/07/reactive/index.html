<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fnlearner.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言vue3 出了 beta，了解一下响应式数据的实现 正文reactive下面这些是在 reactive 中导入的外部文件 123456789101112131415import &amp;#123; isObject, toRawType, def, hasOwn, makeMap &amp;#125; from &apos;@vue/shared&apos;##这些都是通用方法## 两个handler，待会儿说为啥import">
<meta name="keywords" content="TypeScript,Vue3">
<meta property="og:type" content="article">
<meta property="og:title" content="响应式模块">
<meta property="og:url" content="https://fnlearner.github.io/2020/07/reactive/index.html">
<meta property="og:site_name" content="Personal Blog">
<meta property="og:description" content="前言vue3 出了 beta，了解一下响应式数据的实现 正文reactive下面这些是在 reactive 中导入的外部文件 123456789101112131415import &amp;#123; isObject, toRawType, def, hasOwn, makeMap &amp;#125; from &apos;@vue/shared&apos;##这些都是通用方法## 两个handler，待会儿说为啥import">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://fnlearner.github.io/images/reactive/code3.png">
<meta property="og:image" content="https://fnlearner.github.io/images/reactive/code5.png">
<meta property="og:image" content="https://fnlearner.github.io/images/reactive/code6.png">
<meta property="og:image" content="https://fnlearner.github.io/images/reactive/code7.png">
<meta property="og:updated_time" content="2020-10-07T09:41:15.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="响应式模块">
<meta name="twitter:description" content="前言vue3 出了 beta，了解一下响应式数据的实现 正文reactive下面这些是在 reactive 中导入的外部文件 123456789101112131415import &amp;#123; isObject, toRawType, def, hasOwn, makeMap &amp;#125; from &apos;@vue/shared&apos;##这些都是通用方法## 两个handler，待会儿说为啥import">
<meta name="twitter:image" content="https://fnlearner.github.io/images/reactive/code3.png">

<link rel="canonical" href="https://fnlearner.github.io/2020/07/reactive/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>响应式模块 | Personal Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Personal Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fnlearner.github.io/2020/07/reactive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="ZJS">
      <meta itemprop="description" content="你找到我了呀！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Personal Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          响应式模块
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-09 11:23:04" itemprop="dateCreated datePublished" datetime="2020-07-09T11:23:04+08:00">2020-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-07 17:41:15" itemprop="dateModified" datetime="2020-10-07T17:41:15+08:00">2020-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript/" itemprop="url" rel="index"><span itemprop="name">TypeScript</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript/Vue3/" itemprop="url" rel="index"><span itemprop="name">Vue3</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue3 出了 beta，了解一下响应式数据的实现</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p>下面这些是在 reactive 中导入的外部文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isObject, toRawType, def, hasOwn, makeMap &#125; from <span class="string">'@vue/shared'</span><span class="comment">##这些都是通用方法</span></span><br><span class="line"><span class="comment">## 两个handler，待会儿说为啥</span></span><br><span class="line">import &#123;</span><br><span class="line">  mutableHandlers,</span><br><span class="line">  readonlyHandlers,</span><br><span class="line">  shallowReactiveHandlers,</span><br><span class="line">  shallowReadonlyHandlers</span><br><span class="line">&#125; from <span class="string">'./baseHandlers'</span></span><br><span class="line">import &#123;</span><br><span class="line">  mutableCollectionHandlers,</span><br><span class="line">  readonlyCollectionHandlers,</span><br><span class="line">  shallowCollectionHandlers</span><br><span class="line">&#125; from <span class="string">'./collectionHandlers'</span></span><br><span class="line"><span class="comment">## 然后是ref，是为了给primitive类型的value做reactive</span></span><br><span class="line">import &#123; UnwrapRef, Ref &#125; from <span class="string">'./ref'</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后是常量定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 枚举类型</span></span><br><span class="line"><span class="built_in">export</span> const enum ReactiveFlags &#123;</span><br><span class="line">  SKIP = <span class="string">'__v_skip'</span>,</span><br><span class="line">  IS_REACTIVE = <span class="string">'__v_isReactive'</span>,</span><br><span class="line">  IS_READONLY = <span class="string">'__v_isReadonly'</span>,</span><br><span class="line">  RAW = <span class="string">'__v_raw'</span>,</span><br><span class="line">  REACTIVE = <span class="string">'__v_reactive'</span>,</span><br><span class="line">  READONLY = <span class="string">'__v_readonly'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## 所监听数据中的属性接口</span></span><br><span class="line">interface Target &#123;</span><br><span class="line">  [ReactiveFlags.SKIP]?: boolean</span><br><span class="line">  [ReactiveFlags.IS_REACTIVE]?: boolean</span><br><span class="line">  [ReactiveFlags.IS_READONLY]?: boolean</span><br><span class="line">  [ReactiveFlags.RAW]?: any</span><br><span class="line">  [ReactiveFlags.REACTIVE]?: any</span><br><span class="line">  [ReactiveFlags.READONLY]?: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>typeof Map = &#39;function&#39;</code>以及 Set 里面的四个类型都是，所以这里的 collectionTypes 要变成 new Set<function></function></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const collectionTypes = new Set&lt;Function&gt;([Set, Map, WeakMap, WeakSet])</span><br></pre></td></tr></table></figure>

<p>然后是判断 key 是否存在的函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#</span></span><br><span class="line"> <span class="comment"># Make a map and return a function for checking if a key</span></span><br><span class="line"> <span class="comment"># is in that map.</span></span><br><span class="line"> <span class="comment"># IMPORTANT: all calls of this function must be prefixed with</span></span><br><span class="line"> <span class="comment"># \/\*#\_\_PURE\_\_\*\/</span></span><br><span class="line"> <span class="comment"># So that rollup can tree-shake them if necessary.</span></span><br><span class="line"> <span class="comment">#</span></span><br><span class="line"> <span class="comment"># 这个方法是干嘛用的注释写的很清楚了，很显然这是一个闭包，返回的函数是用来判断# key是否存在map中,在调用方法时要在前片加例子中的pure 让rollup能够tree-shake</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> makeMap(</span><br><span class="line">  str: string,</span><br><span class="line">  expectsLowerCase?: boolean</span><br><span class="line">): (key: string) =&gt; boolean &#123;</span><br><span class="line">  const map: Record&lt;string, boolean&gt; = Object.create(null)</span><br><span class="line">  const list: Array&lt;string&gt; = str.split(<span class="string">','</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    map[list[i]] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> expectsLowerCase ? val =&gt; !!map[val.toLowerCase()] : val =&gt; !!map[val]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isObservableType = /*<span class="comment">#__PURE__*/ makeMap(</span></span><br><span class="line">  <span class="string">'Object,Array,Map,Set,WeakMap,WeakSet'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 判断value是否能被代理</span></span><br><span class="line">const canObserve = (value: Target): boolean =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    !value[ReactiveFlags.SKIP] &amp;&amp;</span><br><span class="line">    isObservableType(toRawType(value)) &amp;&amp;</span><br><span class="line">    !Object.isFrozen(value)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## only unwrap nested ref,用来给嵌套的ref解套</span></span><br><span class="line"><span class="built_in">type</span> UnwrapNestedRefs&lt;T&gt; = T extends Ref ? T : UnwrapRef&lt;T&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 函数定义</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> reactive(target: object) &#123;</span><br><span class="line">  <span class="comment">## if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">## 如果传进来的数据是只读的，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) &#123;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">## 否则就创建响应式对象</span></span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者的注释都写的很明白了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有在属性中不带skip并且类型属于'Object,Array,Map,Set,WeakMap,WeakSet'并且属性没有被冻结的对象才能够被代理</span></span><br><span class="line">const canObserve = (value: Target): boolean =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    !value[ReactiveFlags.SKIP] &amp;&amp;</span><br><span class="line">    isObservableType(toRawType(value)) &amp;&amp;</span><br><span class="line">    !Object.isFrozen(value)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty</span><br><span class="line"><span class="built_in">export</span> const hasOwn = (</span><br><span class="line">  val: object,</span><br><span class="line">  key: string | symbol</span><br><span class="line">): key is keyof typeof val =&gt; hasOwnProperty.call(val, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createReactiveObject(</span><br><span class="line">  target: Target,</span><br><span class="line">  isReadonly: boolean,</span><br><span class="line">  baseHandlers: ProxyHandler&lt;any&gt;,</span><br><span class="line">  collectionHandlers: ProxyHandler&lt;any&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      console.warn(`value cannot be made reactive: <span class="variable">$&#123;String(target)&#125;</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># target is already a Proxy, return it.</span></span><br><span class="line">  <span class="comment"># exception: calling readonly() on a reactive object</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># target already has corresponding Proxy</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    hasOwn(target, isReadonly ? ReactiveFlags.READONLY : ReactiveFlags.REACTIVE)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> isReadonly</span><br><span class="line">      ? target[ReactiveFlags.READONLY]</span><br><span class="line">      : target[ReactiveFlags.REACTIVE]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># only a whitelist of value types can be observed.</span></span><br><span class="line">  <span class="keyword">if</span> (!canObserve(target)) &#123;</span><br><span class="line">    <span class="built_in">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  const observed = new Proxy(</span><br><span class="line">    target,</span><br><span class="line">    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  def(</span><br><span class="line">    target,</span><br><span class="line">    isReadonly ? ReactiveFlags.READONLY : ReactiveFlags.REACTIVE,</span><br><span class="line">    observed</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># def函数，显然是在obj定义一个可编写不可枚举的key,将target的响应式对象储存在自身的属性上，这样可以解决自己嵌套自己的无限循环（禁止套娃）</span></span><br><span class="line"><span class="built_in">export</span> const def = (obj: object, key: string | symbol, value: any) =&gt; &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里要说明为什么对 target 执行代理的时候 handler 要根据 target 的 contstructor 来调用不同的 handler，拿 Map 举例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map()</span><br><span class="line">const proxy = new Proxy(map,&#123;&#125;)</span><br><span class="line">proxy.set(1,1)</span><br></pre></td></tr></table></figure>

<p>一执行肯定就报错<code>Uncaught TypeError: Method Map.prototype.set called on incompatible receiver [object Object]</code>,提示信息告诉我们代码可以变成这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">var proxy = new Proxy(map, &#123;&#125;);</span><br><span class="line">Map.prototype.set.call(proxy, 1, 1);</span><br></pre></td></tr></table></figure>

<p>所以这段代码<code>Map.prototype.set.call(proxy, 1, 1);</code>为什么这个报错，就是这个问题的核心</p>
<p>那首先，Map 这个呢把数据储存在自己的私有内部插槽中，类型[MapData]这样，然后这个插槽是跟 Map 对象自身绑定的。而 Proxy 不能完全模仿这样的行为，巧的是，这样的插槽 Proxy 学不来，所以在给它们做代理的时候把调用的实例重新指向 Map 这类结构的实例再进行调用实例方法就行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const PRIVATE = new WeakMap();</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">PRIVATE.set(obj, <span class="string">"private stuff"</span>);</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(obj, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">PRIVATE.get(proxy) === undefined // <span class="literal">true</span></span><br><span class="line">PRIVATE.get(obj) === <span class="string">"private stuff"</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>所以在上面创建响应式对象的时候要根据 target 的类型是判断用哪个的 handler</p>
<p>之前的枚举类型中有定义了<code>IS_REACTIVE</code>和<code>IS_READONLY</code>，就是用来判断<code>isReactive</code>和<code>isReadonly</code>，由于创建只读对象的<code>readonly</code>方法和创建响应式对象的<code>reactive</code>都是通过<code>createReactiveObject</code>方法来进行调用的，所以可以通过判断响应式或者只读属性来判断是否是被代理过的对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isReactive(value: unknown): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (isReadonly(value)) &#123;</span><br><span class="line">    <span class="built_in">return</span> isReactive((value as Target)[ReactiveFlags.RAW])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isReadonly(value: unknown): boolean &#123;</span><br><span class="line">  <span class="built_in">return</span> !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_READONLY])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isProxy(value: unknown): boolean &#123;</span><br><span class="line">  <span class="built_in">return</span> isReactive(value) || isReadonly(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 获取原始数据</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(observed: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    (observed &amp;&amp; toRaw((observed as Target)[ReactiveFlags.RAW])) || observed</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 这个方法就是不让value值被代理，之前的canObserve中有对SKIP的判断</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> markRaw&lt;T extends object&gt;(value: T): T &#123;</span><br><span class="line">  def(value, ReactiveFlags.SKIP, <span class="literal">true</span>)</span><br><span class="line">  <span class="built_in">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>toRaw</code>这个方法我曾经把它改成这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(observed: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">       observed ? toRaw((observed as Target)[ReactiveFlags.RAW]) : observed</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后跑了单测，发现所有有关 toRaw 的测试用例都报错，我靠.然后写了个小 demo 跑了一下，上面这个代码在进入倒数第二个调用栈的时候，observed 是 truthy，然后进入最后一个调用栈的时候是返回 undefined 的，然后返回倒数第二个调用栈的时候还是 undefined，这样一直到第一个栈返回的结果一直都是 undefined.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRaw&lt;T&gt;(observed: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    (observed &amp;&amp; toRaw((observed as Target)[ReactiveFlags.RAW])) || observed</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码的时候，同样的进入最后一个调用栈的时候返回的是 undefined，但是返回倒数第二个调用栈的时候 <code>observed &amp;&amp; undefined</code>是 fasly 值，所以倒数第二个调用栈返回的是一个具体的值<code>observed</code>,有、东西，智商捉急了。</p>
<p>然后还剩几个方法,这个不用说，很明显是设置只读对象，handler 也是有所区别的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">readonly</span>&lt;T extends object&gt;(</span><br><span class="line">  target: T</span><br><span class="line">): Readonly&lt;UnwrapNestedRefs&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    readonlyHandlers,</span><br><span class="line">    readonlyCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝，只有第一层的数据才是响应式</span></span><br><span class="line"><span class="comment"># Return a reactive-copy of the original object, where only the root level</span></span><br><span class="line"><span class="comment"># properties are reactive, and does NOT unwrap refs nor recursively convert</span></span><br><span class="line"><span class="comment"># returned properties.</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> shallowReactive&lt;T extends object&gt;(target: T): T &#123;</span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    shallowReactiveHandlers,</span><br><span class="line">    shallowCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浅只读，不会对ref解套</span></span><br><span class="line"><span class="comment"># Return a reactive-copy of the original object, where only the root level</span></span><br><span class="line"><span class="comment"># properties are readonly, and does NOT unwrap refs nor recursively convert</span></span><br><span class="line"><span class="comment"># returned properties.</span></span><br><span class="line"><span class="comment"># This is used for creating the props proxy object for stateful components.</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> shallowReadonly&lt;T extends object&gt;(</span><br><span class="line">  target: T</span><br><span class="line">): Readonly&lt;&#123; [K <span class="keyword">in</span> keyof T]: UnwrapNestedRefs&lt;T[K]&gt; &#125;&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    shallowReadonlyHandlers,</span><br><span class="line">    readonlyCollectionHandlers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h4><br>
<br>
导入方法
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, <span class="built_in">readonly</span>, toRaw, ReactiveFlags &#125; from <span class="string">'./reactive'</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line">import &#123; track, trigger, ITERATE_KEY &#125; from <span class="string">'./effect'</span></span><br><span class="line">import &#123;</span><br><span class="line">  isObject,</span><br><span class="line">  hasOwn,</span><br><span class="line">  isSymbol,</span><br><span class="line">  hasChanged,</span><br><span class="line">  isArray,</span><br><span class="line">  extend</span><br><span class="line">&#125; from <span class="string">'@vue/shared'</span></span><br><span class="line">import &#123; isRef &#125; from <span class="string">'./ref'</span></span><br></pre></td></tr></table></figure>

<p>获取Symbol的属性名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const builtInSymbols = new Set(</span><br><span class="line">  Object.getOwnPropertyNames(Symbol)</span><br><span class="line">    .map(key =&gt; (Symbol as any)[key])</span><br><span class="line">    .filter(isSymbol)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>看名字就知道干嘛的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const get = /*<span class="comment">#__PURE__*/ createGetter()</span></span><br><span class="line">const shallowGet = /*<span class="comment">#__PURE__*/ createGetter(false, true)</span></span><br><span class="line">const readonlyGet = /*<span class="comment">#__PURE__*/ createGetter(true)</span></span><br><span class="line">const shallowReadonlyGet = /*<span class="comment">#__PURE__*/ createGetter(true, true)</span></span><br></pre></td></tr></table></figure>

<p>对数组的这三个方法插桩，看的时候有个问题，为什么有个条件分支是<code>res === -1 || res === false</code>的时候继续执行，什么情况下会进入这个分支？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const arrayInstrumentations: Record&lt;string, Function&gt; = &#123;&#125;</span><br><span class="line">;[<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>].forEach(key =&gt; &#123;</span><br><span class="line">  arrayInstrumentations[key] = <span class="keyword">function</span>(...args: any[]): any &#123;</span><br><span class="line">    const arr = toRaw(this) as any</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0, l = (this as any).length; i &lt; l; i++) &#123;</span><br><span class="line">      track(arr, TrackOpTypes.GET, i + <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">## we run the method using the original args first (which may be reactive)</span></span><br><span class="line">    <span class="comment">## console.log(key,...args)</span></span><br><span class="line">    const res = arr[key](...args)</span><br><span class="line">    <span class="keyword">if</span> (res === -1 || res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">## if that didn't work, run it again using raw values.</span></span><br><span class="line">      <span class="built_in">return</span> arr[key](...args.map(toRaw))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">## return res</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>把 if 的条件分支注释，只留下<code>return res</code>这个分支，然后跑单测，发现 reactiveArray.spec.ts 这个测试文件的测试用例<code>× Array identity methods should work with raw values (16 ms)</code>测试不通过。发现是在这里的时候不能测试通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const raw = &#123;&#125;</span><br><span class="line">const arr = reactive([&#123;&#125;, &#123;&#125;])</span><br><span class="line">arr.push(raw)</span><br><span class="line"><span class="comment">## 省略其他代码</span></span><br><span class="line"><span class="comment"># should work also for the observed version</span></span><br><span class="line">const observed = arr[2]</span><br><span class="line">expect(arr.indexOf(observed)).toBe(2)</span><br></pre></td></tr></table></figure>

<p>然后将测试不通过代码拷贝到 vite 的 app 中进行调试，发现是 observed 这个值不再是跟 raw 一样的{},猜测是劫持了数组的 get 方法并且对返回值进行了修改。然后进入到<code>createGetter</code>这个方法，其中有个逻辑,如果参数是对象，那么就要转成响应式对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">    <span class="comment"># Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">    <span class="comment"># here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">    <span class="comment"># and reactive here to avoid circular dependency.</span></span><br><span class="line">    <span class="built_in">return</span> isReadonly ? <span class="built_in">readonly</span>(res) : reactive(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，<code>typeof {} === &#39;object&#39;</code>，所以这个时候的 observed 不再是单纯的<code>{}</code>，它是一个响应式的<code>{}</code>，所以就能解释为什么在<code>res === -1 || res === false</code>的时候还要进行次函数执行的过程，这是为了防止获取到的值是经过转换的值，所以在分支里面的参数要对参数进行一次还原，SKR。</p>
<p>下面这个就是劫持了 get 的方法，一条条逻辑看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createGetter(isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> get(target: object, key: string | symbol, receiver: object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="built_in">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      <span class="built_in">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? (target as any)[ReactiveFlags.READONLY]</span><br><span class="line">          : (target as any)[ReactiveFlags.REACTIVE])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const targetIsArray = isArray(target)</span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="built_in">return</span> Reflect.get(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const res = Reflect.get(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isSymbol(key)</span><br><span class="line">        ? builtInSymbols.has(key)</span><br><span class="line">        : key === `__proto__` || key === `__v_isRef`</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="built_in">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRef(res)) &#123;</span><br><span class="line">      <span class="comment"># ref unwrapping, only for Objects, not for Arrays</span></span><br><span class="line">      <span class="comment"># 对于ref的解套，仅仅针对object，不针对数组.</span></span><br><span class="line">      <span class="built_in">return</span> targetIsArray ? res : res.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment"># Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment"># here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment"># and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="built_in">return</span> isReadonly ? <span class="built_in">readonly</span>(res) : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看这个,老样子，先注释，跑单测，看结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="built_in">return</span> !isReadonly</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:<br><img src="/images/reactive/code3.png" alt="code3"><br>可以看到是<code>reactivity/reactive/Array › should make Array reactive</code>这个测试用例中的某个用例出现了问题，来看具体问题代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const observed = reactive(original)</span><br><span class="line">expect(observed).not.toBe(original)</span><br><span class="line"><span class="comment"># 下面这段是问题代码</span></span><br><span class="line">expect(isReactive(observed)).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>看<code>isReactive</code>方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isReactive(value: unknown): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (isReadonly(value)) &#123;</span><br><span class="line">    <span class="built_in">return</span> isReactive((value as Target)[ReactiveFlags.RAW])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那现在可以看出，是在数组访问<code>ReactiveFlags.IS_REACTIVE</code>这个 key 的时候被劫持了，然后进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      return !isReadonly</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个逻辑，至于为什么返回结果要对<code>isReadonly</code>取反，很显然，在<code>createReactiveObject</code>的时候 reactive 和 readonly 是互斥的关系，那么一个对象不是只读很显然就是响应式,那如果是原始对象呢？很显然，原始对象没有<code>__v_isReactive</code>这个属性，那么会返回 undefined，用!!转义就是 false；然后<code>key === ReactiveFlags.IS_READONLY</code>这个分支的逻辑就跟<code>REACTIVE</code>的逻辑一样的。</p>
<p>然后我把第三个分支给注释，WDM，直接爆栈了。。。<br><br><br><code>RangeError: Maximum call stack size exceeded at Object.get (&lt;anonymous&gt;)</code><br>四个测试用例没通过，我选了其中一个测试用例来复现<code>Array identity methods should work with raw values</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> const raw = &#123;&#125;</span><br><span class="line"> const arr = reactive([&#123;&#125;, &#123;&#125;])</span><br><span class="line"> arr.push(raw)</span><br><span class="line">console.log(arr.indexOf(raw))</span><br></pre></td></tr></table></figure>

<p>然后跟着代码走，先进入 indexOf 的这个方法，这个方法是被劫持的,走到这里</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>].forEach(key =&gt; &#123;</span><br><span class="line">    arrayInstrumentations[key] = <span class="keyword">function</span> (...args) &#123;</span><br><span class="line">        <span class="comment"># 1 这里需要获取当前数组的原始数据,然后会在this中访问__v_raw属性，接着就进入劫持的get方法</span></span><br><span class="line">        const arr = toRaw(this);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> i = 0, l = this.length; i &lt; l; i++) &#123;</span><br><span class="line">            track(arr, <span class="string">"get"</span> /* GET */, i + <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># we run the method using the original args first (which may be reactive)</span></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        const res = arr[key](...args);</span><br><span class="line">        <span class="keyword">if</span> (res === -1 || res === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment"># if that didn't work, run it again using raw values.</span></span><br><span class="line">            <span class="built_in">return</span> arr[key](...args.map(toRaw));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当1执行的时候，跳到get的时候此时的key是__v_raw</span></span><br><span class="line"><span class="comment"># 这里截取get方法的一部分，第三个分支被我删去，此时不会直接return，而是继续往下执行，此时</span></span><br><span class="line"><span class="comment"># 的return res是undefined,然后在返回toRaw方法的时候直接看第一层调用栈observed&amp;&amp;undefinde||observed,很明显这时候的arr返回的是observed，因此此时的arr并不是原始数据，当执行到2处时，又一次进入get方# 法，此时的key是indexOf，然后此时会返回 return Reflect.get(arrayInstrumentations, # key, receiver);而arrayInstrumentations['indexOf']这个方法又进入了1这个过程，从而造# 成调用栈爆栈的问题</span></span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">"__v_isReactive"</span> /* IS_REACTIVE */) &#123;</span><br><span class="line">        <span class="built_in">return</span> !isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"__v_isReadonly"</span> /* IS_READONLY */) &#123;</span><br><span class="line">        <span class="built_in">return</span> isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line">    const targetIsArray = isArray(target);</span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">        <span class="built_in">return</span> Reflect.get(arrayInstrumentations, key, receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个 Symbol 的判断逻辑一直没有理解，我 TM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    isSymbol(key)</span><br><span class="line">      ? builtInSymbols.has(key)</span><br><span class="line">      : key === `__proto__` || key === `__v_isRef`</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我在单测里面执行测试用例的自定义 Symbol 访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const customSymbol = Symbol()</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.asyncIterator]: &#123; a: 1 &#125;,</span><br><span class="line">  [Symbol.unscopables]: &#123; b: <span class="string">'1'</span> &#125;,</span><br><span class="line">  [customSymbol]: &#123; c: [1, 2, 3] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const objRef = ref(obj)</span><br><span class="line">expect(objRef.value[Symbol.asyncIterator]).toBe(obj[Symbol.asyncIterator])</span><br><span class="line">expect(objRef.value[Symbol.unscopables]).toBe(obj[Symbol.unscopables])</span><br><span class="line"><span class="comment"># 这两句log语句都是输出 &#123; c: [ 1, 2, 3 ] &#125;原始数据</span></span><br><span class="line">console.log(objRef.value[customSymbol])</span><br><span class="line">console.log(obj[customSymbol])</span><br></pre></td></tr></table></figure>

<p>然后我在 demo 里面也复制了这段代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const customSymbol = Symbol()</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.asyncIterator]: &#123; a: 1 &#125;,</span><br><span class="line">  [Symbol.unscopables]: &#123; b: <span class="string">'1'</span> &#125;,</span><br><span class="line">  [customSymbol]: &#123; c: [1, 2, 3] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debugger</span><br><span class="line">const objRef = ref(obj)</span><br><span class="line"><span class="comment"># 结果下面两个log 一个输出 代理过的Object，一个输出Objectt原始数据</span></span><br><span class="line">console.log(objRef.value[customSymbol])</span><br><span class="line">console.log(obj[customSymbol])</span><br></pre></td></tr></table></figure>

<p>我就先不管它了。</p>
<p>然后是<code>createSetter</code>,是 set 方法的插桩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createSetter(shallow = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="built_in">set</span>(</span><br><span class="line">    target: object,</span><br><span class="line">    key: string | symbol,</span><br><span class="line">    value: unknown,</span><br><span class="line">    receiver: object</span><br><span class="line">  ): boolean &#123;</span><br><span class="line">    const oldValue = (target as any)[key]</span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      value = toRaw(value)</span><br><span class="line">      <span class="comment"># 这里就是判断赋值的时候新值如果不是ref，并且旧值是ref的情况下的赋值</span></span><br><span class="line">      <span class="comment"># 这里有个条件是判断当前target是非数组，但是当我把这个条件删除的时候，210个测试用例仍然测试通过，所以这个条件不知道是干啥的。</span></span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        oldValue.value = value</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const hadKey = hasOwn(target, key)</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment"># don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="comment"># 这个等于是在什么情况下发生的，把里面的逻辑拿出来，找到没有通过的测试用例，发现就一个，是在effect模块，emm先记录，等读到的时候再看---effect-settter</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="comment"># 这里就是判断要set的key是否存在target上，如果不存在，就触发添加数据的依赖，如果存在，就触发更新数据的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># Reflect要返回boolean来判断是否设置成功</span></span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># hasChange方法用来判断值是否有所改变，&amp;&amp;后面的判断语句是用来过滤NaN的，因为NaN是唯一一个自身不相等的数</span></span><br><span class="line"><span class="built_in">export</span> const hasChanged = (value: any, oldValue: any): boolean =&gt;</span><br><span class="line">  value !== oldValue &amp;&amp; (value === value || oldValue === oldValue)</span><br></pre></td></tr></table></figure>

<p>附一张疑问图<br><img src="/images/reactive/code5.png" alt="confused"><br><img src="/images/reactive/code6.png" alt="confused"><br>剩下几个的逻辑就很单一了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除逻辑 删除成功并且在target有这个key存在然后触发更新</span></span><br><span class="line"><span class="keyword">function</span> deleteProperty(target: object, key: string | symbol): boolean &#123;</span><br><span class="line">  const hadKey = hasOwn(target, key)</span><br><span class="line">  const oldValue = (target as any)[key]</span><br><span class="line">  const result = Reflect.deleteProperty(target, key)</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 静态方法 Reflect.has() 作用与 in 操作符 相同。</span></span><br><span class="line"><span class="keyword">function</span> has(target: object, key: string | symbol): boolean &#123;</span><br><span class="line">  const result = Reflect.has(target, key)</span><br><span class="line">  track(target, TrackOpTypes.HAS, key)</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。不包括原型链喔</span></span><br><span class="line"><span class="keyword">function</span> ownKeys(target: object): (string | number | symbol)[] &#123;</span><br><span class="line">  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)</span><br><span class="line">  <span class="built_in">return</span> Reflect.ownKeys(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 baseHandlers 剩下的代码就是一些 handler 了，没有逻辑</p>
<h4 id="collectionHandler"><a href="#collectionHandler" class="headerlink" title="collectionHandler"></a>collectionHandler</h4><p>导入文件，类型声明，以及一些方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; toRaw, reactive, <span class="built_in">readonly</span>, ReactiveFlags &#125; from <span class="string">'./reactive'</span></span><br><span class="line">import &#123; track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY &#125; from <span class="string">'./effect'</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line">import &#123;</span><br><span class="line">  isObject,</span><br><span class="line">  capitalize,</span><br><span class="line">  hasOwn,</span><br><span class="line">  hasChanged,</span><br><span class="line">  toRawType</span><br><span class="line">&#125; from <span class="string">'@vue/shared'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> CollectionTypes = IterableCollections | WeakCollections</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> IterableCollections = Map&lt;any, any&gt; | Set&lt;any&gt;</span><br><span class="line"><span class="built_in">type</span> WeakCollections = WeakMap&lt;any, any&gt; | WeakSet&lt;any&gt;</span><br><span class="line"><span class="built_in">type</span> MapTypes = Map&lt;any, any&gt; | WeakMap&lt;any, any&gt;</span><br><span class="line"><span class="built_in">type</span> SetTypes = Set&lt;any&gt; | WeakSet&lt;any&gt;</span><br><span class="line"></span><br><span class="line">const toReactive = &lt;T extends unknown&gt;(value: T): T =&gt;</span><br><span class="line">  isObject(value) ? reactive(value) : value</span><br><span class="line"></span><br><span class="line">const toReadonly = &lt;T extends unknown&gt;(value: T): T =&gt;</span><br><span class="line">  isObject(value) ? <span class="built_in">readonly</span>(value) : value</span><br><span class="line"></span><br><span class="line">const toShallow = &lt;T extends unknown&gt;(value: T): T =&gt; value</span><br><span class="line"></span><br><span class="line">const getProto = &lt;T extends CollectionTypes&gt;(v: T): any =&gt;</span><br><span class="line">  Reflect.getPrototypeOf(v)</span><br></pre></td></tr></table></figure>

<p>看 get 方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> get(</span><br><span class="line">  target: MapTypes,</span><br><span class="line">  key: unknown,</span><br><span class="line">  wrap: typeof toReactive | typeof toReadonly | typeof toShallow</span><br><span class="line">) &#123;</span><br><span class="line">  target = toRaw(target)</span><br><span class="line">  const rawKey = toRaw(key)</span><br><span class="line">  <span class="comment"># 这里的key不等于rawKey的话那么必然是这个key是响应式对象</span></span><br><span class="line">  <span class="comment"># 然后这里track应该是收集依赖，具体逻辑不知道，先这样看</span></span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    track(target, TrackOpTypes.GET, key)</span><br><span class="line">  &#125;</span><br><span class="line">  track(target, TrackOpTypes.GET, rawKey)</span><br><span class="line">  const &#123; has, get &#125; = getProto(target)</span><br><span class="line">  <span class="comment"># 判断是key在target上还是rawKey在target上，wrap是属于toReactive|toReadonly|toShallow三个函数中的其中一个，if里面是在组合调用函数</span></span><br><span class="line">  <span class="keyword">if</span> (has.call(target, key)) &#123;</span><br><span class="line">    <span class="built_in">return</span> wrap(get.call(target, key))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.call(target, rawKey)) &#123;</span><br><span class="line">    <span class="built_in">return</span> wrap(get.call(target, rawKey))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>啊，然后看 set 方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>(this: MapTypes, key: unknown, value: unknown) &#123;</span><br><span class="line">  value = toRaw(value)</span><br><span class="line">  <span class="comment"># 这里肯定要把this转成原生数据类型，而不能用Proxy，原因之前有讲了，这里的has调用绑定到了代理之前的数据实例</span></span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const &#123; has, get, <span class="built_in">set</span> &#125; = getProto(target)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> hadKey = has.call(target, key)</span><br><span class="line">  <span class="comment">## 这个是我自己改的，果然 ，测试用例没通过，调了下，果然还是得用实例自带的方法来判断，用Object.prototype.hasOwnProperty还是不能用来对Map这类结构进行判断的</span></span><br><span class="line">  <span class="comment">## let hadKey = hasOwn(target,key as any)</span></span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    <span class="comment"># 这个逻辑跟之前的对数组的indexOf插桩的方法一个道理，都是考虑了key值为响应式对象的情况</span></span><br><span class="line">    key = toRaw(key)</span><br><span class="line">    hadKey = has.call(target, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    checkIdentityKeys(target, has, key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldValue = get.call(target, key)</span><br><span class="line">  const result = set.call(target, key, value)</span><br><span class="line">  <span class="comment"># 更新依赖----&gt;要么add要么set</span></span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>has 和 add 方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> has(this: CollectionTypes, key: unknown): boolean &#123;</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const rawKey = toRaw(key)</span><br><span class="line">  <span class="comment"># 响应对象</span></span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    track(target, TrackOpTypes.HAS, key)</span><br><span class="line">  &#125;</span><br><span class="line">  track(target, TrackOpTypes.HAS, rawKey)</span><br><span class="line">  const has = getProto(target).has</span><br><span class="line">  <span class="comment"># 这里用到了或运算符考虑到了Set里面放置了响应式对象的情况</span></span><br><span class="line">  <span class="comment"># 所以单独只使用一个判断的话测试用例是不能全部通过的</span></span><br><span class="line">  <span class="built_in">return</span> has.call(target, key) || has.call(target, rawKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个方法 就 嗯  一目了然</span></span><br><span class="line"><span class="keyword">function</span> add(this: SetTypes, value: unknown) &#123;</span><br><span class="line">  <span class="comment"># 可能会有疑问，这里的添加不是把value都做了一个转换吗？为什么Set里面会有响应式对象？</span></span><br><span class="line">  <span class="comment"># 这个方法只是劫持了Set方法的add，所以只有Set转变成响应式对象后调用了add方法，加入进去的value才只是普通的value值</span></span><br><span class="line">  value = toRaw(value)</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const proto = getProto(target)</span><br><span class="line">  const hadKey = proto.has.call(target, value)</span><br><span class="line">  const result = proto.add.call(target, value)</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.ADD, value, value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码，在 set 转为响应式对象前后分别把响应式对象 entry 加入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const raw = new Set();</span><br><span class="line">const entry = reactive(&#123;&#125;);</span><br><span class="line">raw.add(entry);</span><br><span class="line">const <span class="built_in">set</span> = reactive(raw);</span><br><span class="line">// console.log(set.has(entry));</span><br><span class="line">set.add(entry)</span><br></pre></td></tr></table></figure>

<p>看 log 结果<br><img src="/images/reactive/code7.png" alt="code7"></p>
<p>从图里可以很明显的看出 添加了两个相同的对象，但是一个是原始值，一个是代理对象，说明之前那个问题，Set 结构里面是可以有代理对象的，只要在 Set 被 reactive 之前加入就行，在被 reactive 之后添加的数据就只是原始数据，而不是代理对象了，这里的原始数据指的是没有被 Proxy</p>
<p>deleteEntry 跟 set 逻辑有点相似,区别就在于调用的方法不一样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> deleteEntry(this: CollectionTypes, key: unknown) &#123;</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const &#123; has, get, delete: del &#125; = getProto(target)</span><br><span class="line">  <span class="built_in">let</span> hadKey = has.call(target, key)</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    key = toRaw(key)</span><br><span class="line">    hadKey = has.call(target, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    checkIdentityKeys(target, has, key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldValue = get ? get.call(target, key) : undefined</span><br><span class="line">  <span class="comment"># forward the operation before queueing reactions</span></span><br><span class="line">  const result = del.call(target, key)</span><br><span class="line">  <span class="keyword">if</span> (hadKey) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear 方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> clear(this: IterableCollections) &#123;</span><br><span class="line">  const target = toRaw(this)</span><br><span class="line">  const hadItems = target.size !== 0</span><br><span class="line">  const oldTarget = __DEV__</span><br><span class="line">    ? target instanceof Map</span><br><span class="line">      ? new Map(target)</span><br><span class="line">      : new Set(target)</span><br><span class="line">    : undefined</span><br><span class="line">  <span class="comment"># forward the operation before queueing reactions</span></span><br><span class="line">  const result = getProto(target).clear.call(target)</span><br><span class="line">  <span class="comment"># 告诉有收集这个target的对象们可以把它的值置空了</span></span><br><span class="line">  <span class="keyword">if</span> (hadItems) &#123;</span><br><span class="line">    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unction createForEach(isReadonly: boolean, shallow: boolean) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> forEach(</span><br><span class="line">    this: IterableCollections,</span><br><span class="line">    callback: Function,</span><br><span class="line">    <span class="comment"># 以为这个参数没有用，注释掉跑了下测试，只有一个用例报错，断言写的是callback内部的this等于thisArg</span></span><br><span class="line">    thisArg?: unknown</span><br><span class="line">  ) &#123;</span><br><span class="line">    const observed = this</span><br><span class="line">    <span class="comment"># 本来以为这里的observed算是重复变量，</span></span><br><span class="line">    <span class="comment"># 所以下一行可以改成</span></span><br><span class="line">    <span class="comment"># const target = toRaw(this)</span></span><br><span class="line">    <span class="comment"># 但是注意到wrappedCallback这个函数也用到了，取得是外层作用域的this，因此需要一个储存this的临时变量</span></span><br><span class="line">    const target = toRaw(observed)</span><br><span class="line">    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive</span><br><span class="line">    !isReadonly &amp;&amp; track(target, TrackOpTypes.ITERATE, ITERATE_KEY)</span><br><span class="line">    <span class="comment"># important: create sure the callback is</span></span><br><span class="line">    <span class="comment"># 1. invoked with the reactive map as `this` and 3rd arg</span></span><br><span class="line">    <span class="comment"># 2. the value received should be a corresponding reactive/readonly.</span></span><br><span class="line">    <span class="keyword">function</span> wrappedCallback(value: unknown, key: unknown) &#123;</span><br><span class="line">      <span class="built_in">return</span> callback.call(thisArg, wrap(value), wrap(key), observed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 这句我一开始以为是遍历原型链上所有的属性以及方法并且进行this重定向，后来我对这句进行了一次debug，我发现下面这句应该是等同于</span></span><br><span class="line">    <span class="comment"># return getProto(target)['forEach'].call(target,wrappedCallback)</span></span><br><span class="line">    <span class="comment"># 我觉得这样写应该更容易理解吧～</span></span><br><span class="line">    <span class="built_in">return</span> getProto(target).forEach.call(target, wrappedCallback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对迭代方法进行一个插桩，返回闭包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createIterableMethod(</span><br><span class="line">  method: string | symbol,</span><br><span class="line">  isReadonly: boolean,</span><br><span class="line">  shallow: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(</span><br><span class="line">    this: IterableCollections,</span><br><span class="line">    ...args: unknown[]</span><br><span class="line">  ): Iterable &amp; Iterator &#123;</span><br><span class="line">    const target = toRaw(this)<span class="comment">#获取原始数据</span></span><br><span class="line">    const isMap = target instanceof Map</span><br><span class="line">    const isPair = method === <span class="string">'entries'</span> || (method === Symbol.iterator &amp;&amp; isMap)</span><br><span class="line">    const isKeyOnly = method === <span class="string">'keys'</span> &amp;&amp; isMap</span><br><span class="line">    <span class="comment"># 考虑这里对apply可以用call来调用吗？</span></span><br><span class="line">    <span class="comment"># 但是是不行，因为这里的arg是一个数组，而call的参数需要是一个参数或者多个参数，就是说call的参数只能是一个个的传！</span></span><br><span class="line">    <span class="comment"># 并且这里的innerIterator返回的并不是一个array，而是一个iterator</span></span><br><span class="line">    const innerIterator = getProto(target)[method].apply(target, args)</span><br><span class="line">    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive</span><br><span class="line">    !isReadonly &amp;&amp;</span><br><span class="line">      track(</span><br><span class="line">        target,</span><br><span class="line">        TrackOpTypes.ITERATE,</span><br><span class="line">        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY</span><br><span class="line">      )</span><br><span class="line">    <span class="comment"># return a wrapped iterator which returns observed versions of the</span></span><br><span class="line">    <span class="comment"># values emitted from the real iterator</span></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      <span class="comment"># iterator protocol</span></span><br><span class="line">      <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">        const &#123; value, <span class="keyword">done</span> &#125; = innerIterator.next()</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">done</span></span><br><span class="line">          ? &#123; value, <span class="keyword">done</span> &#125;</span><br><span class="line">          : &#123;</span><br><span class="line">              <span class="comment"># 只有在调用entries方法或者是Map类型对时候才需要返回【key，value】，并且让返回对数据保持响应式结构</span></span><br><span class="line">              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),</span><br><span class="line">              <span class="keyword">done</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment"># iterable protocol</span></span><br><span class="line">      <span class="comment"># mdn对于重写迭代器有提到需要返回自身，否则会发生意料之外对错误</span></span><br><span class="line">      [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="built_in">return</span> this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">之后的函数都是通过条件来调用之前的函数，就跳哟拉～</span><br><span class="line"></span><br><span class="line">待续...(reactive还没看完)</span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>跟 reactive 类似，同样也是让一个 value 值变成一个响应式对象，但是不同的是 reactive 只能让 object 变成响应式对象，却不包括 primitive 值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 收集 触发依赖</span></span><br><span class="line">import &#123; track, trigger &#125; from <span class="string">'./effect'</span></span><br><span class="line"><span class="comment"># 枚举类型</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line"><span class="comment"># 通用方法</span></span><br><span class="line">import &#123; isObject, hasChanged &#125; from <span class="string">'@vue/shared'</span></span><br><span class="line">import &#123; reactive, isProxy, toRaw &#125; from <span class="string">'./reactive'</span></span><br><span class="line">import &#123; CollectionTypes &#125; from <span class="string">'./collectionHandlers'</span></span><br></pre></td></tr></table></figure>

<p>要定义一个独一无二的字段 Symbol 类型，并且不想让 ide 识别出来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> const RefSymbol: unique symbol</span><br><span class="line"><span class="built_in">export</span> interface Ref&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">   <span class="comment">#Type differentiator only.</span></span><br><span class="line">   <span class="comment">#We need this to be in public d.ts but don't want it to show up in IDE</span></span><br><span class="line">   <span class="comment">#autocomplete, so we use a private Symbol instead.</span></span><br><span class="line">   <span class="comment">#</span></span><br><span class="line">  [RefSymbol]: <span class="literal">true</span></span><br><span class="line">  value: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toRefs 的类型声明，每个在 T 里面的值都是 ref 类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> ToRefs&lt;T = any&gt; = &#123; [K <span class="keyword">in</span> keyof T]: Ref&lt;T[K]&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>由于 reactive 仅接受 object 作为入参，所以对于 primitive 的值就返回它的值而不是调用 reactive</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const convert = &lt;T extends unknown&gt;(val: T): T =&gt;</span><br><span class="line">  isObject(val) ? reactive(val) : val</span><br></pre></td></tr></table></figure>

<p>ref 直接调用了<code>createRef</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> ref(value?: unknown) &#123;</span><br><span class="line">  <span class="built_in">return</span> createRef(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># createRef直接返回一个object，</span></span><br><span class="line"><span class="comment"># const count = ref(1)</span></span><br><span class="line"><span class="comment"># ==&gt;count = &#123;</span></span><br><span class="line"><span class="comment">#         __v_isRef:true,</span></span><br><span class="line"><span class="comment">#         value:1</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="keyword">function</span> createRef(rawValue: unknown, shallow = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="built_in">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> value = shallow ? rawValue : convert(rawValue)</span><br><span class="line">  const r = &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">      track(r, TrackOpTypes.GET, <span class="string">'value'</span>)</span><br><span class="line">      <span class="built_in">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> value(newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(toRaw(newVal), rawValue)) &#123;</span><br><span class="line">        rawValue = newVal</span><br><span class="line">        value = shallow ? newVal : convert(newVal)</span><br><span class="line">        trigger(</span><br><span class="line">          r,</span><br><span class="line">          TriggerOpTypes.SET,</span><br><span class="line">          <span class="string">'value'</span>,</span><br><span class="line">          __DEV__ ? &#123; newValue: newVal &#125; : void 0</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 reactive 只是针对于 object 的，对于内部的 prop 是没有做代理的，因此一旦解构，解构出来的值就已经失去了响应性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRefs&lt;T extends object&gt;(object: T): ToRefs&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isProxy(object)) &#123;</span><br><span class="line">    console.warn(`toRefs() expects a reactive object but received a plain one.`)</span><br><span class="line">  &#125;</span><br><span class="line">  const ret: any = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (const key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    ret[key] = toRef(object, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> toRef&lt;T extends object, K extends keyof T&gt;(</span><br><span class="line">  object: T,</span><br><span class="line">  key: K</span><br><span class="line">): Ref&lt;T[K]&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    get value(): any &#123;</span><br><span class="line">      <span class="built_in">return</span> object[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> value(newVal) &#123;</span><br><span class="line">      object[key] = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; as any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LIKE THIS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  const obj = reactive(&#123;count:10,age:10]&#125;)</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    ...obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const obj = f()</span><br><span class="line"><span class="built_in">let</span> &#123;count,age&#125; = obj</span><br><span class="line">count <span class="comment"># 10</span></span><br><span class="line">count++</span><br><span class="line">count <span class="comment"># 11</span></span><br><span class="line">obj.count <span class="comment">#10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  const obj = reactive(&#123;count:10,age:10]&#125;)</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    ...toRefs(obj)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const obj = f()</span><br><span class="line">const &#123;count&#125;  = obj <span class="comment"># 这样解构出来的count是一个ref类型，它具备有响应性</span></span><br><span class="line">count.value <span class="comment"># 10</span></span><br><span class="line">count.value++</span><br><span class="line">count.value <span class="comment">#11</span></span><br><span class="line">obj.count.value <span class="comment"># 11</span></span><br></pre></td></tr></table></figure>

<p>看看这个很长很长的类型声明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> interface RefUnwrapBailTypes &#123;&#125;</span><br><span class="line"><span class="comment"># 首先如果T是Ref类型的，那么把ref类型里面推断的数据类型作为类型传递给UnwrapRefSimple</span></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> UnwrapRef&lt;T&gt; = T extends Ref&lt;infer V&gt;</span><br><span class="line">  ? UnwrapRefSimple&lt;V&gt;</span><br><span class="line">  : UnwrapRefSimple&lt;T&gt;</span><br><span class="line"><span class="comment"># 然后UnwrapRefSimple根据传进来的类型来决定返回什么类型</span></span><br><span class="line"><span class="built_in">type</span> UnwrapRefSimple&lt;T&gt; = T extends</span><br><span class="line">  | Function</span><br><span class="line">  | CollectionTypes</span><br><span class="line">  | BaseTypes</span><br><span class="line">  | Ref</span><br><span class="line">  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]</span><br><span class="line">  ? T</span><br><span class="line">  : T extends Array&lt;any&gt;</span><br><span class="line">    ? &#123; [K <span class="keyword">in</span> keyof T]: UnwrapRefSimple&lt;T[K]&gt; &#125;</span><br><span class="line">    : T extends object ? UnwrappedObject&lt;T&gt; : T</span><br></pre></td></tr></table></figure>

<p>这里的 T[P]要用 UnwrapRef 嵌套应该是要考虑对象中有 ref 的情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> UnwrappedObject&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: UnwrapRef&lt;T[P]&gt; &#125; &amp; SymbolExtract&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个枚举</span></span><br><span class="line">import &#123; TrackOpTypes, TriggerOpTypes &#125; from <span class="string">'./operations'</span></span><br><span class="line"><span class="comment"># 两个工具方法</span></span><br><span class="line">import &#123; EMPTY_OBJ, isArray &#125; from <span class="string">'@vue/shared'</span></span><br></pre></td></tr></table></figure>

<p>储存依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The main WeakMap that stores &#123;target -&gt; key -&gt; dep&#125; connections.</span></span><br><span class="line"><span class="comment"># Conceptually, it's easier to think of a dependency as a Dep class</span></span><br><span class="line"><span class="comment"># which maintains a Set of subscribers, but we simply store them as</span></span><br><span class="line"><span class="comment"># raw Sets to reduce memory overhead.</span></span><br><span class="line"><span class="built_in">type</span> Dep = Set&lt;ReactiveEffect&gt;</span><br><span class="line"><span class="built_in">type</span> KeyToDepMap = Map&lt;any, Dep&gt;</span><br><span class="line">const targetMap = new WeakMap&lt;any, KeyToDepMap&gt;()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> interface ReactiveEffect&lt;T = any&gt; &#123;</span><br><span class="line">  (...args: any[]): T</span><br><span class="line">  _isEffect: <span class="literal">true</span></span><br><span class="line">  id: number</span><br><span class="line">  <span class="comment"># 是否停止监听</span></span><br><span class="line">  active: boolean</span><br><span class="line">  <span class="comment"># 原始函数</span></span><br><span class="line">  raw: () =&gt; T</span><br><span class="line">  <span class="comment"># 依赖数组</span></span><br><span class="line">  deps: Array&lt;Dep&gt;</span><br><span class="line">  <span class="comment"># 选项</span></span><br><span class="line">  options: ReactiveEffectOptions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> interface ReactiveEffectOptions &#123;</span><br><span class="line">  <span class="comment"># 判断是否立即执行</span></span><br><span class="line">  lazy?: boolean</span><br><span class="line">  computed?: boolean</span><br><span class="line">  scheduler?: (job: ReactiveEffect) =&gt; void</span><br><span class="line">  onTrack?: (event: DebuggerEvent) =&gt; void</span><br><span class="line">  onTrigger?: (event: DebuggerEvent) =&gt; void</span><br><span class="line">  onStop?: () =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">type</span> DebuggerEvent = &#123;</span><br><span class="line">  effect: ReactiveEffect</span><br><span class="line">  target: object</span><br><span class="line">  <span class="built_in">type</span>: TrackOpTypes | TriggerOpTypes</span><br><span class="line">  key: any</span><br><span class="line">&#125; &amp; DebuggerEventExtraInfo</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> interface DebuggerEventExtraInfo &#123;</span><br><span class="line">  newValue?: any</span><br><span class="line">  oldValue?: any</span><br><span class="line">  oldTarget?: Map&lt;any, any&gt; | Set&lt;any&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 储存effect的数组</span></span><br><span class="line">const effectStack: ReactiveEffect[] = []</span><br><span class="line"><span class="built_in">let</span> activeEffect: ReactiveEffect | undefined</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> const ITERATE_KEY = Symbol(__DEV__ ? <span class="string">'iterate'</span> : <span class="string">''</span>)</span><br><span class="line"><span class="built_in">export</span> const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? <span class="string">'Map key iterate'</span> : <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>判断是否是 effect 函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> isEffect(fn: any): fn is ReactiveEffect &#123;</span><br><span class="line">  <span class="built_in">return</span> fn &amp;&amp; fn._isEffect === <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 effect 函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> effect&lt;T = any&gt;(</span><br><span class="line">  fn: () =&gt; T,</span><br><span class="line">  options: ReactiveEffectOptions = EMPTY_OBJ</span><br><span class="line">): ReactiveEffect&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  const effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="comment"># 如果没有lazy参数，那么effect 函数立即执行</span></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> uid = 0</span><br><span class="line"><span class="comment"># 删除effect里面的依赖的依赖的effect（很拗口）</span></span><br><span class="line"><span class="keyword">function</span> cleanup(effect: ReactiveEffect) &#123;</span><br><span class="line">  const &#123; deps &#125; = effect</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createReactiveEffect&lt;T = any&gt;(</span><br><span class="line">  fn: (...args: any[]) =&gt; T,</span><br><span class="line">  options: ReactiveEffectOptions</span><br><span class="line">): ReactiveEffect&lt;T&gt; &#123;</span><br><span class="line">  const effect = <span class="keyword">function</span> reactiveEffect(...args: unknown[]): unknown &#123;</span><br><span class="line">    <span class="comment"># 把这句注释，一个用例报错 reactivity/effect › stop with scheduler</span></span><br><span class="line">    <span class="comment"># 提示我们 在把effect调用了stop之后，scheduler不在执行</span></span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="built_in">return</span> options.scheduler ? undefined : fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 问个问题，if代码块里面的语句push了一次，然后pop了一次，那么为什么还需要判断effect是否存在effect栈中</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      <span class="comment"># 这里要删除effect的依赖项，是为了处理effect里面有条件语句的情况，</span></span><br><span class="line">      <span class="comment"># 分支不处于激活状态时，修改分支上的属性不应该执行effect</span></span><br><span class="line">      cleanup(effect)</span><br><span class="line">      try &#123;</span><br><span class="line">        enableTracking()</span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="built_in">return</span> fn(...args)</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - 1]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; as ReactiveEffect</span><br><span class="line">  effect.id = uid++</span><br><span class="line">  effect._isEffect = <span class="literal">true</span></span><br><span class="line">  effect.active = <span class="literal">true</span></span><br><span class="line">  effect.raw = fn</span><br><span class="line">  effect.deps = []</span><br><span class="line">  effect.options = options</span><br><span class="line">  <span class="built_in">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提个问题，在 effect 函数里面的 if 语句块里面执行了一次<code>effectStack.push</code>,然后又执行了<code>effectStack.pop</code>,但是为什么要在 if 语句里面判断 effect 是否存在 effectStack 中，所以我把这个 if 语句删除，这是为了防止套娃。在 effect 里面调用 effect 本身，避免无限递归（小声 bb，我只看懂了这层）</p>
<p>track 函数，这是为了收集依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> track(target: object, <span class="built_in">type</span>: TrackOpTypes, key: unknown) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === undefined) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = new Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = new Set()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 在收集依赖前执行了cleanup方法</span></span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="built_in">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> trigger(</span><br><span class="line">  target: object,</span><br><span class="line">  <span class="built_in">type</span>: TriggerOpTypes,</span><br><span class="line">  key?: unknown,</span><br><span class="line">  newValue?: unknown,</span><br><span class="line">  oldValue?: unknown,</span><br><span class="line">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  const depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    // never been tracked</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const effects = new Set&lt;ReactiveEffect&gt;()</span><br><span class="line">  const add = (effectsToAdd: Set&lt;ReactiveEffect&gt; | undefined) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(effect =&gt; &#123;</span><br><span class="line">      <span class="comment"># 判断是否需要收集依赖或者effect是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123;</span><br><span class="line">          effects.add(effect)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment"># the effect mutated its own dependency during its execution.</span></span><br><span class="line">          <span class="comment"># this can be caused by operations like foo.value++</span></span><br><span class="line">          <span class="comment"># do not trigger or we end in an infinite loop</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment"># collection being cleared</span></span><br><span class="line">    <span class="comment"># trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach((dep, key) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'length'</span> || key &gt;= (newValue as number)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== void 0) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#如果是增加或者删除数据的行为，还要再往相应队列中增加监听函数</span></span><br><span class="line">    <span class="comment"># also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    const isAddOrDelete =</span><br><span class="line">      <span class="built_in">type</span> === TriggerOpTypes.ADD ||</span><br><span class="line">      (<span class="built_in">type</span> === TriggerOpTypes.DELETE &amp;&amp; !isArray(target))</span><br><span class="line">    <span class="comment"># 这个逻辑需要什么时候走到，比如对数据进行push操作时，劫持的key其实是length，此时的key确实不是0，但是depsMap.get(0)其实是为空的</span></span><br><span class="line">    <span class="comment"># 而depsMap.get('length')才是真的有相应effect，所以需要补充第二个逻辑</span></span><br><span class="line">    <span class="comment"># 假如第一个逻辑和第二个逻辑都执行了，那还是只会执行一次effect的</span></span><br><span class="line">    <span class="comment"># 理由是add中的effects这是一个set结构，自动去重</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isAddOrDelete ||</span><br><span class="line">      (<span class="built_in">type</span> === TriggerOpTypes.SET &amp;&amp; target instanceof Map)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">#如果原始数据是数组，则key为length，否则为迭代行为标识符</span></span><br><span class="line">      add(depsMap.get(isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target instanceof Map) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const run = (effect: ReactiveEffect) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="built_in">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 这里对computed进行区分，因为computed 对象中自带scheduler函数</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># 运行所有计算数据的监听方法</span></span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computed</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> computed&lt;T&gt;(getter: ComputedGetter&lt;T&gt;): ComputedRef&lt;T&gt;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  options: WritableComputedOptions&lt;T&gt;</span><br><span class="line">): WritableComputedRef&lt;T&gt;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="built_in">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? () =&gt; &#123;</span><br><span class="line">          console.warn(<span class="string">'Write operation failed: computed value is readonly'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> dirty = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">let</span> value: T</span><br><span class="line">  <span class="built_in">let</span> computed: ComputedRef&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  const runner = effect(getter, &#123;</span><br><span class="line">    lazy: <span class="literal">true</span>,</span><br><span class="line">    scheduler: () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        dirty = <span class="literal">true</span></span><br><span class="line">        trigger(computed, TriggerOpTypes.SET, <span class="string">'value'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  computed = &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    [ReactiveFlags.IS_READONLY]:</span><br><span class="line">      isFunction(getterOrOptions) || !getterOrOptions.set,</span><br><span class="line"></span><br><span class="line">    // expose effect so computed can be stopped</span><br><span class="line">    effect: runner,</span><br><span class="line">    get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">       <span class="comment"># 跑单测可以发现这个是为了防止重复计算的。</span></span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = runner()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"># 收集依赖</span></span><br><span class="line">      track(computed, TrackOpTypes.GET, <span class="string">'value'</span>)</span><br><span class="line">      <span class="built_in">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> value(newValue: T) &#123;</span><br><span class="line">      setter(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; as any</span><br><span class="line">  <span class="built_in">return</span> computed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OVER</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="ZJS 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tagstags/TypeScript/" rel="tag"># TypeScript</a>
              <a href="/tagstags/Vue3/" rel="tag"># Vue3</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/ObjectKeys/" rel="prev" title="ObjectKeys">
      <i class="fa fa-chevron-left"></i> ObjectKeys
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/essay-1/" rel="next" title="今日随笔(7-29)">
      今日随笔(7-29) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive"><span class="nav-number">2.1.</span> <span class="nav-text">reactive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#baseHandler"><span class="nav-number">2.2.</span> <span class="nav-text">baseHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collectionHandler"><span class="nav-number">2.3.</span> <span class="nav-text">collectionHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref"><span class="nav-number">2.4.</span> <span class="nav-text">ref</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#effect"><span class="nav-number">2.5.</span> <span class="nav-text">effect</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZJS"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">ZJS</p>
  <div class="site-description" itemprop="description">你找到我了呀！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/1525039433@qq.com" title="E-Mail → 1525039433@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZJS</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
